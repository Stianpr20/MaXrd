(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
(* Start package *)
BeginPackage["MaXrd`"];

(* Import usage messages from file *)
If[!FailureQ@FindFile[#],Get@FindFile[#]]&["MaXrd/Core/Messages.txt"];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
AttenuationCoefficient::invalidSource="The source \[LeftGuillemet]`1`\[RightGuillemet] is invalid.";
AttenuationCoefficient::invcoeff="The \[LeftGuillemet]`1`\[RightGuillemet] coefficient is not recognised.";
AttenuationCoefficient::peOnly="Only the photoelectric cross section is related to \!\(\*
StyleBox[FormBox[SuperscriptBox[\"f\", \"\[Prime]\[Prime]\",\nMultilineFunction->None],
TraditionalForm], \"TI\"]\).";
AttenuationCoefficient::asfLambda="The wavelength, `1` \[CapitalARing], must be smaller than 2.5 \[CapitalARing] when using \!\(\*FormBox[SuperscriptBox[\(f\), \(\[DoublePrime]\)],
TraditionalForm]\).";

Options@AttenuationCoefficient={
"Coefficient"->"LinearAttenuation",
"MassCoefficientMethod"->"DivideByDensity",
(* GetScatteringCrossSections *)
"PhysicalProcess"->"",
"Source"->"xraylib",
"Units"->True
};

SyntaxInformation@AttenuationCoefficient={
"ArgumentsPattern"->{_,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
AttenuationCoefficient[
crystal_String,
lambda:_?(NumericQ[#]||QuantityQ[#]&):-1,
OptionsPattern[]]:=Block[{
\[Lambda],unitsQ=TrueQ@OptionValue["Units"],
coeff=OptionValue["Coefficient"],
mcMethod=OptionValue["MassCoefficientMethod"],
source=OptionValue["Source"],pp=OptionValue["PhysicalProcess"],csDir,asfFile,
V,\[Sigma],\[CapitalSigma],column,atomdata,r,siteM,
fpp,re,\[Mu],\[Rho]
},

(*---* Checking input *---*)
	InputCheck["CrystalQ",crystal];
	\[Lambda]=InputCheck["ProcessWavelength",crystal,lambda];

	csDir=FileNameJoin[{
	$MaXrdPath,"Core","Data","CrossSections",source}];
	asfFile=FileNameJoin[{$MaXrdPath,"Core","Data",
	"AtomicScatteringFactor","AnomalousCorrections",source<>".m"}];
	If[DirectoryQ[csDir]\[Nor]FileExistsQ[asfFile],
		Message[AttenuationCoefficient::invalidSource,source];
		Abort[]];

	(* Processing cross section type *)
	If[
	(* a. Select 'PhysicalProcess' manually *)
	pp=!="",
	column=Which[
	MemberQ[{
	"Photoelectric","Photoionisation"},pp],2,
	MemberQ[{
	"Coherent","Rayleigh","Thompson",
	"Classical","Elastic"},pp],3,
	MemberQ[{
	"Incoherent","Compton","Inelastic"
	},pp],4,
	pp==="Total",5,
	True,Message[AttenuationCoefficient::invproc,pp];Abort[]
	],

	(* b. Select automatically based on coefficient type *)
	column=Which[
	MemberQ[
	{"LinearAttenuation","MassAbsorption"},
	coeff],
	5,(* Total = ph.el. + Ray. + Comp. *)

	True,
	Message[AttenuationCoefficient::invcoeff,coeff];
	Abort[]]
	];

(*---* Calculations *---*)
	(* Auxiliary variables *)
	V=Sqrt@Det@GetCrystalMetric@crystal;
	
	(* Calculation method *)
	If[DirectoryQ@csDir,
	(* a. Using cross sections *)
	\[Sigma]=Normal@GetScatteringCrossSections[crystal,\[Lambda],
	"PhysicalProcess"->pp,"Source"->source,"Units"->False];

		(* Multiplying atoms with corresponding cross sections *)
		atomdata=Values@$CrystalData[[crystal,"AtomData",All,
	{"Element","FractionalCoordinates","OccupationFactor"}]];
		atomdata[[All,1]]=StringDelete[atomdata[[All,1]],
		{"+","-",DigitCharacter}];
		atomdata=atomdata/.Join[
		\[Sigma],{Missing["KeyAbsent","OccupationFactor"]->1}];
		r=atomdata[[All,2]];
		siteM=Table[Length@SymmetryEquivalentPositions[
		crystal,r[[a]],"UseCentring"->True],{a,Length@r}];
		atomdata[[All,2]]=siteM;
		\[CapitalSigma]=Total[Times@@@atomdata];
		\[Mu]=\[CapitalSigma]/V,

	(* b. Using f-double-prime *)
		(* Check wavelength *)
		If[\[Lambda]>2.5,
		Message[AttenuationCoefficient::asfLambda,ToString@\[Lambda]];
		Abort[]];

		column=3;(* Force p.e. cross section only *)
		re=2.81794032*^-15;
		fpp=Im@StructureFactor[crystal,{0,0,0},\[Lambda],
		"AbsoluteValue"->False,
		"f1f2Source"->source];
		(* (See formula in documentation page details) *)
		\[Mu]=2*re*\[Lambda]/V*Abs[fpp]*Power[10,18]
	];

	(* Normalise by mass density? *)
	If[coeff==="MassAbsorption"&&mcMethod==="DivideByDensity",
	\[Rho]=CrystalDensity[crystal,"Units"->False];
	If[unitsQ,
	Return@Quantity[\[Mu]/\[Rho],"Centimeters"^2/"Grams"],
	Return[\[Mu]/\[Rho]]]
	];

(* Output linear coefficient *)
If[unitsQ,Quantity[\[Mu],"Centimeters"^(-1)],\[Mu]]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
BraggAngle::invinput="Input must either be the name of a crystal or a metric matrix.";

Options@BraggAngle={
"Units"->True,
"AngleThreshold"->90.*Degree
};

SyntaxInformation@BraggAngle={
"ArgumentsPattern"->{_,_.,_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
BraggAngle[
input_,
lambda:_?(NumericQ[#]||QuantityQ[#]&):-1,
reflections_List,
OptionsPattern[]]:=Block[{
hkl,G,H,\[Lambda]=N@lambda,sl,bragg,angle,angleThreshold
},
(* Check crystal (or metric) and reflection(s) *)
Which[
StringQ@input,
	InputCheck["CrystalQ",input];
	G=GetCrystalMetric@input,
MatrixQ@input,
	G=input,
True,
	Message[BraggAngle::invinput];Abort[]
];

hkl=InputCheck[reflections,"Integer","WrapSingle"];

(* Reciprocal metric *)
H=Chop@N@Inverse@G;

(* Process wavelength *)
\[Lambda]=If[MatrixQ@input,
InputCheck["GetEnergyWavelength",\[Lambda],False],
InputCheck["ProcessWavelength",input,\[Lambda]]];

(* Sin/lambda, from Bragg's law and inner product *)
sl[h_]:=Sqrt[h . H . h]/2.;
bragg[h_]:=N[ArcSin[sl[h]*\[Lambda]]]/.x_Complex->Undefined;
angle=bragg/@hkl;

(* Optional: Truncate at chosen angle threshold *)
angleThreshold=OptionValue["AngleThreshold"];
If[0<=angleThreshold<\[Pi]/2,
angle=Select[angle,(#<=angleThreshold)&]
];
angle=angle/Degree;

(* Option: Units *)
If[OptionValue["Units"],
angle=Quantity[angle,"Degrees"];
angle=angle/.Quantity[Undefined,"Degrees"]->Undefined]; 

(* If only one reflection, return content *)
If[Length@angle==1,First@angle,angle]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ConstructDomains::SectorRegionsInvalidNumberOfPairs="The number of pairs must be a natural number.";
ConstructDomains::SectorRegionsInvalidWidth="Angular width of the sectors must be a number";
ConstructDomains::CompleteDomination="A domain has reached complete domination after `1` cycles.";

Options@ConstructDomains={
"ReturnAllCycles"->False,
"ShowProgress"->False,
"TransitionProbabilities"-><|
0->0.95,1->0.92,2->0.86,3->0.75,4->0.40,5->0.50,6->0.75,7->0.12,8->0.03|>
};

SyntaxInformation@ConstructDomains={
"ArgumentsPattern"->{_,_,_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ConstructDomains[
{A_Integer,B_Integer,C_Integer},
numberOfDomains_Integer,numberOfCycles_Integer,
OptionsPattern[]]:=Block[{
structureSize=A*B*C,
insertionCoordinates,domainTable,cyclesPassed=0,transitionProbabilities=OptionValue["TransitionProbabilities"],
visitOrderInCurrentCycle,currentCellIndex,currentCell,nearest,nearestFiltered,neighbourDomains,numberOfDomainsEqualToSelf,
completeSeries,storeAllCyclesQ=TrueQ@OptionValue["ReturnAllCycles"]
},

insertionCoordinates=InputCheck["GenerateTargetPositions",{A,B,C}];
domainTable=Association@Thread[insertionCoordinates->RandomSample[
Flatten@ConstantArray[
Range@numberOfDomains,\[LeftCeiling]structureSize/numberOfDomains\[RightCeiling]],
structureSize]];

If[TrueQ@OptionValue["ShowProgress"],
PrintTemporary[Row[{
ProgressIndicator@Dynamic[cyclesPassed/numberOfCycles]
}]]
];

completeSeries=Reap@Catch@Do[
visitOrderInCurrentCycle=RandomSample@Range@structureSize;
Do[
currentCellIndex=visitOrderInCurrentCycle[[i]];
currentCell=insertionCoordinates[[currentCellIndex]];
nearest=Nearest[insertionCoordinates,currentCell,26];
nearestFiltered=Select[
Delete[nearest,1],
SquaredEuclideanDistance[currentCell,#]<=3.&];
neighbourDomains=Lookup[domainTable,nearestFiltered,0.];
numberOfDomainsEqualToSelf=Count[neighbourDomains,domainTable[currentCell]];
If[Random[]<transitionProbabilities[numberOfDomainsEqualToSelf],
domainTable[currentCell]=RandomChoice@neighbourDomains],
{i,structureSize}
];

If[storeAllCyclesQ,Sow@Values@domainTable];

If[AllTrue[Values@domainTable,#===First@domainTable&],
Message[ConstructDomains::CompleteDomination,cyclesPassed+1];Throw@domainTable];
cyclesPassed++,numberOfCycles
];

(* Express domain table as '{outputSize, {domains}}' *)
If[storeAllCyclesQ,
{{A,B,C},completeSeries[[2,1]]},
{{A,B,C},Values@domainTable}]
]


(* ::Input::Initialization:: *)
ConstructDomains["SectorRegions",
{A_Integer,B_Integer,C_Integer},regionSettings_List,
OptionsPattern[]]:=Block[{
insertionCoordinates,identifiers,
regions,
MakeSectorRegion,angleStarts,oppositeStarts,allStarts,angleRanges,disks,
FindMatch,n
},

(* Input cheks *)
If[!AllTrue[regionSettings[[All,1]],IntegerQ[#]&&Positive[#]&],
Message[ConstructDomains::SectorRegionsInvalidNumberOfPairs];Abort[]];
If[!AllTrue[regionSettings[[All,2]],NumericQ],
Message[ConstructDomains::SectorRegionsInvalidNumberOfPairs];Abort[]];

(* Auxiliary functions *)
MakeSectorRegion[
numberOfPairs_Integer,
width_?NumericQ,
startAngle_:Null]:=(

If[NumericQ@startAngle,
angleStarts=Table[a,{a,startAngle,2.*\[Pi],2.*\[Pi]/(numberOfPairs*2)}],
angleStarts=RandomReal[{0.,2.*\[Pi]},numberOfPairs]
];
oppositeStarts=angleStarts+\[Pi];
allStarts=Join[angleStarts,oppositeStarts];
angleRanges={#,#+width}&/@allStarts;
disks=Disk[{A/2,B/2},A,#]&/@angleRanges;
RegionUnion@@disks
);

FindMatch[{x_,y_,z_}]:=(
n=Do[If[RegionMember[regions[[i]],{x,y}],Return@i],
{i,Length@regions}];
{x,y,z}->n);

(* Main procedure *)
insertionCoordinates=Flatten[Table[{i,j,0},
{i,0,A-1},{j,0,B-1}],1];
regions=MakeSectorRegion@@@regionSettings;
insertionCoordinates=(FindMatch/@insertionCoordinates)
/.{Null->Length@regions+1};
identifiers=Values@insertionCoordinates;

If[C>1,
identifiers=Flatten@Transpose@ConstantArray[identifiers,C]
];

(* Express domain table as '{outputSize, {domains}}' *)
{{A,B,C},identifiers}
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@CrystalDensity={
"Units"->True
};

SyntaxInformation@CrystalDensity={
"ArgumentsPattern"->{_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
CrystalDensity[crystal_String,OptionsPattern[]]:=Block[
{data,unitsQ,Z,
f,m,V,NA,
X,o,xyz,M,mass,
temp},

(*---* Input check *---*)
	InputCheck["CrystalQ",crystal];
	data=$CrystalData[crystal];
	unitsQ=OptionValue["Units"];

	(* Return density if contained in '$CrystalData' *)
	temp=data["MassDensity"];
	If[!MissingQ[temp],Return@temp];

	(* Lookup formula units *)
	Z=Lookup[data,"FormulaUnits",-1];

(*---* Calculations *---*)
(*--* Common variables *--*)
	(* Volume, converted to cm^3 *)
	V=Sqrt@Det@GetCrystalMetric@crystal;
	If[unitsQ,
	V=Quantity[V*10^(-24),"Centimeters"^3],
	V=V*10^(-24)];

	(* Chemical formula *)
	f=Sort@GetElements[crystal,"Tally"->True];

If[Positive@Z,
(*--* A. Calculate \[Rho] from Z *--*)
	(* Atomic mass of one unit *)
	m=MapAt[$PeriodicTable[#,"StandardAtomicWeight"]&,f,{All,1}];
	m=Total[Times@@#&/@m];
	If[unitsQ,m=Quantity[m,"Grams"/"Moles"]];

	(* Avogadro's constant *)
	If[unitsQ,
	NA=UnitConvert[Quantity["AvogadroConstant"],"Moles"^-1],
	NA=6.022140857*^23];

	(* Calculating \[Rho] *)
	Return[(Z*m)/(V*NA)],


(*--* B. Calculate \[Rho] from atom data, symmetry and occupation *--*)
	(* Elements, occupation factors and coordinates *)
	{X,o,xyz}=Transpose@Values@data[["AtomData",All,
{"Element","OccupationFactor","FractionalCoordinates"}]];
	X=StringDelete[X,{DigitCharacter,"+","-"}];
	o=o/._Missing->1.;

	(* Site multiplicities *)
	M=o*(Length/@(SymmetryEquivalentPositions[
data["SpaceGroup"],xyz]));

	(* Counting *)
	temp=Transpose/@GatherBy[Transpose[{X,M}],First];
	temp=Sort[temp/.{x_List,m_List}/;
Depth[x]===2:>{First@x,Total@m}];

	(* Total atom mass *)
	mass=Total[temp/.{X_String,f_?NumericQ}:>
	f*$PeriodicTable[X,"StandardAtomicWeight"]];
	If[unitsQ,
	mass=UnitConvert[Quantity[mass,"AtomicMassUnit"],"Grams"],
	mass=mass*(1.6605390*^-24)];

	(* Calculated density *)
	Return[mass/V]
]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
CrystalFormulaUnits::mismatch="Element mismatch detected.";

Options@CrystalFormulaUnits={
"IgnoreHydrogen"->True
};

SyntaxInformation@CrystalFormulaUnits={
"ArgumentsPattern"->{_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
CrystalFormulaUnits[
crystal_String,OptionsPattern[]]:=Block[
{data,
\[Rho],f,fWithoutH,m,V,NA,
X,XwithoutH,o,xyz,M,Z,
temp},

(*---* Input check *---*)
	InputCheck["CrystalQ",crystal];
	data=$CrystalData[crystal];

	(* Return Z if contained in '$CrystalData' *)
	temp=data["FormulaUnits"];
	If[!MissingQ[temp],Return@temp];

	(* Lookup density *)
	\[Rho]=Lookup[data,"MassDensity",-1];

(*---* Calculations *---*)
	(* Chemical formula *)
	f=Sort@GetElements[crystal,"Tally"->True];

	(* Atomic mass of one unit *)
	m=MapAt[$PeriodicTable[#,"StandardAtomicWeight"]&,f,{All,1}];
	m=Total[Times@@#&/@m];

	(* Volume [cubic centimeters] and Avogadro's constant *)
	V=Sqrt@Det@GetCrystalMetric[crystal]*Power[10,-24];
	NA=6.022140857*^23;

If[Positive@\[Rho],
(*--* A. Calculate Z from mass denisty *--*)
	(* Calculate formula units from density *)
	If[QuantityQ@\[Rho],\[Rho]=QuantityMagnitude@
	UnitConvert[\[Rho],"Grams"/"Centimeters"^3]];

	(* Calculate formula units from density *)
	Return[\[Rho]*V*NA/m],


(*--* B. Calculate Z by counting symmetry-generated atoms *--*)
	(* Elements, occupation factors and coordinates *)
	{X,o,xyz}=Transpose@Values@data[["AtomData",All,
{"Element","OccupationFactor","FractionalCoordinates"}]];
	X=StringDelete[X,{DigitCharacter,"+","-"}];
	XwithoutH=DeleteCases[X,"H"];
	o=o/._Missing->1.;
	fWithoutH=Sort@DeleteCases[f[[All,1]],"H"];
	
		(* Check: Compare formula and atom data *)
		If[!TrueQ@OptionValue["IgnoreHydrogen"],
		fWithoutH=f;XwithoutH=X];
		If[Sort@DeleteDuplicates@XwithoutH=!=fWithoutH,
		Message[CrystalFormulaUnits::mismatch];Abort[]];

	(* Site multiplicities *)
	M=o*(Length/@(SymmetryEquivalentPositions[
data["SpaceGroup"],#]&/@xyz));

	(* Counting *)
	temp=Transpose/@GatherBy[Transpose[{X,M}],First];
	temp=Sort[temp/.{x_List,m_List}/;
Depth[x]===2:>{First@x,Round@Total@m}];

	(* Check if hydrogen is ignored *)
	If[MemberQ[f,{"H",_}]&&(!MemberQ[temp,{"H",_}]),
	f=DeleteCases[f,{"H",_}];
	temp=DeleteCases[temp,{"H",_}]];

	(* Check agreement of 'Z' *) 
	Z=temp[[All,2]]/f[[All,2]];
		(* a. Common integer factor *)
		If[MatchQ[DeleteDuplicates@Z,{_Integer}],
		Return@First@Z,

		(* b. Calculate density, then find Z *)
		\[Rho]=CrystalDensity[crystal,"Units"->False];
		Z=(\[Rho]*V*NA)/(m);
		Return@Z
	]
]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
CrystalPlot::InvalidMethod="\"AtomSizeMethod\" must either be \"RadiusTable\" or \"DisplacementParameters\".";
CrystalPlot::InvalidDisplay="\"UnitCell\" must be either \"Box\", \"Axes\" or \"None\".";
CrystalPlot::InvalidOpacityMap="Keys of \"OpacityMap\" must be \"Host\", \"Guest\" or a chemical element, which was not the case for: `1`.";
CrystalPlot::InvalidAtomRadiusType="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid setting for \"AtomRadiusType\".";
CrystalPlot::NoAtomData="\[LeftGuillemet]`1`\[RightGuillemet] does not contain any atom data.";

Options@CrystalPlot=SortBy[Normal@Union[
Association@Options@Graphics3D,<|
"AtomRadius"->0,
"AtomRadiusType"->"CovalentRadius",
"AxisFunction"->Line,
"BondRadius"->0.1,
"Bonds"->True,
"Ellipsoids"->False,
"OpacityMap"-><||>,
"RGBStyle"->True,
"StructureSize"->{0,0,0},
"UnitCellDisplay"->"Box",
(* Graphics3D *)
Boxed->False,
PlotRange->All,
Lighting->"Neutral",
SphericalRegion->True
|>],ToString[#[[1]]]&];

SyntaxInformation@CrystalPlot={
"ArgumentsPattern"->{_,OptionsPattern[{CrystalPlot,Graphics3D}]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
CrystalPlot[
crystalInput_String,
OptionsPattern[{CrystalPlot,Graphics3D}]]:=Block[{
crystal=crystalInput,opacityKeysCheck,useEllipsoids=TrueQ@OptionValue["Ellipsoids"],
crystalDataOriginal=$CrystalData,
structureSize=OptionValue["StructureSize"],
rgbStyle=TrueQ@OptionValue["RGBStyle"],latticeStyleList,CreateBoxEdges,toCartesianMatrix,toCartesianMatrixTransposed,cartesianADPconverter,
MakeRadiusFromElement,MakeRadiusFromADPs,MakeSemiaxesFromADPs,shapeFunction,extentFunction,MakeAtomObject,
FlattenSphereList,
atomRadius=OptionValue["AtomRadius"],useOneRadiusQ=False,
atomRadiusType=OptionValue["AtomRadiusType"],atomRadii,
latticePlotFunction=OptionValue["AxisFunction"],
atomData,atoms,
basisArrowCoordinates,translations,coordinatePairs,unitCellPlotData,unitCellDisplay=OptionValue["UnitCellDisplay"],
opacityMap=OptionValue["OpacityMap"],
connectedPairs,bondData,cylinders,
plotContent,plotOptions
},

(* Checks *)
InputCheck["CrystalQ",crystal];

If[Lookup[$CrystalData[crystal],"AtomData",{}]==={},
Message[CrystalPlot::NoAtomData,crystal];Abort[]];

opacityKeysCheck=Complement[
Keys@opacityMap,Join[Keys@$PeriodicTable,{"Host","Guest"}]];
If[opacityKeysCheck=!={},
Message[CrystalPlot::InvalidOpacityMap,
StringDelete[ToString@opacityKeysCheck,{"{","}"}]
];Abort[]];

(* Optional: Expand crystal *)
If[structureSize=!={0,0,0},
ExpandCrystal[crystalInput,structureSize,"StoreTemporarily"->True];
crystal=First@Keys@MaXrd`Private`$TempCrystalData;
$CrystalData=MaXrd`Private`$TempCrystalData;
];

(* Auxiliary *)
If[TrueQ@Positive@atomRadius,
(* a. Use a single radius for all atoms *)
useOneRadiusQ=True,

(* b. Look up radii *)
atomRadii=$AtomRadii@atomRadiusType;
If[MissingQ@atomRadii,
Message[CrystalPlot::InvalidAtomRadiusType,atomRadiusType];Abort[]]
];

latticeStyleList=ConstantArray[Black,12];
If[rgbStyle,latticeStyleList[[;;3]]={Red,Green,Blue}];

CreateBoxEdges[{a_,b_,c_},{t1_,t2_,t3_}]:={
a,b,c,
t2[a],t1[b],
t1[c],t2[c],t1[t2[c]],
t3[a],t3[b],t3[t2[a]],t3[t1[b]]
};

toCartesianMatrix=GetCrystalMetric[crystal,"ToCartesian"->True];
toCartesianMatrixTransposed=Transpose@toCartesianMatrix;
cartesianADPconverter=TransformAtomicDisplacementParameters[
crystal,"CartesianConverter"];

If[useOneRadiusQ,
MakeRadiusFromElement[element_]:=atomRadius,
MakeRadiusFromElement[element_]:=atomRadii@element
];
MakeSemiaxesFromADPs[ADPs_]:=If[ListQ@ADPs,
2.36597*#,#]&@cartesianADPconverter@ADPs;(* 2.36597 = InverseCDF[ChiSquareDistribution@3,0.5] *)
(*X=1.5382*X;*)

{shapeFunction,extentFunction}=If[useEllipsoids,
{Ellipsoid,MakeSemiaxesFromADPs},
{Sphere,MakeRadiusFromElement}];

MakeAtomObject[{element_,xyz_,opacityTag_,ADPs_},makeSpheresOnly_:False]:={
ColorData["Atoms"][element],

Opacity@If[KeyExistsQ[opacityMap,element],
opacityMap@element,Lookup[opacityMap,opacityTag,1.0]],

shapeFunction[
toCartesianMatrix . xyz,
extentFunction@If[makeSpheresOnly,element,ADPs]]
};

FlattenSphereList[spheres_List]:=Block[{allCoordinates,representant,radius},
allCoordinates=spheres[[All,3,1]];
representant=First@spheres;
radius=representant[[3,2]];
representant[[3]]=Sphere[allCoordinates,radius];
representant
];

(* Preparing atom spheres/ellipsoids *)
atomData=Lookup[$CrystalData[crystal,"AtomData"],
{"Element","FractionalCoordinates","Component","DisplacementParameters"}];
If[DeleteMissing/@atomData==={{}},
(* a. No atom content *)
atoms={},

(* b. Regular procedure *)
atomData[[All,1]]=StringDelete[atomData[[All,1]],{"+","-",DigitCharacter}];
atoms=MakeAtomObject[#,!useEllipsoids]&/@atomData;
If[!useEllipsoids,
atoms=GatherBy[atoms,{#[[{1,2}]],#[[3,2]]}&];
atoms=FlattenSphereList/@atoms]
];

(* Basis/lattice vectors and boxes *)
basisArrowCoordinates={{0,0,0},#}&/@toCartesianMatrixTransposed;
translations=TranslationTransform/@toCartesianMatrixTransposed;

Which[
unitCellDisplay==="Box",
coordinatePairs=CreateBoxEdges[
basisArrowCoordinates,translations];
unitCellPlotData=Table[{
latticeStyleList[[i]],
If[i>3,#,Arrow@#]&@latticePlotFunction@coordinatePairs[[i]]
},{i,Length@coordinatePairs}],

unitCellDisplay==="Axes",
unitCellPlotData=Transpose[{
If[rgbStyle,{Red,Green,Blue},ConstantArray[Black,3]],
Arrow[latticePlotFunction[{{0,0,0},#}]]&/@toCartesianMatrixTransposed
}],

unitCellDisplay==="None",unitCellPlotData={},

True,Message[CrystalPlot::InvalidDisplay];Abort[]
];

(* If crystal was expanded, reset pointer to original $CrystalData *)
If[structureSize=!={0,0,0},$CrystalData=crystalDataOriginal];

(* Atom bonds *)
plotContent=Join[unitCellPlotData,atoms];
If[TrueQ@OptionValue["Bonds"],
connectedPairs=Keys@CP$FindAtomPairs@crystal;
If[connectedPairs=!={},
atomData=GetAtomCoordinates[crystal,
"Cartesian"->True,"GatherElements"->False,"IgnoreCharge"->True];
bondData=Transpose/@(atomData[[#]]&/@connectedPairs);
cylinders=CP$MakeBonds[bondData,OptionValue["BondRadius"]];
plotContent=Join[plotContent,cylinders]
]];

(* Plot options *)
plotOptions=Association@FilterRules[
#->OptionValue[#]&/@(Keys@Options@CrystalPlot),
Options@Graphics3D];

If[
MemberQ[{"Trigonal","Hexagonal"},
GetSymmetryData[crystal,"CrystalSystem"]]&&OptionValue["ViewPoint"]===OptionValue[Graphics3D,ViewPoint],
AssociateTo[plotOptions,ViewPoint->{0,0,\[Infinity]}]
];

(* Plot *)
Graphics3D[
plotContent,
Sequence@@Normal@plotOptions]
]


(* ::Input::Initialization:: *)
CP$FindAtomPairs[crystal_String]:=Block[{
atomData,elements,coordinates,distances,
elementPairs,ranges,$ElementRanges=$AtomRadii["CovalentRadius"],connectedQ
},
atomData=GetAtomCoordinates[crystal,
"Cartesian"->True,"GatherElements"->False,"IgnoreCharge"->True];
{elements,coordinates}=Transpose@atomData;
elements=Flatten@StringCases[elements,RegularExpression["[A-Z][a-z]?"]];
distances=AssociationMap[
EuclideanDistance@@coordinates[[#]]&,
Subsets[Range@Length@coordinates,{2}]];

elementPairs=elements[[#]]&/@Keys@distances;
ranges=Total/@(Lookup[$ElementRanges,#,0]&/@elementPairs);
connectedQ=Thread[ranges*1.10>=Values@distances];(*15% threshold*)

Pick[distances,connectedQ]
]


(* ::Input::Initialization:: *)
CP$MakeBonds[bondDataInput_List,bondRadius_]:=Block[{
SplitPoints,MakeCylinder,
bondData=bondDataInput,colors,coordinates,colorMap,cylinders
},
SplitPoints:={{#1,(#1+#2)/2},{(#1+#2)/2,#2}}&;
MakeCylinder:={#1,Cylinder[#2,bondRadius]}&;

{colors,coordinates}=Transpose@bondData;
colorMap=ColorData["Atoms"];
colors=Map[colorMap,colors,{2}];
coordinates=SplitPoints@@@coordinates;
bondData={colors,coordinates};
bondData=Flatten[Transpose/@Transpose@bondData,1];

MakeCylinder@@@bondData
]


(* ::Input::Initialization:: *)
$ElementRanges=<|"H"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"0.682\"\>",
ShowStringCharacters->False],
0.682,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"He"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"0.616\"\>",
ShowStringCharacters->False],
0.6160000000000001,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Li"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.816\"\>",
ShowStringCharacters->False],
2.8160000000000003`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Be"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.112\"\>",
ShowStringCharacters->False],
2.112,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"B"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"1.870\"\>",
ShowStringCharacters->False],
1.87,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"C"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"1.672\"\>",
ShowStringCharacters->False],
1.6720000000000002`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"N"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"1.562\"\>",
ShowStringCharacters->False],
1.562,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"O"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"1.452\"\>",
ShowStringCharacters->False],
1.4520000000000002`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"F"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"1.254\"\>",
ShowStringCharacters->False],
1.254,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ne"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"1.276\"\>",
ShowStringCharacters->False],
1.276,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Na"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.652\"\>",
ShowStringCharacters->False],
3.652,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Mg"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.102\"\>",
ShowStringCharacters->False],
3.102,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Al"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.662\"\>",
ShowStringCharacters->False],
2.662,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Si"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.442\"\>",
ShowStringCharacters->False],
2.4420000000000006`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"P"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.354\"\>",
ShowStringCharacters->False],
2.3540000000000005`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"S"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.310\"\>",
ShowStringCharacters->False],
2.3100000000000005`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Cl"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.244\"\>",
ShowStringCharacters->False],
2.244,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ar"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.332\"\>",
ShowStringCharacters->False],
2.3320000000000003`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"K"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.466\"\>",
ShowStringCharacters->False],
4.466,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ca"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.872\"\>",
ShowStringCharacters->False],
3.8720000000000003`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Sc"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.740\"\>",
ShowStringCharacters->False],
3.74,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ti"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.520\"\>",
ShowStringCharacters->False],
3.5200000000000005`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"V"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.366\"\>",
ShowStringCharacters->False],
3.3660000000000005`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Cr"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.058\"\>",
ShowStringCharacters->False],
3.058,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Mn"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.058\"\>",
ShowStringCharacters->False],
3.058,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Fe"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.904\"\>",
ShowStringCharacters->False],
2.9040000000000004`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Co"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.772\"\>",
ShowStringCharacters->False],
2.7720000000000002`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ni"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.728\"\>",
ShowStringCharacters->False],
2.728,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Cu"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.904\"\>",
ShowStringCharacters->False],
2.9040000000000004`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Zn"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.684\"\>",
ShowStringCharacters->False],
2.684,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ga"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.684\"\>",
ShowStringCharacters->False],
2.684,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ge"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.640\"\>",
ShowStringCharacters->False],
2.64,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"As"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.618\"\>",
ShowStringCharacters->False],
2.618,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Se"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.640\"\>",
ShowStringCharacters->False],
2.64,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Br"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.640\"\>",
ShowStringCharacters->False],
2.64,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Kr"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.552\"\>",
ShowStringCharacters->False],
2.552,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Rb"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.840\"\>",
ShowStringCharacters->False],
4.840000000000001,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Sr"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.290\"\>",
ShowStringCharacters->False],
4.29,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Y"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.180\"\>",
ShowStringCharacters->False],
4.18,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Zr"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.850\"\>",
ShowStringCharacters->False],
3.8500000000000005`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Nb"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.608\"\>",
ShowStringCharacters->False],
3.608,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Mo"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.388\"\>",
ShowStringCharacters->False],
3.3880000000000003`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Tc"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.234\"\>",
ShowStringCharacters->False],
3.234,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ru"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.212\"\>",
ShowStringCharacters->False],
3.212,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Rh"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.124\"\>",
ShowStringCharacters->False],
3.124,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Pd"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.058\"\>",
ShowStringCharacters->False],
3.058,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ag"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.190\"\>",
ShowStringCharacters->False],
3.19,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Cd"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.168\"\>",
ShowStringCharacters->False],
3.168,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"In"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.124\"\>",
ShowStringCharacters->False],
3.124,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Sn"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.058\"\>",
ShowStringCharacters->False],
3.058,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Sb"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.058\"\>",
ShowStringCharacters->False],
3.058,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Te"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.036\"\>",
ShowStringCharacters->False],
3.036,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"I"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.058\"\>",
ShowStringCharacters->False],
3.058,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Xe"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.080\"\>",
ShowStringCharacters->False],
3.08,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Cs"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"5.368\"\>",
ShowStringCharacters->False],
5.368,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ba"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.730\"\>",
ShowStringCharacters->False],
4.73,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"La"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.554\"\>",
ShowStringCharacters->False],
4.554,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ce"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.488\"\>",
ShowStringCharacters->False],
4.488,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Pr"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.466\"\>",
ShowStringCharacters->False],
4.466,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Nd"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.422\"\>",
ShowStringCharacters->False],
4.422,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Pm"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.378\"\>",
ShowStringCharacters->False],
4.378,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Sm"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.356\"\>",
ShowStringCharacters->False],
4.356,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Eu"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.356\"\>",
ShowStringCharacters->False],
4.356,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Gd"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.312\"\>",
ShowStringCharacters->False],
4.312,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Tb"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.268\"\>",
ShowStringCharacters->False],
4.268,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Dy"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.224\"\>",
ShowStringCharacters->False],
4.224,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ho"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.224\"\>",
ShowStringCharacters->False],
4.224,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Er"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.158\"\>",
ShowStringCharacters->False],
4.158,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Tm"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.180\"\>",
ShowStringCharacters->False],
4.18,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Yb"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.114\"\>",
ShowStringCharacters->False],
4.114000000000001,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Lu"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.114\"\>",
ShowStringCharacters->False],
4.114000000000001,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Hf"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.850\"\>",
ShowStringCharacters->False],
3.8500000000000005`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ta"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.740\"\>",
ShowStringCharacters->False],
3.74,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"W"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.564\"\>",
ShowStringCharacters->False],
3.5640000000000005`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Re"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.322\"\>",
ShowStringCharacters->False],
3.3220000000000005`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Os"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.168\"\>",
ShowStringCharacters->False],
3.168,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ir"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.102\"\>",
ShowStringCharacters->False],
3.102,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Pt"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.992\"\>",
ShowStringCharacters->False],
2.9920000000000004`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Au"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.992\"\>",
ShowStringCharacters->False],
2.9920000000000004`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Hg"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"2.904\"\>",
ShowStringCharacters->False],
2.9040000000000004`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Tl"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.190\"\>",
ShowStringCharacters->False],
3.19,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Pb"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.212\"\>",
ShowStringCharacters->False],
3.212,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Bi"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.256\"\>",
ShowStringCharacters->False],
3.2560000000000002`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Po"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.080\"\>",
ShowStringCharacters->False],
3.08,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"At"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.300\"\>",
ShowStringCharacters->False],
3.3000000000000003`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Rn"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.300\"\>",
ShowStringCharacters->False],
3.3000000000000003`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Fr"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"5.720\"\>",
ShowStringCharacters->False],
5.720000000000001,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ra"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.862\"\>",
ShowStringCharacters->False],
4.862,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ac"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.730\"\>",
ShowStringCharacters->False],
4.73,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Th"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.532\"\>",
ShowStringCharacters->False],
4.532000000000001,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Pa"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"U"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.312\"\>",
ShowStringCharacters->False],
4.312,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Np"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.180\"\>",
ShowStringCharacters->False],
4.18,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Pu"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.114\"\>",
ShowStringCharacters->False],
4.114000000000001,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Am"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.960\"\>",
ShowStringCharacters->False],
3.9600000000000004`,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Cm"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"3.718\"\>",
ShowStringCharacters->False],
3.718,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Bk"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Cf"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Es"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Fm"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Md"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"No"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Lr"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Rf"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Db"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Sg"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Bh"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Hs"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Mt"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ds"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Rg"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Cn"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Nh"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Fl"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Mc"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Lv"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Ts"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\),"Og"->\!\(\*
TagBox[
InterpretationBox[
StyleBox["\<\"4.400\"\>",
ShowStringCharacters->False],
4.4,
AutoDelete->True],
NumberForm[#, {DirectedInfinity[1], 3}]& ]\)|>;


(* ::Input::Initialization:: *)
$AtomRadii=<|
"AtomicRadius"-><|"H"->0.53`,"He"->0.31`,"Li"->1.67`,"Be"->1.12`,"B"->0.87`,"C"->0.67`,"N"->0.56`,"O"->0.48`,"F"->0.42`,"Ne"->0.38`,"Na"->1.9`,"Mg"->1.45`,"Al"->1.18`,"Si"->1.11`,"P"->0.98`,"S"->0.87`,"Cl"->0.79`,"Ar"->0.71`,"K"->2.43`,"Ca"->1.94`,"Sc"->1.84`,"Ti"->1.76`,"V"->1.71`,"Cr"->1.66`,"Mn"->1.61`,"Fe"->1.56`,"Co"->1.52`,"Ni"->1.49`,"Cu"->1.45`,"Zn"->1.42`,"Ga"->1.36`,"Ge"->1.25`,"As"->1.14`,"Se"->1.03`,"Br"->0.94`,"Kr"->0.87`,"Rb"->2.65`,"Sr"->2.19`,"Y"->2.12`,"Zr"->2.06`,"Nb"->1.98`,"Mo"->1.9`,"Tc"->1.83`,"Ru"->1.78`,"Rh"->1.73`,"Pd"->1.69`,"Ag"->1.65`,"Cd"->1.61`,"In"->1.56`,"Sn"->1.45`,"Sb"->1.33`,"Te"->1.23`,"I"->1.15`,"Xe"->1.08`,"Cs"->2.98`,"Ba"->2.53`,"La"->1.655`,"Ce"->1.655`,"Pr"->2.47`,"Nd"->2.06`,"Pm"->2.05`,"Sm"->2.38`,"Eu"->2.31`,"Gd"->2.33`,"Tb"->2.25`,"Dy"->2.28`,"Ho"->2.26`,"Er"->2.26`,"Tm"->2.22`,"Yb"->2.22`,"Lu"->2.17`,"Hf"->2.08`,"Ta"->2.`,"W"->1.93`,"Re"->1.88`,"Os"->1.85`,"Ir"->1.8`,"Pt"->1.77`,"Au"->1.74`,"Hg"->1.71`,"Tl"->1.56`,"Pb"->1.54`,"Bi"->1.43`,"Po"->1.35`,"At"->1.27`,"Rn"->1.2`,"Fr"->1.655`,"Ra"->1.655`,"Ac"->1.655`,"Th"->1.655`,"Pa"->1.655`,"U"->1.655`,"Np"->1.655`,"Pu"->1.655`,"Am"->1.655`,"Cm"->1.655`,"Bk"->1.655`,"Cf"->1.655`,"Es"->1.655`,"Fm"->1.655`,"Md"->1.655`,"No"->1.655`,"Lr"->1.655`,"Rf"->1.655`,"Db"->1.655`,"Sg"->1.655`,"Bh"->1.655`,"Hs"->1.655`,"Mt"->1.655`,"Ds"->1.655`,"Rg"->1.655`,"Cn"->1.655`,"Nh"->1.655`,"Fl"->1.655`,"Mc"->1.655`,"Lv"->1.655`,"Ts"->1.655`,"Og"->1.655`|>,
"CovalentRadius"-><|"H"->0.31`,"He"->0.28`,"Li"->1.28`,"Be"->0.96`,"B"->0.85`,"C"->0.76`,"N"->0.71`,"O"->0.66`,"F"->0.57`,"Ne"->0.58`,"Na"->1.66`,"Mg"->1.41`,"Al"->1.21`,"Si"->1.11`,"P"->1.07`,"S"->1.05`,"Cl"->1.02`,"Ar"->1.06`,"K"->2.03`,"Ca"->1.76`,"Sc"->1.7`,"Ti"->1.6`,"V"->1.53`,"Cr"->1.39`,"Mn"->1.39`,"Fe"->1.32`,"Co"->1.26`,"Ni"->1.24`,"Cu"->1.32`,"Zn"->1.22`,"Ga"->1.22`,"Ge"->1.2`,"As"->1.19`,"Se"->1.2`,"Br"->1.2`,"Kr"->1.16`,"Rb"->2.2`,"Sr"->1.95`,"Y"->1.9`,"Zr"->1.75`,"Nb"->1.64`,"Mo"->1.54`,"Tc"->1.47`,"Ru"->1.46`,"Rh"->1.42`,"Pd"->1.39`,"Ag"->1.45`,"Cd"->1.44`,"In"->1.42`,"Sn"->1.39`,"Sb"->1.39`,"Te"->1.38`,"I"->1.39`,"Xe"->1.4`,"Cs"->2.44`,"Ba"->2.15`,"La"->2.07`,"Ce"->2.04`,"Pr"->2.03`,"Nd"->2.01`,"Pm"->1.99`,"Sm"->1.98`,"Eu"->1.98`,"Gd"->1.96`,"Tb"->1.94`,"Dy"->1.92`,"Ho"->1.92`,"Er"->1.89`,"Tm"->1.9`,"Yb"->1.87`,"Lu"->1.87`,"Hf"->1.75`,"Ta"->1.7`,"W"->1.62`,"Re"->1.51`,"Os"->1.44`,"Ir"->1.41`,"Pt"->1.36`,"Au"->1.36`,"Hg"->1.32`,"Tl"->1.45`,"Pb"->1.46`,"Bi"->1.48`,"Po"->1.4`,"At"->1.5`,"Rn"->1.5`,"Fr"->2.6`,"Ra"->2.21`,"Ac"->2.15`,"Th"->2.06`,"Pa"->2.`,"U"->1.96`,"Np"->1.9`,"Pu"->1.87`,"Am"->1.8`,"Cm"->1.69`,"Bk"->1.46`,"Cf"->1.46`,"Es"->1.46`,"Fm"->1.46`,"Md"->1.46`,"No"->1.46`,"Lr"->1.46`,"Rf"->1.46`,"Db"->1.46`,"Sg"->1.46`,"Bh"->1.46`,"Hs"->1.46`,"Mt"->1.46`,"Ds"->1.46`,"Rg"->1.46`,"Cn"->1.46`,"Nh"->1.46`,"Fl"->1.46`,"Mc"->1.46`,"Lv"->1.46`,"Ts"->1.46`,"Og"->1.46`|>,
"VanDerWaalsRadius"-><|"H"->1.2`,"He"->1.4`,"Li"->1.82`,"Be"->1.8`,"B"->1.8`,"C"->1.7`,"N"->1.55`,"O"->1.52`,"F"->1.47`,"Ne"->1.54`,"Na"->2.27`,"Mg"->1.73`,"Al"->1.8`,"Si"->2.1`,"P"->1.8`,"S"->1.8`,"Cl"->1.75`,"Ar"->1.88`,"K"->2.75`,"Ca"->1.8`,"Sc"->1.8`,"Ti"->1.8`,"V"->1.8`,"Cr"->1.8`,"Mn"->1.8`,"Fe"->1.8`,"Co"->1.8`,"Ni"->1.63`,"Cu"->1.4`,"Zn"->1.39`,"Ga"->1.87`,"Ge"->1.8`,"As"->1.85`,"Se"->1.9`,"Br"->1.85`,"Kr"->2.02`,"Rb"->1.8`,"Sr"->1.8`,"Y"->1.8`,"Zr"->1.8`,"Nb"->1.8`,"Mo"->1.8`,"Tc"->1.8`,"Ru"->1.8`,"Rh"->1.8`,"Pd"->1.63`,"Ag"->1.72`,"Cd"->1.58`,"In"->1.93`,"Sn"->2.17`,"Sb"->1.8`,"Te"->2.06`,"I"->1.98`,"Xe"->2.16`,"Cs"->1.8`,"Ba"->1.8`,"La"->1.8`,"Ce"->1.8`,"Pr"->1.8`,"Nd"->1.8`,"Pm"->1.8`,"Sm"->1.8`,"Eu"->1.8`,"Gd"->1.8`,"Tb"->1.8`,"Dy"->1.8`,"Ho"->1.8`,"Er"->1.8`,"Tm"->1.8`,"Yb"->1.8`,"Lu"->1.8`,"Hf"->1.8`,"Ta"->1.8`,"W"->1.8`,"Re"->1.8`,"Os"->1.8`,"Ir"->1.8`,"Pt"->1.75`,"Au"->1.66`,"Hg"->1.55`,"Tl"->1.96`,"Pb"->2.02`,"Bi"->1.8`,"Po"->1.8`,"At"->1.8`,"Rn"->1.8`,"Fr"->1.8`,"Ra"->1.8`,"Ac"->1.8`,"Th"->1.8`,"Pa"->1.8`,"U"->1.86`,"Np"->1.8`,"Pu"->1.8`,"Am"->1.8`,"Cm"->1.8`,"Bk"->1.8`,"Cf"->1.8`,"Es"->1.8`,"Fm"->1.8`,"Md"->1.8`,"No"->1.8`,"Lr"->1.8`,"Rf"->1.8`,"Db"->1.8`,"Sg"->1.8`,"Bh"->1.8`,"Hs"->1.8`,"Mt"->1.8`,"Ds"->1.8`,"Rg"->1.8`,"Cn"->1.8`,"Nh"->1.8`,"Fl"->1.8`,"Mc"->1.8`,"Lv"->1.8`,"Ts"->1.8`,"Og"->1.8`|>
|>;


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@DarwinWidth={
"Units"->True,
	(* ExtinctionLength *)
	"Polarisation"->"\[Pi]"
};

SyntaxInformation@DarwinWidth={
"ArgumentsPattern"->{_,_,_.,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
DarwinWidth[
crystal_,
lambda:_?(NumericQ[#]||QuantityQ[#]&):-1,
hklInput_List,
\[Gamma]o:_?NumericQ:1.0,
\[Gamma]h:_?NumericQ:1.0,
OptionsPattern[]]:=Block[{
hkl,L,\[Lambda],\[Theta],\[CapitalLambda]o,\[Delta]os},

(* Check input *)
InputCheck["CrystalQ",crystal];
hkl=InputCheck[hklInput,"Integer","WrapSingle"];
L=Length@hkl;
\[Lambda]=InputCheck["ProcessWavelength",crystal,lambda];

(* Miscellaneous preparations *)
\[Theta]=BraggAngle[crystal,\[Lambda],hkl,"Units"->False]*Degree;
\[CapitalLambda]o=ExtinctionLength[crystal,\[Lambda],hkl,\[Gamma]o,\[Gamma]h,
"Polarisation"->OptionValue["Polarisation"],
"Units"->False];

(* Darwin width *)
\[Delta]os=2*\[Lambda]/\[CapitalLambda]o*\[Gamma]h/Sin[2\[Theta]]*(1 (* \[Mu]m *)/(10^4) (* \[CapitalARing] *))*((10^6) (* \[Mu]rad *)/1 (* rad *));
\[Delta]os=Flatten[{Chop@\[Delta]os}];

(* Option: Units *)
If[OptionValue["Units"],
\[Delta]os=\[Delta]os/.x_?NumericQ:>Quantity[x,"Microradians"]];

If[L===1,First@\[Delta]os,\[Delta]os]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
DistortStructure::InvalidDistortionType="\"DistortionType\" must be set to either \"Crystallographic\" or \"Cartesian\".";
DistortStructure::InvalidDimensions="Function and variables must both be three-dimensional.";

Options@DistortStructure={
"DistortionType"->"Crystallographic",
"NewLabel"->""
};

SyntaxInformation@DistortStructure={
"ArgumentsPattern"->{_,_,_,OptionsPattern[{CrystalPlot,VectorPlot3D}]},
"LocalVariables"->{"Solve",{3}}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
DistortStructure[crystal_,vectorField_,variables_,OptionsPattern[]]:=Block[{
newLabel=OptionValue["NewLabel"],
distortionType=OptionValue["DistortionType"],
M,inverseM,f,distortions,
coordinates,coordinatesCartesian,newCoordinates,
crystalCopy
},

(* Input checks *)
InputCheck["CrystalQ",crystal];
If[!StringQ@newLabel||newLabel==="",newLabel=crystal];
If[!MemberQ[{"Cartesian","Crystallographic"},distortionType],
Message[EmbedStructure::InvalidDistortionType];Abort[]];
If[Length/@{vectorField,variables}=!={3,3},
Message[DistortStructure::InvalidDimensions];Abort[]];

(* Vector field function *)
f[xyz_]:=N@vectorField/.Thread[variables->xyz];

(* Calculate individual distortions *)
coordinates=$CrystalData[[crystal,"AtomData",All,"FractionalCoordinates"]];
distortions=f/@coordinates;

(* Determine distortion type *)
If[distortionType==="Cartesian",
M=GetCrystalMetric[crystal,"ToCartesian"->True];
inverseM=Inverse@M;
coordinatesCartesian=M . #&/@coordinates;
newCoordinates=coordinatesCartesian+distortions;
newCoordinates=inverseM . #&/@newCoordinates,

(* Shifts in a pure crystallographic frame *)
newCoordinates=coordinates+distortions
];

(* Create new entry in `$CrystalData` *)
crystalCopy=$CrystalData[crystal];
crystalCopy[["AtomData",All,"FractionalCoordinates"]]=newCoordinates;
AssociateTo[$CrystalData,newLabel->crystalCopy];

(* Update auto-completion *)
InputCheck["Update$CrystalDataAutoCompletion"];

newLabel
];


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
DomainPlot::InputMismatch="Input size does not match size of domain list.";
DomainPlot::InvalidDomainIndex="Domain identifiers must be non-negative integers";

Options@DomainPlot={
"Colours"->{Red,Green,Blue,Yellow,Purple},
"CrystalFamily"->"Cubic",
"GraphicFunction"->Automatic,
Opacity->1.0,
"RotationAnchorReference"->"DomainCentroid",
"RotationAnchorShift"->{0,0,0},
"RotationMap"-><||>
};

SyntaxInformation@DomainPlot={
"ArgumentsPattern"->{{{_,_,_},_},OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
DomainPlot[
{{A_Integer,B_Integer,C_Integer},allDomains_List},
OptionsPattern[]]:=Block[{
domains=allDomains,seriesQ,
twoDimensionalQ,crystalFamily=OptionValue["CrystalFamily"],graphicFunction=OptionValue["GraphicFunction"],coordinates,coordinateDomainMap,M,makePolytope,
rotationMap=OptionValue["RotationMap"],rotationQ,R,
anchorShift=OptionValue["RotationAnchorShift"],
anchorReference=OptionValue["RotationAnchorReference"],
numberOfDomains,preferredColours=OptionValue["Colours"],coloursToUse,colourTable,makeRotatedPolytope,
MakePlot,polytopes,graphicList},

(* Preparations in case of domain series *)
seriesQ=MatchQ[Dimensions@domains,{_,A*B*C}];
If[seriesQ,domains=First@domains(* Check first list only *)];

(* Check input *)
twoDimensionalQ=C===1;
If[(A*B*C)!=Length@domains,
Message[DomainPlot::InputMismatch];Abort[]];
If[AnyTrue[domains,NonNegative[#]\[Nand]IntegerQ[#]&],
Message[DomainPlot::InvalidDomainIndex];Abort[]];

(* Preparations *)
numberOfDomains=Max@domains;
coordinates=InputCheck["GenerateTargetPositions",{A,B,C}];
If[twoDimensionalQ,coordinates=coordinates[[All,{1,2}]]];
coordinateDomainMap=Association@Thread[coordinates->domains];

coloursToUse=Join[preferredColours,
ColorData[96,#]&/@Range[numberOfDomains-Length@preferredColours]];
colourTable=Join[<|0->Transparent|>,Association@Thread[
Range@numberOfDomains->coloursToUse[[;;numberOfDomains]]]];

(* Fitting to given crystal system *)
M=InputCheck["GetCrystalFamilyMetric",
crystalFamily,If[twoDimensionalQ,"2D","3D"]];
coordinateDomainMap=Association@KeyValueMap[
M . #1->#2&,coordinateDomainMap];
If[graphicFunction=!=Automatic,
makePolytope=graphicFunction,
makePolytope[origin_]:=Parallelepiped[origin,Transpose@M]
];

(* Checking any rotations of domains *)
rotationQ=rotationMap=!=<||>;
If[rotationQ,
R=InputCheck["RotationTransformation",
{{A,B,C},domains},{anchorShift,anchorReference,rotationMap}];
makeRotatedPolytope[xyz_,d_]:=If[anchorReference==="Host"||(twoDimensionalQ&&anchorReference=!="Unit"),
GeometricTransformation[makePolytope[xyz],R[d]],
GeometricTransformation[makePolytope[xyz],R[d,xyz]]]
];

(* Preparing graphics *)
MakePlot[domainMap_]:=(
polytopes=If[rotationQ,
KeyValueMap[{colourTable@#2,makeRotatedPolytope[#1,#2]}&,domainMap],
KeyValueMap[{colourTable@#2,makePolytope@#1}&,domainMap]
];
graphicList={Opacity@OptionValue[Opacity],polytopes};
If[twoDimensionalQ,
Graphics[graphicList,Frame->False],
Graphics3D[graphicList,Boxed->False]]);

If[seriesQ,
coordinates=Keys@coordinateDomainMap;
Table[MakePlot@AssociationThread[coordinates->allDomains[[i]]],
{i,Length@allDomains}],

MakePlot@coordinateDomainMap]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
EmbedStructure::InvalidGuestInput="Invalid guest unit input.";
EmbedStructure::InvalidTargetPositions="Invalid position input.";
EmbedStructure::InvalidProbabilities="The probabilities must be numbers between 0 and 1.";
EmbedStructure::InvalidTrimming="Invalid setting for \"TrimBoundary\".";
EmbedStructure::InvalidAlteration="Invalid input for \"Distortions\" or \"Rotations\".";
EmbedStructure::InvalidAlterationValues="Distortion/rotation amplitudes should be numeric and on the form \[Delta] or {\!\(\*SubscriptBox[\(\[Delta]\), \(min\)]\), \!\(\*SubscriptBox[\(\[Delta]\), \(max\)]\)}.";
EmbedStructure::InvalidDistortionType="\"DistortionType\" must be set to either \"Crystallographic\" or \"Cartesian\".";
EmbedStructure::InvalidOverlapRadius="\"OverlapRadius\" must be numeric.";
EmbedStructure::InvalidAnchorReference="Anchor reference type \[LeftGuillemet]`1`\[RightGuillemet] is invalid. Use either \"Host\" or \"Unit\".";

Options@EmbedStructure={
"DataFile"->FileNameJoin[{$MaXrdPath,"UserData","CrystalData.m"}],
"DistortionType"->"Cartesian",
"Distortions"->{0,0,0},
"MatchHostSize"->True,
"NewLabel"->"",
"OverlapPrecedence"->"",
"OverlapRadius"->1.0,
"RotationAnchorReference"->"Unit",
"RotationAnchorShift"->{0,0,0},
"RotationAxes"->IdentityMatrix[3],
"Rotations"->{0,0,0},
"ShowProgress"->False,
"TrimBoundary"->"None"
};

SyntaxInformation@EmbedStructure={
"ArgumentsPattern"->{_,_,_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
EmbedStructure[
guestUnitsInput_,
targetPositionsInput_List,
hostCrystal_String,
OptionsPattern[]
]:=Block[{
newStructureLabel=OptionValue["NewLabel"],
invAbort,conditionFilterQ=False,
crystalDataOriginal=$CrystalData,dataFile=OptionValue["DataFile"],
hostStructureSize,newSize,
probabilities,units,distributionList,i,
guestUnits,guestCopies,crystalLabels,specialCrystalLabels,nonVoidRange,
matchHostSizeQ=TrueQ@OptionValue["MatchHostSize"],
anchorShift=OptionValue["RotationAnchorShift"],
anchorReference=OptionValue["RotationAnchorReference"],
R,rotationAxes=OptionValue["RotationAxes"],
targetPositions=targetPositionsInput,embedLength,latticeTargetPositions,hostCoordinates,mid,
latticeParameters,latticeParametersABC,hostM,hostMinverse,targetPositionsCartesian,
completed,M,T,p,P,CheckAndMakeRuleList,
distortions,rotations,performShift,performTwist,
conditions,list,shift,twist,
MakeAlteration,PrepareAlterationList,
conditionedDistortionsQ=False,conditionedRotationsQ=False,
coordinatesCrystal,coordinatesCartesian,
coordinatesCrystalEmbedded,coordinatesCrystalEmbeddedTranslated,
newCoordinates,newCoordinatesCartesian,
atomDataHost,atomDataGuest,joinedAtomData,boundary,hostCopy,newUnitCellAtomCount,
findOverlap,intervals,checks,atomData1,atomData2,xyz1,xyz2,nearestList,overlappingCoordinates,
overlapPrecedence=OptionValue["OverlapPrecedence"],
overlapRadius=OptionValue["OverlapRadius"]
},

(*--- Input checks ---*)
boundary=OptionValue["TrimBoundary"];
If[!MemberQ[{"Box","None","OuterEdges"},boundary],
Message[EmbedStructure::InvalidTrimming];Abort[]];

If[!NumericQ@overlapRadius,
Message[EmbedStructure::InvalidOverlapRadius];Abort[]];

invAbort[]:=(Message[EmbedStructure::InvalidGuestInput];Abort[]);
Which[
(* A. 'guestUnits' as list of crystals or elements *)
ListQ@guestUnitsInput,
	If[guestUnitsInput==={},invAbort[]];
	Which[
	(* A.a. Regular crystal entries *)
	AllTrue[guestUnitsInput,StringQ]&&(Depth@guestUnitsInput===2),
	Null(* Check complete *),

	(* A.b. Conditional rules *)
	AllTrue[guestUnitsInput,Head[#]===Rule&]&&
	AllTrue[guestUnitsInput[[All,1]],Head[#]===Condition&],
	conditionFilterQ=True,

	True,invAbort[]
	],

(* B. 'guestUnits' as list paired with probabilities *)
Head@guestUnitsInput===Rule,
If[!MatchQ[Length/@guestUnitsInput,x_->x_/;x==x],invAbort[]];
If[!AllTrue[guestUnitsInput[[1]],0.0<=#<=1.0&],
Message[EmbedStructure::InvalidProbabilities];Abort[]],

(* Invalid input *)
True,invAbort[]
];

If[!MatchQ[Dimensions@targetPositionsInput,{_,3}],
Message[EmbedStructure::InvalidTargetPositions];Abort[]];

If[!MemberQ[{"Host","Unit"},anchorReference],
Message[EmbedStructure::InvalidAnchorReference,anchorReference];Abort[]];


(*--- Checking and preparing embeddings ---*)
crystalLabels=DeleteDuplicates@Cases[Flatten[
{hostCrystal,guestUnitsInput}],_String,3];
Scan[InputCheck["CrystalEntityQ",#]&,crystalLabels];
specialCrystalLabels=InputCheck["HandleSpecialLabels",crystalLabels];

overlapRadius=overlapRadius/GetLatticeParameters[
hostCrystal,"Units"->False][[{1,2,3}]];

hostCopy=$CrystalData[hostCrystal];
atomDataHost=hostCopy["AtomData"];
hostCoordinates=atomDataHost[[All,"FractionalCoordinates"]];
hostStructureSize=hostCopy["Notes"]["StructureSize"];
If[!ListQ@hostStructureSize,hostStructureSize={0,0,0}];

(*--- Preparing target positions ---*)
If[matchHostSizeQ&&hostStructureSize=!={0,0,0},
latticeTargetPositions=InputCheck["GenerateTargetPositions",hostStructureSize];
targetPositions=Flatten[Outer[Plus,
latticeTargetPositions,targetPositions,1],1];
targetPositions=DeleteCases[targetPositions,{x_,y_,z_}/;
Or@@MapThread[Greater,{{x,y,z},hostStructureSize}]];
(* If any negative coordinates, assume host is centred around origin *)
If[AnyTrue[Flatten@hostCoordinates,#<-1.&],
mid=\[LeftFloor]hostStructureSize/2.\[RightFloor];
targetPositions=#-mid&/@targetPositions
]];
embedLength=Length@targetPositions;

(* Preparing list to be used *)
guestUnits=Which[
conditionFilterQ,
targetPositions/.Append[guestUnitsInput,
{x_,y_,z_}/;True->"Void"],

Head@guestUnitsInput===Rule,
{probabilities,units}={Keys@#,Values@#}&@guestUnitsInput;
distributionList=Round[probabilities*embedLength];
Which[
Total@distributionList<embedLength,
While[Total@distributionList<embedLength,
i=RandomInteger[{1,Length@distributionList}];
distributionList[[i]]+=1],

Total@distributionList>embedLength,
While[Total@distributionList>embedLength,
i=RandomInteger[{1,Length@distributionList}];
distributionList[[i]]-=1]
];
RandomSample@Flatten@MapThread[
ConstantArray,{units,distributionList}],

True,
PadRight[#,embedLength,#]&@guestUnitsInput
];

guestCopies=$CrystalData/@guestUnits;
nonVoidRange=Complement[
Range@embedLength,
Flatten@Position[guestUnits,"Void"]];
If[nonVoidRange==={},Goto["End"]];

latticeParameters=GetLatticeParameters[
hostCrystal,"Units"->False];
latticeParametersABC=latticeParameters[[;;3]];
hostM=GetCrystalMetric[
hostCrystal,"ToCartesian"->True];
hostMinverse=Inverse@hostM;
targetPositionsCartesian=hostM . #&/@targetPositions;

(*--- Distortions and rotations -- Checks and preparations ---*)
MakeAlteration[c_]:=c;
MakeAlteration[{min_,max_}]:=Hold@RandomReal[{min,max}];
MakeAlteration[{x_,y_,z_}]:=MakeAlteration/@{x,y,z};
PrepareAlterationList[conditionsQ_,ruleList_List]:=If[conditionsQ,
conditions=Append[ruleList,{x_,y_,z_}/;True->{0.,0.,0.}];
list=Map[MakeAlteration,conditions,{2}];
#/.ReleaseHold@list&/@targetPositions,

ReleaseHold@ConstantArray[MakeAlteration/@ruleList,embedLength]
];

distortions=OptionValue["Distortions"];
performShift=distortions=!={0,0,0};

rotations=OptionValue["Rotations"];
performTwist=rotations=!={0,0,0};
rotations=rotations/.{
(c_Condition->r_List):>(N@c->N@r),
{r1_,r2_,r3_}:>N@{r1,r2,r3}
};

p=(NumericQ[#])&;P[x_]:=p[x];P[{x_,y_}]:=p[x]&&p[y];

CheckAndMakeRuleList[input_]:=Check[Which[
(input==={0,0,0})||SubsetQ[{Integer,Real,List},Head/@input],
	{False,CheckAndMakeRuleList[N@input,"Numeric"]},
(AllTrue[Input,Head[#]===Rule&]&&
AllTrue[input[[All,1]],Head[#]===Condition&])||(Head/@input==={Condition,List}),
	{True,CheckAndMakeRuleList[N@input,"Conditions"]},
True,
	Message[EmbedStructure::InvalidAlteration];
	Abort[]
],Abort[]];

	CheckAndMakeRuleList[input_,"Conditions"]:=(
	If[(P/@#)=!={True,True,True}&/@input[[All,2]],
	Message[EmbedStructure::InvalidAlterationValues];
	Abort[]];
	input/.{x_Condition->y_}:>{x->N@y}
	);

	CheckAndMakeRuleList[input_,"Numeric"]:=(
	If[(P/@input)=!={True,True,True},
	Message[EmbedStructure::InvalidAlterationValues];
	Abort[]];
	input
	);

{conditionedDistortionsQ,distortions}=CheckAndMakeRuleList@distortions;
distortions=PrepareAlterationList[conditionedDistortionsQ,distortions];
Which[
OptionValue["DistortionType"]==="Crystallographic",
Null,

OptionValue["DistortionType"]==="Cartesian",
distortions=hostMinverse . #&/@distortions,

True,
Message[EmbedStructure::InvalidDistortionType];Abort[]
];

{conditionedRotationsQ,rotations}=CheckAndMakeRuleList@rotations;
rotations=PrepareAlterationList[conditionedRotationsQ,rotations];

(*--- Actual tranformation -- Loop through each guest unit ---*)
R=If[performTwist,
InputCheck["RotationTransformation",{{0,0,0},{}},
{anchorShift,anchorReference,{},rotationAxes}]
];

completed=0;
If[TrueQ@OptionValue["ShowProgress"],
PrintTemporary[ProgressIndicator@Dynamic[completed/embedLength]]];

Do[
M=GetCrystalMetric[guestUnits[[i]],"ToCartesian"->True];
T=TranslationTransform[targetPositions[[i]]];

coordinatesCrystal=
guestCopies[[i,"AtomData",All,"FractionalCoordinates"]];

coordinatesCartesian=M . #&/@coordinatesCrystal;

coordinatesCrystalEmbedded=hostMinverse . #
&/@coordinatesCartesian;

coordinatesCrystalEmbeddedTranslated=T/@coordinatesCrystalEmbedded;
newCoordinates=coordinatesCrystalEmbeddedTranslated;

(* Optional: Perform shifts, twists or transformations *)
If[performShift||performTwist,

(* Optional: Rotations *)
If[performTwist,
twist=R[rotations[[i]],targetPositionsCartesian[[i]]];
newCoordinatesCartesian=hostM . #&/@newCoordinates;
newCoordinatesCartesian=twist@newCoordinatesCartesian;
newCoordinates=hostMinverse . #&/@newCoordinatesCartesian
];

(* Optional: Distortions *)
If[performShift,
shift=distortions[[i]];
newCoordinates=#+shift&/@newCoordinates]
];

guestCopies[[i,"AtomData",All,"FractionalCoordinates"]]=newCoordinates;
completed++,
{i,nonVoidRange}
];

(*--- Merge guest units with traget crystal ---*)
If[atomDataHost==={<||>},atomDataHost={},
atomDataHost=$CrystalData[hostCrystal,"AtomData"];
atomDataHost=Append[#,"Component"->"Host"]&/@atomDataHost];
atomDataGuest=Flatten@guestCopies[[nonVoidRange,"AtomData"]];
atomDataGuest=Append[#,"Component"->"Guest"]&/@atomDataGuest;

(* Optional: Remove overlapping target positions *)
joinedAtomData=If[!MemberQ[{"Host","Guest"},overlapPrecedence],
(* A. No measure taken against overlapping *)
Join[atomDataHost,atomDataGuest],

(* B. Remove superpositioned atoms *)
findOverlap[point_,region_List]:=(
If[region==={},Return@Nothing];
intervals=MapThread[Interval[{#1-#2,#1+#2}]&,{point,overlapRadius}];
checks=MapThread[IntervalMemberQ[#1,#2]&,{intervals,Transpose@region}];
checks=Position[And@@@Transpose@checks,True];
If[checks=!={},Part[region,Flatten@checks],Nothing]
);
{atomData1,atomData2}=If[overlapPrecedence==="Host",
#,Reverse@#]&@{atomDataHost,atomDataGuest};
{xyz1,xyz2}=Part[#,All,"FractionalCoordinates"]&/@{atomData1,atomData2};
nearestList=Nearest[xyz2,#,5]&/@xyz1;
overlappingCoordinates=Flatten[MapThread[
findOverlap,{xyz1,nearestList}],1];
atomData2=DeleteCases[atomData2,x_/;MemberQ[
overlappingCoordinates,x["FractionalCoordinates"]]];
Join[atomData1,atomData2]
];

(* Optional: Trim the outer boundary *)
If[boundary=!="None",
Which[
boundary==="Box",
joinedAtomData=DeleteCases[joinedAtomData,{x_,y_,z_}/;
Nand@@MapThread[0<=#1<#2&,{{x,y,z},hostStructureSize}],
{2}],

boundary==="OuterEdges",
joinedAtomData=DeleteCases[joinedAtomData,{x_,y_,z_}/;
Nand@@MapThread[0<=#1<#2&,{{x,y},hostStructureSize[[{1,2}]]}],
{2}]
];
joinedAtomData=Select[joinedAtomData,
KeyExistsQ[#,"FractionalCoordinates"]&]
];
joinedAtomData=MapAt[N@Chop[#,10.^-6]&,joinedAtomData,
{All,"FractionalCoordinates"}];
hostCopy["AtomData"]=joinedAtomData;

(* Overwrite host or create new crystal object *)
Label["End"];
Which[
newStructureLabel==="Void",
	newStructureLabel="CustomStructure",
hostCrystal==="Void"&&newStructureLabel==="",
	newStructureLabel="CustomStructure",
newStructureLabel==="",
	newStructureLabel=hostCrystal];

$CrystalData=crystalDataOriginal;

newSize=hostCopy["Notes","StructureSize"]/._Missing->{1,1,1};
newUnitCellAtomCount=\[LeftCeiling]Length@joinedAtomData/Times@@newSize\[RightCeiling];
If[!KeyExistsQ[hostCopy,"Notes"],AppendTo[hostCopy,"Notes"-><||>]];
AppendTo[hostCopy["Notes"],"UnitCellAtomsCount"->newUnitCellAtomCount];
AppendTo[hostCopy["Notes"],"AsymmetricUnitAtomsCount"->Null];
AppendTo[hostCopy["Notes"],"StructureSize"->newSize];

InputCheck["Update$CrystalDataFile",dataFile,newStructureLabel,hostCopy];

newStructureLabel
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ExpandCrystal::InvalidSize="The structure size must be a list of three natural numbers.";
ExpandCrystal::DuplicateLabel="The new label must be different from the input.";

Options@ExpandCrystal={
"DataFile"->FileNameJoin[{$MaXrdPath,"UserData","CrystalData.m"}],
"ExpandIntoNegative"->False,
"FirstTransformTo"->False,
"IgnoreSymmetry"->False,
"IncludeBoundary"->True,
"NewLabel"->"",
"StoreTemporarily"->False
};

SyntaxInformation@ExpandCrystal={
"ArgumentsPattern"->{_,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ExpandCrystal[crystal_String,structureSize_List:{1,1,1},
OptionsPattern[]]:=Block[{
crystalDataOriginal=$CrystalData,dataFile=OptionValue["DataFile"],
newLabel=OptionValue["NewLabel"],
changeCell=OptionValue["FirstTransformTo"],
storeTempQ=TrueQ@OptionValue["StoreTemporarily"],
ignoreSymmetryQ=TrueQ@OptionValue["IgnoreSymmetry"],
crystalData,crystalCopy,atomData,coordinates,spaceGroup,generated,
copyTranslations,mid,atomDataMapUnitCell,
cutoffFunction,atomDataMapExpanded,lengths,
newAtomData
},

(* Input check and data acquisition *)
If[
AllTrue[structureSize,Positive[#]&&IntegerQ[#]&]\[Nand]
Length[structureSize]===3,
Message[ExpandCrystal::InvalidSize];Abort[]];

InputCheck["CrystalQ",crystal];
crystalData=crystalCopy=$CrystalData[crystal];

If[crystal===newLabel,
Message[ExpandCrystal::DuplicateLabel,newLabel];Abort[]];
If[newLabel==="",newLabel=crystal<>"_"<>StringJoin@Riffle[
ToString/@structureSize,"x"]];

(* Optional: Transform cell beforehand *)
If[changeCell=!=False,
InputCheck["InterpretSpaceGroup",changeCell];
AssociateTo[$CrystalData,newLabel->crystalCopy];
UnitCellTransformation[newLabel,changeCell];
crystalData=crystalCopy=$CrystalData[newLabel]
];

(* Expand asymmetric unit to unit cell *)
atomData=crystalData["AtomData"];
coordinates=atomData[[All,"FractionalCoordinates"]];
spaceGroup=crystalData["SpaceGroup"];

(* Optional: Ignory symmetry and simply copy content as is *)
generated=N@If[ignoreSymmetryQ,
Partition[coordinates,1],
SymmetryEquivalentPositions[spaceGroup,#]&/@coordinates
];

(* Generate full content of the unit cell *)
atomDataMapUnitCell=Association@Thread[
Range@Length@atomData->generated];

(* Copy by translation *)
copyTranslations=InputCheck["GenerateTargetPositions",structureSize+1];
atomDataMapExpanded=Flatten[
Outer[Plus,copyTranslations,#,1],
1]&/@atomDataMapUnitCell;

(* Optional: Complete the outer boundary *)
cutoffFunction=If[TrueQ@OptionValue["IncludeBoundary"],
Greater,GreaterEqual];

(* Delete atoms whose coordinates are outside *)
atomDataMapExpanded=DeleteCases[atomDataMapExpanded,{x_,y_,z_}/;
Or@@MapThread[cutoffFunction,{{x,y,z},structureSize}],
{2}];

(* Optional: Center translations around origin *)
If[TrueQ@OptionValue["ExpandIntoNegative"],
mid=\[LeftFloor]structureSize/2.\[RightFloor];
atomDataMapExpanded=Map[#-mid&,atomDataMapExpanded,{2}];
];

(* Create new atom data structure *)
lengths=Values[Length/@atomDataMapExpanded];
newAtomData=Table[
ConstantArray[atomData[[i]],lengths[[i]]],
{i,Length@atomData}];

newAtomData[[All,All,"FractionalCoordinates"]]=
Values@atomDataMapExpanded;
newAtomData=Flatten[newAtomData,1];

(* Create new crystal entry *)
crystalCopy["AtomData"]=newAtomData;
AssociateTo[crystalCopy,"Notes"-><|
"StructureSize"->structureSize,
"UnitCellAtomsCount"->Total[Length/@generated],
"AsymmetricUnitAtomsCount"->Length@atomDataMapUnitCell
|>];

(* If temporary storage was used, reset pointer to original $CrystalData *)
If[storeTempQ,
MaXrd`Private`$TempCrystalData=<|newLabel->crystalCopy|>;
$CrystalData=crystalDataOriginal;
InputCheck["Update$CrystalDataAutoCompletion"],

InputCheck["Update$CrystalDataFile",dataFile,newLabel,crystalCopy]
];

newLabel
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ExportCrystalData::InvalidProgramOrFormat="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid program/format.";
ExportCrystalData::ParameterError="Invalid input parameters.";
ExportCrystalData::DirectoryExpected="An existing output directory was expected.";
ExportCrystalData::InvalidSubtractionMode="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid scattering subtraction mode.";
ExportCrystalData::InvalidImageDimensions="Image dimensions must be two positive integers.";

Options@ExportCrystalData={
"Detailed"->False,
"IncludeStructureSizeInfo"->True
};

SyntaxInformation@ExportCrystalData={
"ArgumentsPattern"->{_,_,_,_.,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ExportCrystalData["DISCUS",crystal_String,outputFile_String,OptionsPattern[]]:=Block[{
crystalData,atomData,size,unitCellAtomCount,latticeParameters,
formatter,appendComma,simpleQ,
preambleTitle,preambleSpaceGroup,preambleCell,preambleCount,preambleAtomsHeader,preamble,
elements,coordinates,dispPars,items,spacesToUse,additional,makeSpace,atoms
},

(* Loading necessary data *)
{crystalData,atomData,size,latticeParameters}=ECD$LoadNecessaries@crystal;
unitCellAtomCount=Lookup[crystalData["Notes"],
"UnitCellAtomsCount",Round[Length[atomData]/Times@@size]];

(* Auxiliary *)
formatter[x_]:=ToString@NumberForm[
N@Chop[x,Power[10.,-5]],{9,6}];
appendComma[x_]:=Map[StringInsert[#,",",-1]&,x,{1}];
simpleQ=!TrueQ@OptionValue["Detailed"];

latticeParameters=If[simpleQ,
ToString/@N@latticeParameters,
Map[formatter,latticeParameters,{1}]];

(* Creating the preamble *)
preambleTitle={"title  ",crystal};
preambleSpaceGroup={"spcgr  ",StringDelete[
$GroupSymbolRedirect[crystalData["SpaceGroup"]]
["Name","HermannMauguinShort"]," "]};
preambleCell={"cell   ",StringJoin@Riffle[latticeParameters,"  "]};
preambleCount={"ncell  ",StringJoin@Riffle[
ToString/@Join[size,{unitCellAtomCount}],
",  "]};
preambleAtomsHeader=If[simpleQ,
{"atoms\n"},
{"atoms      x,              y,              z,             Biso,    Property,  MoleNo,  MoleAt,   Occ\n"}];
preamble=StringJoin@Riffle[{
preambleTitle,preambleSpaceGroup,preambleCell,
If[TrueQ@OptionValue["IncludeStructureSizeInfo"],
preambleCount,Nothing],
preambleAtomsHeader},
{"\n"}
];

(* Extracting atom data *)
elements=ToUpperCase@Lookup[atomData,"Element"];
elements=StringDelete[elements,{"+","-",DigitCharacter}];
coordinates=N@Lookup[atomData,"FractionalCoordinates"];
coordinates=Map[formatter,coordinates,{2}];
If[!simpleQ,coordinates=appendComma@coordinates];
dispPars=TransformAtomicDisplacementParameters[
crystal,"EquivalentIsotropic"]/._Missing->0.;
dispPars=formatter/@dispPars;
If[!simpleQ,dispPars=appendComma@dispPars];
items={elements,Sequence@@Transpose@coordinates,dispPars};

(* Determining spacing information *)
spacesToUse=Transpose@ConstantArray[
{11,16,16,15,8},Length@atomData];
additional="1,       0,       0,   1.000000";
Do[
spacesToUse[[i]]=spacesToUse[[i]]-(StringLength/@items[[i]]),
{i,Length@items-1}];
spacesToUse=Transpose@spacesToUse;
makeSpace[i_,j_]:=ConstantArray[" ",spacesToUse[[i,j]]];

(* Writing atom data *)
atoms=Reap[Do[Sow[{
elements[[i]],makeSpace[i,1],
coordinates[[i,1]],makeSpace[i,2],
coordinates[[i,2]],makeSpace[i,3],
coordinates[[i,3]],makeSpace[i,4],
dispPars[[i]],makeSpace[i,5],
If[simpleQ,"",additional],
"\n"
}],{i,Length@atomData}]][[2,1]];

(* Prepare output and export *)
Export[outputFile,StringJoin[preamble,atoms],"String"]
]


(* ::Input::Initialization:: *)
ExportCrystalData["DIFFUSE",crystal_String,outputDir_String,hklPlane_,indexLimit_,subtractionMode_String,{width_Integer,height_Integer},OptionsPattern[]]:=Block[{
reorganise,source,scatteringFactorTemplate,
crystalData,atomData,allElements,size,latticeParameters,directionCosines,M,
partA,X,Y,Z,unitCells,MakeSitesTable,table,sitesList,
partB,maxPossibleSites,newAtomData,blockLengths,
headerComments,headerData,padWidth,header,scatteringData
},

(* Checks *)
InputCheck["CrystalQ",crystal];
If[!DirectoryQ@outputDir,
Message[ExportCrystalData::DirectoryExpected];Abort[]];
If[!MemberQ[{"N","Y","E","e"},subtractionMode],
Message[ExportCrystalData::InvalidSubtractionMode,subtractionMode];Abort[]];
If[!AllTrue[{width,height},Positive],
Message[ExportCrystalData::InvalidImageDimensions];Abort[]];

(* Auxiliary *)
reorganise[data_Association]:=With[{xyz=data["FractionalCoordinates"]},
{Min/@Transpose[{IntegerPart@xyz+1,size}],
StringJoin[
"   ",
StringPadRight[ToString@DecimalForm[#,{11,5}]&/@FractionalPart@xyz,11],
StringDelete[data["Element"],{DigitCharacter,"+","-"}]
]}
];

MakeSitesTable[stop_Integer]:=(
table=Table[{i,If[i>stop,0,i]},{i,maxPossibleSites}];
table=Map[ToString,table,{2}];
table=StringPadLeft[#,6]&/@table;
StringJoin/@table
);

source=Import@FileNameJoin[
{$MaXrdPath,"Core","Data","AtomicScatteringFactor","InternationalTablesC(3rd).m"}];
scatteringFactorTemplate[element_]:=StringTemplate["'`X`'
`a1`,`b1`,`a2`,`b2`
`a3`,`b3`,`a4`,`b4`,`c`
0.0,0.0"]@Join[source[element],<|"X"->element|>];

(* Loading necessary data *)
{crystalData,atomData,size,latticeParameters}=ECD$LoadNecessaries@crystal;
allElements=DeleteDuplicates@atomData[[All,"Element"]];
allElements=DeleteDuplicates[StringDelete[#,
{DigitCharacter,"+","-"}]&/@allElements];
directionCosines=ToString@DecimalForm[
Cos[#*Degree],{6,5}]&/@N@latticeParameters[[4;;6]];
M=GetCrystalMetric[crystal,"ToCartesian"->True];

(* File 1: Crystal data in 'DIFFUSE' format *)
(* Part B *)
newAtomData=reorganise/@atomData;
newAtomData=DeleteDuplicates/@GatherBy[newAtomData,#[[1]]&];
blockLengths=Length/@newAtomData;
maxPossibleSites=Max@blockLengths;
partB=Flatten@Riffle[
StringTemplate[" `1` `2` `3`"]@@@newAtomData[[All,1,1]],
newAtomData[[All,All,2]]
];

(* Part A *)
sitesList=MakeSitesTable/@blockLengths;
{X,Y,Z}=size;
unitCells=Flatten[Table[
StringTemplate[" `1` `2` `3`"][x,y,z],
{x,1,X},{y,1,Y},{z,1,Z}],2];
partA=Flatten@Transpose[{unitCells,sitesList}];
PrependTo[partA,StringTemplate[" `X` `Y` `Z` `N1` `N1`"]@<|
"X"->X,"Y"->Y,"Z"->Z,"N1"->maxPossibleSites|>];

(* File 2: Input/summary file *)
headerComments={
"Header or structure label",
"Random number seeds",
"Cell coord's; angles are cos(ang)",
"Size of crystal simulation (unit cells)",
"Periodic Boundary?",
"Origin of volume",
"u-axis (bottom right) and image x-dimension",
"v-axis (top left) and image y-dimension",
"w-axis (top right) and image z-dimension",
"sin(theta)/lambda maximum",
"Lot size",
"Number of lots",
"Number of atom sites per cell",
"Number of different atom types (list of sc.coef's below)",
"Subtract average lattice? ('N', 'e', 'E' or 'Y')"
};
headerData={
crystal,
"12645, 9676",
StringTemplate["`1` `2` `3`  `4` `5` `6`"]@@Join[latticeParameters[[1;;3]],directionCosines],
StringTemplate["`1` `2` `3`"]@@size,
"Y",
Sequence@@InputCheck["GetReciprocalImageOrientation",
crystal,hklPlane,indexLimit,{width,height},True],
"3.0",
StringTemplate["`1` `2` `3`"]@@size,
"1",
ToString@maxPossibleSites,
ToString@Length@allElements,
subtractionMode
};
padWidth=Max[StringLength/@headerData]+3;
headerData=StringPadRight[headerData,padWidth];
header=Transpose@{headerData,"! "<>#&/@headerComments};
scatteringData=scatteringFactorTemplate/@allElements;

(* Prepare output and export *)
{
Export[
FileNameJoin[{outputDir,"diffuse_input1_crystal.txt"}],
Join[partA,partB,{"\n"}],
"Table"],
Export[
FileNameJoin[{outputDir,"diffuse_input2_setup.txt"}],
Join[header,scatteringData,{"\n"}],
"Table"]
}
]


(* ::Input::Initialization:: *)
ECD$LoadNecessaries[crystal_String]:=Block[
{crystalData,atomData,crystalNotes,size,latticeParameters},
InputCheck["CrystalQ",crystal];
crystalData=$CrystalData[crystal];
atomData=N@crystalData["AtomData"];
crystalNotes=Lookup[crystalData,"Notes",<||>];
If[!AssociationQ@crystalNotes,crystalNotes=<||>];
size=Lookup[crystalNotes,"StructureSize",
Round/@Max/@Transpose@atomData[[All,"FractionalCoordinates"]]
]/.{0->1};
latticeParameters=GetLatticeParameters[crystal,"Units"->False];
{crystalData,atomData,size,latticeParameters}
]


(* ::Input::Initialization:: *)
ExportCrystalData[invalidProgram_String,rest___]:=(
If[!MemberQ[{"DISCUS","DIFFUSE"},invalidProgram],
Message[ExportCrystalData::InvalidProgramOrFormat,invalidProgram],
Message[ExportCrystalData::ParameterError]];
Abort[]
)


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@ExtinctionLength={
"Polarisation"->"\[Pi]",
"Units"->True
};

SyntaxInformation@ExtinctionLength={
"ArgumentsPattern"->{_,_,_.,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ExtinctionLength[
crystal_,
lambda:_?(NumericQ[#]||QuantityQ[#]&):-1,
hklInput_List,
\[Gamma]o:_?NumericQ:1,
\[Gamma]h:_?NumericQ:1,
OptionsPattern[]]:=Block[{
sg,hkl,L,
\[Lambda],V,\[Theta],R,C,FhFhbar,g,\[CapitalLambda]o,
temp},

(* Check input *)
InputCheck["CrystalQ",crystal];
sg=$CrystalData[crystal,"SpaceGroup"];
hkl=InputCheck[hklInput,"Integer","WrapSingle"];
L=Length@hkl;

(* Wavelength *)
\[Lambda]=InputCheck["ProcessWavelength",crystal,lambda];

(* Unit cell volume *)
V=Sqrt@Det@GetCrystalMetric[crystal];

(* Classical electron radius *)
R=If[OptionValue["Units"],
QuantityMagnitude@UnitConvert[
Quantity["ClassicalElectronRadius"],"Angstroms"],
2.81794032*Power[10,-5](* \[ARing]ngstr\[ODoubleDot]ms *)
];

(* Bragg angle and polarisation *)
\[Theta]=BraggAngle[crystal,\[Lambda],hkl,"Units"->False]*Degree;
C=Flatten[{InputCheck["Polarisation",
OptionValue["Polarisation"],2\[Theta]]}];

(* Structure factors *)
temp=StructureFactor[crystal,#,\[Lambda],"Units"->False]&/@{hkl,-hkl};
temp=Cases[temp,{F_?NumericQ,\[Phi]_?NumericQ}:>F,3];
FhFhbar=Times@@ArrayReshape[temp,{2,L}];

	(* Message about extinction *)
	Do[If[FhFhbar[[i]]==0,
	Message[StructureFactor::extinct,hkl[[i]],sg]
	],{i,L}];

(* Extinction (Pendell\[ODoubleDot]sung) distance *)
If[\[Gamma]o===\[Gamma]h===1,g=1,g=\[Pi]*Sqrt[\[Gamma]o*Abs[\[Gamma]h]]];(* geometrical factor *)
\[CapitalLambda]o=Reap[Do[Quiet@Sow[
(V *g)/(R*\[Lambda]*C[[i]]*Sqrt@FhFhbar[[i]])*(1 (* \[Mu]m *)/(10^4) (* \[CapitalARing] *))],
{i,L}]][[2,1]];
\[CapitalLambda]o=\[CapitalLambda]o/.ComplexInfinity->Undefined;

(* Option: Units *)
If[OptionValue["Units"],
\[CapitalLambda]o=\[CapitalLambda]o/.x_?NumericQ:>Quantity[x,"Micrometers"]];

If[L===1,First@\[CapitalLambda]o,\[CapitalLambda]o]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
FindPixelClusters::method="The method \[LeftGuillemet]`1`\[RightGuillemet] was not recognised.";
FindPixelClusters::pixels="Pixels in the binarised image: `1`.";
FindPixelClusters::dir="Invalid directory.";

Options@FindPixelClusters={
"ClusterRange"->3,
"ClearStatus"->True,
Method->"Median",
"PixelDataFile"->FileNameJoin[{$TemporaryDirectory,"MaXrd","PixelData.m"}],
"RetrieveData"->True,
"ReturnBinaryImage"->False,
"UpdateDataFile"->True
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
FPC$LoadPixelDataFile[dataFile_String]:=Block[{data},
If[!FileExistsQ@dataFile,
Quiet@CreateDirectory[
DirectoryName@dataFile,CreateIntermediateDirectories->True];
Check[Export[dataFile,<||>],Abort[]]];
Import@dataFile
]


(* ::Input::Initialization:: *)
FPC$MakeImageHash[image_Image]:=Hash[image,"Expression","HexString"];


(* ::Input::Initialization:: *)
FPC$LookupPixelData[dataFile_String,image_Image]:=Block[{data,hash},
data=FPC$LoadPixelDataFile@dataFile;
hash=FPC$MakeImageHash@image;
Lookup[data,hash]
]


(* ::Input::Initialization:: *)
FPC$UpdatePixelDataFile[dataFile_String,image_Image,newEntryData_List]:=Block[{data,hash},
data=FPC$LoadPixelDataFile@dataFile;
hash=FPC$MakeImageHash@image;
AppendTo[data,hash->newEntryData];
Export[dataFile,data];
Length@data
]


(* ::Input::Initialization:: *)
FPC$Process[image_Image,OptionsPattern@FindPixelClusters]:=
Module[{
bin,data,L,method,fraction,check,
P,update,start,near,r,progress,status,total,p,i,j,neighbours,new,n,new2,
clusters,k},

(*---* Preparing image *---*)
(* Otsu's cluster variance maximization method *)
bin=Binarize@image;
data=PixelValuePositions[bin,1];
L=Length@data;

(* Option: Choose method *)
method=OptionValue[Method];
If[!MemberQ[{
"Median","Mean","Cluster","HighestFraction","BinariseOnly"},method],
Message[FindPixelClusters::method,method];Abort[]];
If[method==="BinariseOnly",Goto["BinarisationDone"]];

(* Check if further refinement is necessary *)
Which[
L<=20000,Null,
L<=50000,bin=DeleteSmallComponents[bin,Method->method],
True,
	(* Special procedure for very noisy images *)
	fraction=1.00;
	check=True;

	While[check,
	fraction=fraction-0.005;
	bin=Binarize[image,Method->{"BlackFraction", fraction}];
	check=PixelValuePositions[bin,1]=={}];
	bin=DeleteSmallComponents[bin,Method->"Mean"]
];
data=PixelValuePositions[bin,1];
	
(* Option: Return binary image and data length for inspection *)
Label["BinarisationDone"];
If[OptionValue["ReturnBinaryImage"],
Message[FindPixelClusters::pixels,
ToString@NumberForm[Length@data,DigitBlock->3]];
Return@bin
];

(*---* Cluster determination *---*)
(* List of all pixels *)
P={};
update=N@data;
start=First@update;
r=N@OptionValue["ClusterRange"];
near=N@DeleteCases[
Flatten[Table[{i,j},{i,-r,r},{j,-r,r}],1],
{0,0}];
total=Length@data;
progress=total;

(* Dynamic status *)
status=PrintTemporary[
Row[
{Text[Style["Determining pixel clusters:",FontFamily->"Avenir Next",14]],
Spacer[20],
Dynamic@ProgressIndicator[1-progress/total]
},
Alignment->Center
]];

(* Single pixel *)
P=Reap@While[update!={},
(* First iteration *)
p={};

neighbours=start+#&/@near;
new=Intersection[update,neighbours];

	(* Avoid looping over the same single pixel *)
	If[new=={},update=Rest@update];

p=Join[p,new];
update=Complement[update,p];

	(* The next iterations *)
	While[new!={},
	
	(* Current and rest *)
	n=First@new;
	new=Rest@new;

		neighbours=n+#&/@near;
	
	(* Actual new elements *)
	new2=Intersection[update,neighbours];
	p=Join[p,new2];

	update=Complement[update,p];
	new=Join[new,new2];
	];

	(* One pixel done *)
	Sow[p];
	progress=Length@update;
	If[update!={},start=First@update]
];
If[TrueQ@OptionValue["ClearStatus"],NotebookDelete@status];
P=P[[2,1]];
clusters=DeleteCases[P,{}];

(*---* Merge pixel clusters *---*)
P=Reap@Do[
k=Round[
{
Total@clusters[[i,All,1]],
Total@clusters[[i,All,2]]
}/Length@clusters[[i]]
];
Sow[k],
{i,Length@clusters}
];
	
P[[2,1]]
]


(* ::Input::Initialization:: *)
FindPixelClusters[image_Image,options:OptionsPattern[]]:=
Module[{dataFile=OptionValue["PixelDataFile"],imageClusterData},

(* Driver routine -- Check if image has been processed *)
imageClusterData=FPC$LookupPixelData[dataFile,image];

If[!MissingQ@imageClusterData
&&TrueQ@OptionValue["RetrieveData"]
&&!TrueQ@OptionValue["ReturnBinaryImage"],
(* a. Load data *)
Return@imageClusterData,

(* b. Find clusters *)
imageClusterData=FPC$Process[image,options];
If[TrueQ@OptionValue["UpdateDataFile"],
FPC$UpdatePixelDataFile[dataFile,image,imageClusterData]];
imageClusterData
]
]


(* ::Input::Initialization:: *)
FindPixelClusters[images_List,options:OptionsPattern[]]:=Module[
{progress,L,
dataFile=OptionValue["PixelDataFile"],tempDataFile,firstEntry,
image,hash,data,newData
},

(* Dynamic status *)
progress=0;
L=Length@images;

PrintTemporary[
Row[
{Text[Style["Progress:",FontFamily->"Courier",16]],
Spacer[20],
Dynamic@ProgressIndicator[progress/L],
Spacer[20],

Dynamic[Text[Style["Images done: "<>ToString[progress]<>" of "<>ToString@L,FontFamily->"Courier",12]]]
},
Alignment->Center
]];

(* Preparing output file *)
tempDataFile=FileNameJoin[{
$TemporaryDirectory,"MaXrd","PixelData_InProgress.m"}];
Quiet@DeleteFile@tempDataFile;

(* Loop *)
Do[
image=images[[i]];
If[FileExistsQ@image,image=Import@image];
If[!ImageQ@image,progress++;Continue[]];

data=FPC$Process[images[[i]],options];
FPC$UpdatePixelDataFile[tempDataFile,image,data];
progress++,
{i,Length@images}];

(* End *)
newData=Join[FPC$LoadPixelDataFile@dataFile,Import@tempDataFile];
If[TrueQ@OptionValue["UpdateDataFile"],
Quiet@CreateDirectory[
DirectoryName@dataFile,CreateIntermediateDirectories->True];
Export[dataFile,newData],
newData]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
GetAtomCoordinates::InvalidCrystalObject="Invalid crystal object.";
GetAtomCoordinates::PlotObjectInsufficient="Crystal plot object has insufficient lattice information.";

Options@GetAtomCoordinates={
"Cartesian"->False,
"GatherElements"->True,
"IgnoreCharge"->True
};

SyntaxInformation@GetAtomCoordinates={
"ArgumentsPattern"->{_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GetAtomCoordinates[crystalObject_,options:OptionsPattern[]]:=Block[{
atomData,plotData,
toCartesianQ=TrueQ@OptionValue["Cartesian"],
gatherElementsQ=TrueQ@OptionValue["GatherElements"],
ignoreChargeQ=TrueQ@OptionValue["IgnoreCharge"],
transformationMatrix
},

Switch[crystalObject,
_String,
	InputCheck["CrystalQ",crystalObject];
	atomData=Lookup[
	InputCheck["GetAtomData",crystalObject],
	{"Element","FractionalCoordinates"}];
	
	If[gatherElementsQ,
	atomData=Merge[MapThread[Rule,Transpose@atomData],Identity]];

	If[toCartesianQ,
	transformationMatrix=GetCrystalMetric[crystalObject,"ToCartesian"->True];
	atomData=GAC$TransformCoordinates[transformationMatrix,atomData]],

_Graphics3D,
	plotData=Cases[First@crystalObject,x_/;Head@x[[2]]===Opacity];
	plotData=DeleteCases[plotData,_Opacity,2];
	plotData=MapAt[First,plotData,{All,2}];
	plotData=MapThread[Rule,Transpose@plotData];
	plotData=Merge[plotData,Identity];
	plotData=KeyMap[GAC$ColorToElementMap,plotData];
	atomData=Flatten[#,Depth@#-3]&/@plotData;

	If[!gatherElementsQ,
	atomData=List@@@Flatten@KeyValueMap[Thread[#1->#2]&,atomData]
	];

	If[!toCartesianQ,
	transformationMatrix=Inverse@GAC$GetMetricFromPlotVectors@crystalObject;
	atomData=GAC$TransformCoordinates[transformationMatrix,atomData]],
_,
	Message[GetAtomCoordinates::InvalidCrystalObject];Abort[]
];

If[ignoreChargeQ,atomData=atomData/.
x_String:>StringReplace[x,RegularExpression["([A-Z][a-z]?).*"]->"$1"]];

atomData
]


(* ::Input::Initialization:: *)
GAC$ColorToElementMap:=Association[
ColorData["Atoms"][#]->#&/@Keys@$PeriodicTable];


(* ::Input::Initialization:: *)
GAC$GetMetricFromPlotVectors[plotObject_Graphics3D]:=Block[{metric},
metric=Cases[First@plotObject,x_/;Head@x[[2]]===Arrow];
If[metric==={},Message[GetAtomCoordinates::PlotObjectInsufficient];Abort[]];
metric=Transpose@metric[[All,2,1,1,2]]
]


(* ::Input::Initialization:: *)
GAC$TransformCoordinates[transformationMatrix_,coordinates_Association]:=Map[transformationMatrix . #&,coordinates,{2}]
GAC$TransformCoordinates[transformationMatrix_,coordinates_List]:=MapAt[transformationMatrix . #&,coordinates,{All,2}]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
GetAtomicScatteringFactors::source="Invalid data source option.";
GetAtomicScatteringFactors::missing="\[LeftGuillemet]`1`\[RightGuillemet] is missing in data source for the `2`.";
GetAtomicScatteringFactors::slRequired="Crystal name or Sin[\[Theta]]/\[Lambda] values required.";
GetAtomicScatteringFactors::slRange="The value `1` \!\(\*SuperscriptBox[\(\[CapitalARing]\), \(-1\)]\) is out of range for the f0 source `2`.";

Options@GetAtomicScatteringFactors={
"DispersionCorrections"->True,
"f0Source"->"WaasmaierKirfel",
"f1f2Source"->"CromerLiberman",
"IgnoreIonCharge"->True,
"SeparateCorrections"->False
};

SyntaxInformation@GetAtomicScatteringFactors={
"ArgumentsPattern"->{_,_,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GetAtomicScatteringFactors[
crystal_String,
hklInput_List,
input\[Lambda]:_?(NumericQ[#]||QuantityQ[#]&):-1,
OptionsPattern[]]:=Block[{
\[Lambda]=input\[Lambda],hkl,elements,sl,options},

(*---* Basic *---*)
(* Crystal and wavelength/energy *)
\[Lambda]=InputCheck["ProcessWavelength",crystal,\[Lambda],False];

(* Reflection(s) *)
hkl=InputCheck[hklInput,"WrapSingle","Integer"];

(* Processing elements *)
elements=GetElements[crystal,"Tally"->False];

	(* Optional: Remove charge of ions *)
	If[OptionValue["IgnoreIonCharge"],
	elements=DeleteDuplicates@
	StringDelete[elements,
	{DigitCharacter,"+","-"}]];

(* Sin[\[Theta]]/\[Lambda] *)
H=Chop@N@Inverse@GetCrystalMetric[crystal];
sl=Sqrt[# . H . #]/2.&/@hkl;

(*---* Relaying data to main function *---*)
options=#->OptionValue[#]&/@
Keys@Options@GetAtomicScatteringFactors;

GetAtomicScatteringFactors[elements,sl,\[Lambda],Sequence@@options]
]


(* ::Input::Initialization:: *)
GetAtomicScatteringFactors[
inputElements_List,
inputSL_List,
input\[Lambda]:_?(NumericQ[#]||QuantityQ[#]&):-1,
OptionsPattern[]]:=Block[{
\[Lambda]=input\[Lambda],elements=inputElements,sl=inputSL,
f0Source,f1f2Source,$f0Local,$f1f2Local,
upperLimit,ignore,
addCorrectionsQ=TrueQ@OptionValue["DispersionCorrections"],
separateQ=TrueQ@OptionValue["SeparateCorrections"],
ipfQ,
coefficients,akeys,bkeys,a,b,c,
f0,corrections,output,
temp},
(*---* Checking input *---*)
(* Elements *)
elements=InputCheck["InterpretElement",Flatten[{elements}]];

(* Sin[\[Theta]]/\[Lambda] *)
sl=Flatten[{sl}];
If[!AllTrue[sl,TrueQ@Not@Negative[#]&],
Message[GetAtomicScatteringFactors::slRequired];Abort[]];

(* Wavelength *)
If[\[Lambda]!=-1,\[Lambda]=QuantityMagnitude@
InputCheck["GetEnergyWavelength",\[Lambda]]];	

(* Data sources *)
f0Source=OptionValue["f0Source"];
f1f2Source=OptionValue["f1f2Source"];
ignore={"H","He"};

	(* Validating sources *)
	If[!MemberQ[FileBaseName/@FileNames["*.m",
FileNameJoin[{
$MaXrdPath,"Core","Data",
"AtomicScatteringFactor"}]],
f0Source]||
	!MemberQ[FileBaseName/@FileNames["*.m",
FileNameJoin[{
$MaXrdPath,"Core","Data",
"AtomicScatteringFactor","AnomalousCorrections"}]],
f1f2Source],
	Message[GetAtomicScatteringFactors::source];Abort[]];

(*---* Useful variables *---*)
(* Check specific range limits *)
upperLimit=Which[
f0Source==="CromerMann",1.5,
f0Source==="InternationalTablesC(3rd)",2.0,
f0Source==="WaasmaierKirfel",6.0,
True,2.5
];

Do[
temp=sl[[i]];
If[temp>upperLimit,
Message[GetAtomicScatteringFactors::slRange,
ToString@temp,f0Source];
Abort[]],
{i,Length@sl}];

(* Loading source for calculating f0 *)
	(* Setup accumulative variable for the session *)
	If[!AssociationQ@$f0,$f0=<||>];
	If[
	(* a. Check if same source is imported already *)
	KeyExistsQ[$f0,f0Source],
	$f0Local=$f0[f0Source],

	(* b. Import specified data *)
	$f0Local=Import@FileNameJoin[{
	$MaXrdPath,"Core","Data",
	"AtomicScatteringFactor",f0Source<>".m"}];
		(* Update the accumulative variable *)
		AppendTo[$f0,f0Source->$f0Local]
	];

(* Check if atom types are found in $f0 source *)
temp=Complement[elements,Keys@$f0Local];
If[temp=!={},
Message[GetAtomicScatteringFactors::missing,
First@temp,"non-dispersive part (\!\(\*FormBox[SubscriptBox[\(f\), \(0\)],
TraditionalForm]\))"];
Abort[]];

(*---* Calculating form factor (f0) from tabulated data *---*)
ipfQ=Head@First@$f0Local===InterpolatingFunction;
Which[
(* a. Interpolation data *)
(* sin(\[Theta])/\[Lambda] *)
ipfQ,
	(* Non-dispersive part of form factor *)
	f0=Table[{X,$f0Local[X][s]},
	{s,sl},{X,elements}],

(* b. Coefficients *)
True,
	(* Stored with alternating 'a' and 'b'
	and 'c' last *)		
	coefficients=$f0Local[[elements]];

	{akeys,bkeys}=Flatten@StringCases[
Keys@First@coefficients,
#~~DigitCharacter..]&/@{"a","b"};

	{a,b,c}={
	Values/@coefficients[[All,akeys]],
	Values/@coefficients[[All,bkeys]],
	Values@coefficients[[All,"c"]]};

	(* Non-dispersive part of form factor *)
	f0=Table[
	{Keys[coefficients][[i]],
	Total[a[[i]]*Exp[-b[[i]]*(sl[[j]])^2]]+c[[i]]},
	{j,Length@sl},
	{i,Length@elements}]
];

(* Check: Correct normalisation by electrons *)
If[
Abs[If[ipfQ,
$f0Local["C"][0],
Total@Values@$f0Local[["C",akeys]]
+$f0Local["C","c"]]-6(* Carbon: Z=6 *)]>0.5,

f0=f0/.{X_String,f_?NumericQ}:>{X,f*$PeriodicTable[X,"AtomicNumber"]}
];

(*---* Dispersion corrections (f1 + f2) *---*)
	(* Optional: No dispersion corrections *)
	If[\[Lambda]===-1,addCorrectionsQ=False];
	If[!addCorrectionsQ,
	(* Prepare output *)
	output=Map[Association,MapThread[Rule,Transpose[#]]&/@f0];
	Goto["End"]];

	(* Loading source for calculating f' + f'' *)
		(* Setup global variable for the session *)
		If[!AssociationQ@$f1f2,$f1f2=<||>];
		If[
		(* a. Check if same source is imported already *)
		KeyExistsQ[$f1f2,f1f2Source],
		$f1f2Local=$f1f2[f1f2Source],

		(* b. Import specified data *)
		$f1f2Local=Import@FileNameJoin[{
	$MaXrdPath,"Core","Data",
	"AtomicScatteringFactor","AnomalousCorrections",
	f1f2Source<>".m"}];
			(* Update the session's global variable *)
			AppendTo[$f1f2,f1f2Source->$f1f2Local]
		];

	(* Check if atom types are found in $f1f2 source *)
	temp=Complement[elements,Keys@$f1f2Local];
	temp=temp/.Thread[ignore->Nothing];(* ignored elements *)
	If[temp=!={},
	Message[GetAtomicScatteringFactors::missing,
	First@temp,"dispersion corrections (\!\(\*FormBox[\(\*SuperscriptBox[\"f\", \"\[Prime]\",\nMultilineFunction->None] + \*SuperscriptBox[\"f\", \"\[Prime]\[Prime]\",\nMultilineFunction->None]\),
TraditionalForm]\))"];
	Abort[]];

	(* Procedure *)
	Do[
	If[MemberQ[ignore,elements[[j]]],Continue[]];
	corrections=$f1f2Local[elements[[j]]][\[Lambda]];
	AppendTo[f0[[i,j]],corrections],
		{i,Length@sl},
		{j,Length@elements}];

(*---* Preparing and returning association *---*)
If[separateQ,
(* a. Return f0 and f1f2 separated *)
f0=f0/.{
(* Elements with corrections *)
{X_String,f0_?NumericQ,f1f2_?NumericQ}:>
(X-><|"f0"->f0,"f1f2"->f1f2|>),
(* Without corrections (ignored elements) *)
{X_String,f0_?NumericQ}:>(X-><|"f0"->f0,"f1f2"->0.|>)
},

(* b. Return f0 and f1f2 combined *)
f0=f0/.{
(* Elements with corrections *)
{X_String,f0_?NumericQ,f1f2_?NumericQ}:>
(X->f0+f1f2),
(* Without corections (ignored elements) *)
{X_String,f0_?NumericQ}:>(X->f0)
}
];
output=Association/@f0;

Label["End"];
If[Length@output==1,First@output,output]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
GetCrystalMetric::InvalidCategory="Category must be either \"LatticeParameters\" or \"MetricMatrix\".";
GetCrystalMetric::InvalidSpace="\"Space\" must either be \"Direct\", \"Reciprocal\" or \"Both\".";
GetCrystalMetric::InvalidMatrix="Input metric must be a 3\[Times]3 matrix.";
GetCrystalMetric::InvalidList="Expected six numerical lattice parameters.";
GetCrystalMetric::InvalidAssociation="Association expected to contain six lattice parameters with keys \"a\", \"b\", \"c\", \"\[Alpha]\", \"\[Beta]\" and \"\[Gamma]\".";
GetCrystalMetric::InvalidInput="Unable to interpret \[LeftGuillemet]`1`\[RightGuillemet].";

Options@GetCrystalMetric={
"Category"->"MetricMatrix",
"Space"->"Direct",
"Radians"->False,
"RoundAnglesThreshold"->0.001,
"ToCartesian"->False,
"Units"->False
};

SyntaxInformation@GetCrystalMetric={
"ArgumentsPattern"->{_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GetCrystalMetric[userInput_,options:OptionsPattern[]]:=Block[{
outputCategory=OptionValue["Category"],outputSpace=OptionValue["Space"],
inputCategory,reciprocalInputQ,
latticeParameters,outputSettings
},

If[!MemberQ[{"LatticeParameters","MetricMatrix"},outputCategory],
Message[GetCrystalMetric::InvalidCategory];Abort[]];
If[!MemberQ[{"Direct","Reciprocal","Both"},outputSpace],
Message[GetCrystalMetric::InvalidSpace];Abort[]];

latticeParameters=GCM$ExtractLatticeParameters@userInput;
reciprocalInputQ=AnyTrue[latticeParameters,CompatibleUnitQ[#,Quantity[1/"Angstroms"]]&];
latticeParameters=GCM$StandardizeLatticeParameters[
latticeParameters,reciprocalInputQ];

outputSettings=<|
"LatticeQ"->outputCategory==="LatticeParameters",
"Threshold"->OptionValue["RoundAnglesThreshold"],
"ReciprocalQ"->outputSpace==="Reciprocal",
"UnitsQ"->TrueQ@OptionValue["Units"],
"RadiansQ"->TrueQ@OptionValue["Radians"],
"OrthogonalizeQ"->TrueQ@OptionValue["ToCartesian"]
|>;

If[outputSpace==="Both",
GCM$DeliverOutput[latticeParameters,ReplacePart[outputSettings,
"ReciprocalQ"->#]]&/@{False,True},
GCM$DeliverOutput[latticeParameters,outputSettings]]
]


(* ::Input::Initialization:: *)
GCM$DeliverOutput[latticeParameters_,settings_]:=(
If[settings["LatticeQ"],
GCM$DeliverLatticeParameterOutput,
GCM$DeliverMetricMatrixOutput][latticeParameters,settings]
)


(* ::Input::Initialization:: *)
GCM$DeliverLatticeParameterOutput[latticeParameters_,settings_]:=Block[{
output=latticeParameters,\[Delta],reciprocalQ,unitsQ,radiansQ},
{\[Delta],reciprocalQ,unitsQ,radiansQ}=Lookup[settings,
{"Threshold","ReciprocalQ","UnitsQ","RadiansQ"}];
If[reciprocalQ,output=GCM$FlipLatticeParameters@output];
output=GCM$RoundAngles[output,\[Delta]];
If[unitsQ,output=GCM$ApplyUnitsList[output,reciprocalQ]];
If[radiansQ,output[[4;;6]]*=\[Pi]/180];
output
]


(* ::Input::Initialization:: *)
GCM$DeliverMetricMatrixOutput[latticeParameters_,settings_]:=Block[{
output=latticeParameters,reciprocalQ,unitsQ,orthogonalizeQ},
{reciprocalQ,unitsQ,orthogonalizeQ}=Lookup[settings,
{"ReciprocalQ","UnitsQ","OrthogonalizeQ"}];
output=GCM$MakeMetricFromLatticeParameters@output;
If[reciprocalQ,output=Inverse@output];
If[unitsQ,output=GCM$ApplyUnitsMatrix[output,reciprocalQ]];
If[orthogonalizeQ,output=CholeskyDecomposition@output];
output
]


(* ::Input::Initialization:: *)
GCM$ExtractLatticeParameters[userInput_]:=Block[{temp},Switch[userInput,
_String,
temp=InputCheck["CrystalQ",userInput]["LatticeParameters"];
GCM$ExtractLatticeParameters@temp,

_?MatrixQ,
If[!Dimensions[userInput]==={3,3},
Message[GetCrystalMetric::InvalidMatrix];Abort[]];
GCM$MakeLatticeParametersFromMetric@userInput,

_Association,
temp=Lookup[userInput,{"a","b","c","\[Alpha]","\[Beta]","\[Gamma]"}];
If[AnyTrue[temp,MissingQ],Message[GetCrystalMetric::InvalidAssociation];Abort[]];
temp,

_List,
If[!AllTrue[userInput,NumericQ[#]||QuantityQ[#]&]||Length[userInput]!=6,
Message[GetCrystalMetric::InvalidList];Abort[]];
userInput,

_,Message[GetCrystalMetric::InvalidInput,userInput];Abort[]
]
];


(* ::Input::Initialization:: *)
GCM$MakeMetricFromLatticeParameters[latticeParameters_]:=Block[{a,b,c,\[Alpha],\[Beta],\[Gamma]},
{a,b,c,\[Alpha],\[Beta],\[Gamma]}=latticeParameters;
{\[Alpha],\[Beta],\[Gamma]}*=\[Pi]/180;
N@Chop[{
{a^2,a*b*Cos[\[Gamma]],a*c*Cos[\[Beta]]},
{a*b*Cos[\[Gamma]],b^2,b*c*Cos[\[Alpha]]},
{a*c*Cos[\[Beta]],b*c*Cos[\[Alpha]],c^2}}]
]


(* ::Input::Initialization:: *)
GCM$MakeLatticeParametersFromMetric[matrix_]:=Block[{a,b,c,\[Alpha],\[Beta],\[Gamma]},
{a,b,c}=Sqrt@Diagonal@matrix;
\[Alpha]=ArcCos[matrix[[2,3]]/(b*c)]/Degree;
\[Beta]=ArcCos[matrix[[1,3]]/(a*c)]/Degree;
\[Gamma]=ArcCos[matrix[[1,2]]/(a*b)]/Degree;
{a,b,c,\[Alpha],\[Beta],\[Gamma]}
]


(* ::Input::Initialization:: *)
GCM$StandardizeLatticeParameters[latticeParameters_List,reciprocalQ_:False]:=Block[{cell=latticeParameters,lengths,angles},
{lengths,angles}=Part[cell,#]&/@{1;;3,4;;6};
lengths=lengths/.q_Quantity:>UnitConvert[q,If[TrueQ@reciprocalQ,
1/"Angstroms","Angstroms"]];
angles=angles/.q_Quantity:>UnitConvert[q,"Degrees"];
cell=N@QuantityMagnitude[Join@@{lengths,angles}];
If[TrueQ@reciprocalQ,cell=GCM$FlipLatticeParameters@cell];
cell
]


(* ::Input::Initialization:: *)
GCM$RoundAngles[cell_List,threshold_]:=Block[{temp=cell,fr},Do[
fr=FractionalPart@temp[[i]];
If[fr>0.5,fr=1-fr];
If[fr<=threshold,temp[[i]]=Round@temp[[i]]],
{i,4,6}];
temp]


(* ::Input::Initialization:: *)
GCM$ApplyUnitsList[cell_,reciprocalQ_:False]:=Quantity[#1,#2]&@@@Transpose[
{cell,{#1,#1,#1,#2,#2,#2}&@@{If[TrueQ@reciprocalQ,1/"Angstroms","Angstroms"],"Degrees"}}]


(* ::Input::Initialization:: *)
GCM$ApplyUnitsMatrix[metric_,reciprocalQ_:False]:=Quantity[metric,Evaluate@If[
TrueQ@reciprocalQ,1/"Angstroms"^2,"Angstroms"^2]]


(* ::Input::Initialization:: *)
GCM$FlipLatticeParameters[latticeParameters_List]:=Block[{metric},
metric=GCM$MakeMetricFromLatticeParameters@latticeParameters;
GCM$MakeLatticeParametersFromMetric@Inverse@metric
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
GetElements::InvalidFormula="Invalid chemical formula.";
GetElements::InvalidElements="Invalid elements detected: `1`.";

Options@GetElements={
"IgnoreIonCharge"->True,
"Tally"->False
};

SetAttributes[GetElements,Listable];

SyntaxInformation@GetElements={
"ArgumentsPattern"->{_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GetElements[input_String,OptionsPattern[]]:=Block[{formula=input,patternX,groupX,tallyQ=TrueQ@OptionValue["Tally"],elements,temp},
(*---* Check input string *---*)
(*--* A. Crystal name input *--*)
If[MemberQ[Keys@$CrystalData,input],
(* a. Use chemical formula *)
formula=Lookup[$CrystalData@input,"ChemicalFormula",

(* b. Return elements contained in 'AtomData' *)
elements=$CrystalData[[input,"AtomData",All,"Element"]];
If[tallyQ,
(* Return tally *)
Return@Tally@elements,
(* Return elements only *)
Return@DeleteDuplicates@elements
]]];

(*--* B. Chemical formula string *--*)
If[StringContainsQ[ToString@FullForm@formula,"!"],
	(* a. Formatted string *)
		(* Considering the full form *)
		elements=ToString@FullForm@formula;

		(* Marking subscripts with '$' 
		elements=StringReplace[elements,"\\), \\("\[Rule]"$"];*)

		(* Cleaning the full form *)
		elements=StringDelete[elements,
		{"\\!\\(\\*SubscriptBox[\\(",
		"[\\(","\\)]\\)","\\), \\("}],

	(* b. Plain string *)
		elements=formula];

(*---* Useful local variables *---*)
	patternX={_?UpperCaseQ~~_?LowerCaseQ,_?UpperCaseQ};
	groupX[S_]:=StringCases[S,{
	x:patternX~~{n1:DigitCharacter..~~"."~~n2:DigitCharacter..}
	:>{x,ToExpression[n1<>"."<>n2]},
	x:patternX~~n:DigitCharacter..~~pm:{"+","-"}:>{x,n~~pm},
	x:patternX~~pm:{"+","-"}~~n:DigitCharacter...:>{x,n~~pm},
	x:patternX~~n:DigitCharacter...:>{x,ToExpression@n}
	}]/.{""->"1",Null->1};

(*---* Extracting symbols and numbers *---*)
	(* Distribute parenthesis subscripts *)
	elements=StringReplace[elements,
	"("~~p__~~")"~~s:DigitCharacter..
		:>StringJoin[ToString/@Flatten@MapAt[
#*ToExpression[s]&,groupX@p,{All,2}]]
	];

	(* Group elements and corresponding subscripts *)
	elements=groupX@elements;

		(* Check *)
		If[elements==={},
		Message[GetElements::InvalidFormula];Abort[]];
		
		temp=elements[[All,1]];
		temp=InputCheck["InterpretElement",temp];
		temp=DeleteDuplicates@temp;
		temp=Complement[temp,Keys@$PeriodicTable];
		If[temp=!={},
		Message[GetElements::InvalidElements,ToString@temp];
		Abort[]];

	(* Merge equal elements *)
	If[!DuplicateFreeQ[First/@elements],
	elements=MapAt[ToExpression,elements,{All,2}];
	elements=GatherBy[elements,First];
	elements=elements/.x_/;Depth[x]===3:>
	{x[[1,1]],Total@x[[All,2]]}];

	(* Checking for ions *)
	elements=elements/.x_List/;
Depth[x]==2&&StringContainsQ[
ToString@x[[2]],{"+","-"}]:>
	{StringJoin@@x,"1"};

(* Optional: Remove charge of ions *)
If[OptionValue["IgnoreIonCharge"],
elements=MapAt[
StringDelete[#,{DigitCharacter,"+","-"}]&,
elements,{All,1}]
];

(* Confirm that tally numbers are expressions *)
elements=MapAt[ToExpression,elements,{All,2}];

(* Optional: Keep tally of the various atoms *)
If[!tallyQ,elements=DeleteDuplicates[First/@elements]];

elements
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
SyntaxInformation@GetLatticeParameters={
"ArgumentsPattern"->{_,OptionsPattern@GetCrystalMetric}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GetLatticeParameters[input_,options:OptionsPattern@GetCrystalMetric]:=GetCrystalMetric[input,
"Category"->"LatticeParameters","Space"->OptionValue["Space"],options]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
GetLaueClass::missing="No data found on \[LeftGuillemet]`1`\[RightGuillemet].";

SyntaxInformation@GetLaueClass={
"ArgumentsPattern"->{_}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GetLaueClass[symbol_String]:=Block[{g,extract},
(* $CrystalData *)
g=$CrystalData[symbol]["SpaceGroup"];
If[StringQ@g,Goto["End"]];

(* Special case: -3m *)
Which[
symbol=="\!\(\*OverscriptBox[\(3\), \(_\)]\)1m"||symbol=="-31m",Return["\!\(\*OverscriptBox[\(3\), \(_\)]\)1m"],
symbol=="\!\(\*OverscriptBox[\(3\), \(_\)]\)m:r"||symbol=="-3m:r",Return["\!\(\*OverscriptBox[\(3\), \(_\)]\)m:r"],
True,Null
];

(* Point group or space group *)
g=$GroupSymbolRedirect[symbol]["LaueClass"];
If[StringQ@g,Return@g];

(* Point group or space group (alternative setting) *)
extract=FullForm[Quiet@Extract[
$GroupSymbolRedirect,
symbol,Inactivate]][[1,1]];
g=$GroupSymbolRedirect[extract]["LaueClass"];

(* No match *)
If[!StringQ@g,
Message[GetLaueClass::missing,symbol];Abort[],
Return@g];

(* End (for use with $CrystalData) *)
Label["End"];
GetLaueClass[g]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
GetScatteringCrossSections::"invsrc"="Invalid source.";
GetScatteringCrossSections::"invelt"="Invalid element.";
GetScatteringCrossSections::invproc="The scattering process type \[LeftGuillemet]`1`\[RightGuillemet] is not recognised.";
GetScatteringCrossSections::"invwlrange"="The wavelength, `1` \[CapitalARing], must be within (0.001 \[LessEqual] \[Lambda] \[LessEqual] 3.000) \[CapitalARing] when using cross sections.";

Options@GetScatteringCrossSections={
"PhysicalProcess"->"",
"Source"->"xraylib",
"Units"->True
};

SyntaxInformation@GetScatteringCrossSections={
"ArgumentsPattern"->{_,_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GetScatteringCrossSections[input_,
wavelength:_?(NumericQ[#]||QuantityQ[#]&):-1,OptionsPattern[]]:=Block[{
src,unitsQ,elements,\[Lambda]=wavelength,pp=OptionValue["PhysicalProcess"],column,
setpos,\[Sigma],file,read,\[Sigma]i},

(*---* Checks *---*)
(* Chemical element(s) *)
elements=Flatten@GetElements[input];

(* Data source *)
src=FileNameJoin[{$MaXrdPath,"Core","Data","CrossSections",OptionValue["Source"]}];
If[!DirectoryQ@src,Message[GetScatteringCrossSections::"invsrc"];Abort[]];
unitsQ=OptionValue["Units"];

(* Wavelength and its range *)
If[!(0.001<=\[Lambda]<=3.000),
Message[GetScatteringCrossSections::invwlrange,ToString@\[Lambda]];
Abort[]];
\[Lambda]=InputCheck["ProcessWavelength","",wavelength];

(* Column to read from (cross section type) *)
column=Which[
pp==="",5,
MemberQ[{
"Photoelectric","Photoionisation"},pp],2,
MemberQ[{
"Coherent","Rayleigh","Thompson",
"Classical","Elastic"},pp],3,
MemberQ[{
"Incoherent","Compton","Inelastic"
},pp],4,
pp==="Total",5,
True,Message[GetScatteringCrossSections::invproc,pp];Abort[]
];

(*---* Read from file *---*)
(* Stream position in dat files *)
setpos=If[$OperatingSystem==="Windows",65,66]*(Round[1000*\[Lambda]]-1);

(* Extract cross sections; \[Sigma] = \[Sigma](element, wavelength) *)
\[Sigma]={};
Do[
file=OpenRead@FileNameJoin[{src,X<>".dat"}];
SetStreamPosition[file,setpos];
read=Read[file,Record];
\[Sigma]i=ToExpression@StringReplace[StringSplit[read][[column]],
m__~~"E"~~s:{"+","-"}~~e:DigitCharacter..:>
m<>"*10^("<>s<>e<>")"];
If[unitsQ,\[Sigma]i=Quantity[\[Sigma]i,"Barns"]];
Close[file];
AppendTo[\[Sigma],X->\[Sigma]i],
{X,elements}];

(*---* Output *---*)
Association@\[Sigma]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
GetSymmetryData::InvalidLabel="\[LeftGuillemet]`1`\[RightGuillemet] is not a recognised label.";
GetSymmetryData::Incompatible="Incompatible group type and label.";

Options@GetSymmetryData={
"UnambiguousSymbol"->True,
"UseMainEntry"->False
};

SyntaxInformation@GetSymmetryData={
"ArgumentsPattern"->{_,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GetSymmetryData[input_String,label_String:"Lookup",OptionsPattern[]]:=Block[{
group,validLabels,type,data,dataMain,temp},

(* Extract point- or space group (also check $CrystalData) *)
group=InputCheck["GetPointSpaceGroupCrystal",input];
validLabels={"Lookup","Symbol","HermannMauguinFull","HermannMauguinShort",	"HallString","PointGroupNumber","SpaceGroupNumber","LaueClass","CrystalSystem","Centring","MainEntryQ","GroupType","Setting"};

If[!MemberQ[validLabels,label],
Message[GetSymmetryData::InvalidLabel,label];Abort[]];

data=$GroupSymbolRedirect@group;
type=If[MemberQ[$PointGroups,data,Infinity],"PointGroup","SpaceGroup"];

If[
(type==="PointGroup"&&label==="SpaceGroupNumber")||
(type==="SpaceGroup"&&label==="PointGroupNumber"),
Message[GetSymmetryData::incompatible];Abort[]];

If[label==="GroupType",Return@type];

(* Group designation *)
group=If[type==="SpaceGroup",
data["Name","HermannMauguinFull"],
data["Name","Symbol"]
];

If[label=="Centring",
If[type=="PointGroup",Message[GetSymmetryData::Incompatible];Abort[]];
Return@StringTake[group,1]
];

(* Ascertain main entry *)
dataMain=If[type==="SpaceGroup",	
temp=Position[$SpaceGroups,group];
$SpaceGroups[temp[[1,1,1]]],

temp=Position[$PointGroups,data];
$PointGroups[temp[[1,1,1]]]
];

(* Optional: Use main entry corresponding to input *)
If[TrueQ@OptionValue["UseMainEntry"],data=dataMain];

(* Executing commands *)
If[label==="Lookup",Return@data];

If[label==="MainEntryQ",Return@KeyExistsQ[data,type<>"Number"]];

If[MemberQ[{
"Symbol","HermannMauguinFull",
"HermannMauguinShort","HallString"},label],
	
(* Optional: Let output be unambiguous *)
If[TrueQ@OptionValue["UnambiguousSymbol"]&&label==="Symbol",
Return@ToStandardSetting@data["Name","HermannMauguinFull"],
Return@data["Name",label]]
];

If[label==="Setting",Return@data@label];

If[MemberQ[{
"PointGroupNumber","SpaceGroupNumber",
"LaueClass","CrystalSystem"},label],
Return@dataMain@label
]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@GetSymmetryOperations={
"AugmentedMatrix"->True,
"IgnoreTranslations"->False,
"UseCentring"->False
};

SyntaxInformation@GetSymmetryOperations={
"ArgumentsPattern"->{_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
GetSymmetryOperations[input_String,OptionsPattern[]]:=Block[
{symData,operations,pointGroupQ=False,centeringVectors},

symData=$GroupSymbolRedirect@InputCheck["GetPointSpaceGroupCrystal",input];
operations=Lookup[symData,"SymmetryOperations"];
If[MissingQ@operations||AssociationQ@operations,
pointGroupQ=True;
operations=Lookup[If[MissingQ@operations,symData,operations],"MatrixOperations"]
];

If[!pointGroupQ,
If[TrueQ@OptionValue["IgnoreTranslations"],
operations=operations[[All,1]],

If[TrueQ@OptionValue["UseCentring"],
centeringVectors=Quiet@InputCheck["GetCentringVectors",input];
operations=Flatten[Table[
{operations[[i,1]],Mod[operations[[i,2]]+centeringVectors[[j]],1]},
{j,Length@centeringVectors},{i,Length@operations}],1]
]]
];

If[TrueQ@OptionValue["AugmentedMatrix"],AffineTransform/@operations,operations]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ImportCrystalData::subdataInteger="\"\!\(\*
StyleBox[\"ExtractSubdata\", \"Program\"]\)\" must be a positive integer.";
ImportCrystalData::subdataLength="The \!\(\*
StyleBox[\".\", \"Program\"]\)\!\(\*
StyleBox[\"cif\", \"Program\"]\) file has a subdata length of `1`.";
ImportCrystalData::latticeParameters="No lattice parameters were located, or they have an invalid form.";
ImportCrystalData::atomData="No atom data was located.";
ImportCrystalData::SG="Could not determine space group. 'P1' will be used.";
ImportCrystalData::cell="Could not work out the unit cell properly.";
ImportCrystalData::notMaXrd="Data collected using `1` radiation. Errors may occur.";
ImportCrystalData::modulation="Modulated structure detected. Errors may occur.";
ImportCrystalData::SpecialLabel="\[LeftGuillemet]`1`\[RightGuillemet] is a reserved label and should not be used.";

Options@ImportCrystalData={
"DataFile"->FileNameJoin[{$MaXrdPath,"UserData","CrystalData.m"}],
"ExtractSubdata"->1,
"IgnoreIonCharge"->False,
"Notes"-><||>,
"RoundAnglesThreshold"->0.001,
"Units"->True,
"OverwriteWarning"->True
};

SyntaxInformation@ImportCrystalData={
"ArgumentsPattern"->{___,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ImportCrystalData[
{CrystalName_String,
ChemicalFormula:_?StringQ:"",
Z:_?IntegerQ:0,
SpaceGroup_:1,
Wavelength:_?NumericQ:-1
},
GetLatticeParameters_List,
AtomData_List,
OptionsPattern[]
]:=Block[
{choice,name,sg,cell,\[Delta],fr,latticeItem,\[Lambda],itemAtomData,item,dataFile=OptionValue["DataFile"],temp},

(*---* Check if name already exists *---*)
name=If[CrystalName==="",
"ImportedCrystal_"<>DateString["ISODate"],
CrystalName];
If[TrueQ@OptionValue["OverwriteWarning"],
	If[KeyExistsQ[$CrystalData,name],
	choice=ChoiceDialog["\[LeftGuillemet]"<>name<>
"\[RightGuillemet] already exists in $CrystalData.\nDo you want to overwrite this entry?"]];
	If[!choice,Return[]]
];

(*--- Space Group *---*)
sg=InputCheck["GetPointSpaceGroupCrystal",SpaceGroup];
sg=ToStandardSetting@sg;

(*---* Lattice parameters *---*)
If[!AllTrue[GetLatticeParameters,NumericQ[#]&]||
Length@GetLatticeParameters!=6,
Message[ImportCrystalData::latticeParameters]];

	(* Optional: Round angles *)
	cell=GetLatticeParameters;
	\[Delta]=OptionValue["RoundAnglesThreshold"];
	Do[
	fr=FractionalPart@cell[[i]];
	If[fr>0.5,fr=1-fr];
	If[fr<=\[Delta],cell[[i]]=Round@cell[[i]]],
	{i,4,6}];

	(* Optional: Use units *)
	If[OptionValue["Units"],
	Do[
	Which[
	i<=3,cell[[i]]=Quantity[cell[[i]],"Angstroms"],
	i>=4,cell[[i]]=Quantity[cell[[i]],"Degrees"]],
	{i,6}]];

	(* Prepare association entry *)
	latticeItem=Association@
	Thread[{"a","b","c","\[Alpha]","\[Beta]","\[Gamma]"}->cell];

(*---* Wavelength *---*)
	(* Optional: Use units *)
	If[OptionValue["Units"],
	\[Lambda]=Quantity[Wavelength,"Angstroms"],
	\[Lambda]=Wavelength];

(*---* Atom data *---*)
If[AtomData==={},
itemAtomData={<||>},

itemAtomData=Table[
DeleteMissing@Part[AtomData[[i]],{
"Element",
"OccupationFactor",
"SiteSymmetryMultiplicity",
"SiteSymmetryOrder",
"FractionalCoordinates",
"DisplacementParameters",
"Type"}],
{i,Length@AtomData}];

Do[
If[KeyExistsQ[First@itemAtomData,k],
itemAtomData=MapAt[
ToExpression,itemAtomData,{All,Key[k]}]],
	{k,{
	"OccupationFactor",
	"SiteSymmetryMultiplicity",
	"SiteSymmetryOrder",
	"DisplacementParameters"}}
];

	(* Checking strings in coordinates *)
	Do[itemAtomData[[i,"FractionalCoordinates"]]=itemAtomData[[i,"FractionalCoordinates"]]/.x_String:>ToExpression[x],
	{i,Length@itemAtomData}]
];

(*---* Preparing item *---*)
item=<|
	"ChemicalFormula"->ChemicalFormula,
	"FormulaUnits"->Z,
	"SpaceGroup"->sg,
	"LatticeParameters"->latticeItem,
	"Wavelength"->\[Lambda],
	"AtomData"->itemAtomData,
	"Notes"->OptionValue["Notes"]
	|>;

(* Delete certain keys *)
	If[item["ChemicalFormula"]==="",
	KeyDropFrom[item,"ChemicalFormula"]];

	If[item["Notes"]===<||>,
	KeyDropFrom[item,"Notes"]];

	If[!Positive@item["Wavelength"],
	KeyDropFrom[item,"Wavelength"]];

	If[Z===0,
	KeyDropFrom[item,"FormulaUnits"]];

	(* If all occupation factors = 1, delete column *)
	temp=item[["AtomData",All,"OccupationFactor"]];
	If[AllTrue[N@temp,#==1.&],
	item[["AtomData",All]]=KeyDrop[
	item[["AtomData",All]],"OccupationFactor"]];

	(* If all displacement parameters = 0, delete column *)
	temp=item[["AtomData",All,"DisplacementParameters"]];
	If[AllTrue[N@temp,#==0.&],
	item[["AtomData",All]]=KeyDrop[
	item[["AtomData",All]],
	{"DisplacementParameters","Type"}]];


InputCheck["Update$CrystalDataFile",dataFile,name,item];
InputCheck["ShallowDisplayCrystal",name]
]


(* ::Input::Initialization:: *)
ImportCrystalData[ciffile_,Name_String:"",OptionsPattern[]]:=Block[{
(* A. Input check and setup *)name,specialLabels=Join[{"Void"},Keys@$PeriodicTable],import,sub,endstring,enc,left,mid,right,
modulationQ=False,
(* B. Lattice parameters *)cell,x,X,multipleQ,parts,coordCount,
(* C. Atom data *)atomdata,atomtags,c,
(* D. Anisotropic displacement parameters (ADPs) *)anisodata,anisoOrder,P,atomoverview,tags,labels,disp,item,
(* E. Misc data labels (wavelength, formula units) *)\[Lambda],Z,
(* F. Chemical formula *)formula,chemicalformula,L,l,r,checkParentheses,
(* G. Space group *)sgTags,sgData,sg,
(* H. Adding item to dataset *)options,
(* Misc *)temp},

(*---* A. Input check and setup *---*)
If[Name=="",name=FileBaseName[ciffile],name=Name];
If[MemberQ[specialLabels,name],
Message[ImportCrystalData::SpecialLabel,name];Abort[]];

(* A.1. Check file *)
import=Check[Import[ciffile,"String"],Abort[]];
sub=OptionValue["ExtractSubdata"];
	If[!(IntegerQ[#]&&Positive[#]&@sub),
	Message[ImportCrystalData::subdataInteger];
	Abort[]];

(* A.2. Auxiliary variables *)
endstring={"loop_","\n\n",";","#",EndOfString};
enc={"'","\""};(* annotation/enclosing marks *)
{left,mid,right}={"\!\(\*SubscriptBox[\(","\), \(","\)]\)"};

(* A.3. Check radiation type *)
temp=StringCases[import,
Shortest[{
"_diffrn_radiation_type","_diffrn_radiation_probe"}
~~Whitespace~~{"",enc}~~t:LetterCharacter..~~"\n"]:>t];
If[MemberQ[temp,#],Message[ImportCrystalData::notMaXrd,#]]
&/@{"neutron","electron"};

(* A.4. Check for modulation *)
temp=If[StringContainsQ[import,"_space_group_ssg_name"],
modulationQ=True;
Message[ImportCrystalData::modulation]];

(*---* B. Lattice parameters *---*)
(* B.1. Extracting lattice parameters *)
cell=StringCases[import,Shortest[
x:("_cell_"~~{"length","angle"}~~__~~
{DigitCharacter,"."}..)~~
{"(",Whitespace}]:>ToLowerCase@x,
IgnoreCase->True];

	(* Check *)
	If[cell=={},
	Message[ImportCrystalData::latticeParameters];
	Abort[]];

(* B.2. Check for multiplue structures *)
	cell=StringSplit[cell,Whitespace];
	Which[
	Length@cell>6,
		multipleQ=True;parts=Length[cell]/6,
	Length@cell==6,
		multipleQ=False;parts=1,
	True,
		Message[ImportCrystalData::cell];
		Return@cell
	];

	(* Correct ordering *)
	cell=Partition[cell,
	Length@cell/Quotient[Length@cell,6]];

	Do[
	X=cell[[i]];
	x=X[[All,1]];
	P=FindPermutation[x,{
	"_cell_length_a",
	"_cell_length_b",
	"_cell_length_c",
	"_cell_angle_alpha",
	"_cell_angle_beta",
	"_cell_angle_gamma"}];
	cell[[i]]=Permute[X,P],
	{i,Length@cell}];

	cell=cell[[All,All,2]];

(* B.3. Check subdata extraction *)
	(* Verify with fractional coordinates *)
	coordCount=StringCount[import,"_atom_site_fract_x"];
	If[coordCount===0,
	Message[ImportCrystalData::atomData];Abort[]];	
	
	parts=Min[parts,coordCount];

	If[(multipleQ&&sub>parts)||(!multipleQ&&sub!=1),
	Message[ImportCrystalData::subdataLength,parts];
	Abort[]];

	If[!IntegerQ[parts],
	Message[ImportCrystalData::subdataInteger];
	Return@parts];

	(* Extract subdata *)
	cell=ToExpression@cell[[sub]];


(*---* C. Atom data *---*)
Label["AtomData"];

(* C.1. Extracting relevant data block *)
	(* Fractional coordinates *)
	(* Occupation factor *)
	(* Site symmetry multiplicity *)

	(* Extracting _atom_site loop *)
	atomdata=StringCases[import,Shortest[
labels:(Whitespace~~"_atom_site_"~~__~~"\n")~~data:(StartOfLine~~Whitespace...~~LetterCharacter~~__~~"\n")
~~{endstring,"_atom_site_aniso","_"~~Except["a"]}]:>{labels,data}];

		(* No data? *)
		If[atomdata=={},
		Message[ImportCrystalData::atomData];
		Abort[]];

		(* Delete cases containing anisotropy data *)
		atomdata=DeleteCases[atomdata,
		x_/;StringContainsQ[x[[1]],"aniso"]];

	(* Specify sub-data *)
	atomdata=atomdata[[sub]];

(* C.2. Organising data *)
atomtags=Flatten@StringCases[atomdata[[1]],
"_atom_site_"~~{WordCharacter,"_"}..];

atomdata=StringDelete[atomdata[[2]],"("~~DigitCharacter..~~")"];
atomdata=Partition[StringSplit@atomdata,Length@atomtags];
atomdata=DeleteCases[atomdata,x_/;Length[x]!=Length[atomtags]];
atomdata=Association@Thread[atomtags->Transpose@atomdata];

(* C.3 Fixing entries *)
(* If 'site_type_symbol' is missing, copy 'site_label' *)
If[!KeyExistsQ[atomdata,"_atom_site_type_symbol"],
AppendTo[atomdata,
"_atom_site_type_symbol"->atomdata["_atom_site_label"]]];

(* Process and check elements *)
temp=atomdata["_atom_site_type_symbol"];
temp=InputCheck["InterpretElement",temp];

(* Optional: Clear any ion charges *)
If[OptionValue["IgnoreIonCharge"],
temp=StringDelete[temp,{"+","-",DigitCharacter}]];

(* Update 'atomdata' with 'temp' *)
atomdata["_atom_site_type_symbol"]=temp;


(*---* D. Anisotropic displacement parameters *---*)
(* D.1. If missing, use default values for ADP *)
L=Length@First@atomdata;
If[!KeyExistsQ[atomdata,"_atom_site_adp_type"],
AppendTo[atomdata,"_atom_site_adp_type"->ConstantArray["Uiso",L]]];
If[!KeyExistsQ[atomdata,"_atom_site_U_iso_or_equiv"],
AppendTo[atomdata,"_atom_site_U_iso_or_equiv"->ConstantArray[0,L]]];

(* D.2. Anisotropic displacement parameters *)
anisodata=StringCases[import,
Shortest["loop_"~~Whitespace~~
x:("_atom_site_aniso"~~__)~~endstring]:>x];

	(* Check *)
	If[anisodata==={},
	Goto["OrganiseAtomdata"],
	anisodata=anisodata[[sub]]];

(* D.3. Noting the order (permutation) *)
anisoOrder=Flatten@StringCases[anisodata,"U_"~~DigitCharacter..];
P=FindPermutation[{"U_11","U_22","U_33","U_12","U_13","U_23"},anisoOrder];

	(* Nothing there to extract? *)
	temp=Flatten@StringCases[anisodata,
	Shortest["_atom_site_aniso_"~~x__~~Whitespace]:>x];
	c=Flatten@Quiet@Position[temp,
	x_/;StringContainsQ[x,"U"]];

(* D.4. Extracting relevant data and trimming *)
anisodata=StringCases[anisodata,
Shortest["_atom_site_aniso"~~__~~EndOfLine]~~Whitespace~~(* Last line *)
x:(WordCharacter~~__):>x(* Content *)];

(* Check if there is any actual data *)
If[anisodata==={},Goto["OrganiseAtomdata"]];
anisodata=StringSplit[First@anisodata,Whitespace];
anisodata=StringReplace[anisodata,x__~~"("~~__~~")":>x];
anisodata=Partition[anisodata,Length@temp];

(* Correcting parameter order *)
anisodata[[All,c]]=Permute[#,P]&/@anisodata[[All,c]];

(* Associating each atom with values *)
anisodata=Association[
Table[anisodata[[i,1]]->anisodata[[i,c]],
{i,Length@anisodata}]];

(* D.5. Organising the atom data *)
Label["OrganiseAtomdata"];
atomoverview={};
tags={
"_atom_site_occupancy",
"_atom_site_site_symmetry_multiplicity",
"_atom_site_site_symmetry_order"};
labels={
"OccupationFactor",
"SiteSymmetryMultiplicity",
"SiteSymmetryOrder"};

Do[
item=<||>;
AppendTo[item,
"Element"->atomdata[["_atom_site_type_symbol",i]]];
Do[
If[KeyExistsQ[atomdata,tags[[j]]],
AppendTo[item,labels[[j]]->
atomdata[[tags[[j]],i]]]],
{j,Length@tags}];

AppendTo[item,"FractionalCoordinates"->
Evaluate[atomdata[["_atom_site_fract_"<>#,i]]&/@{"x","y","z"}]];
If[StringTake[
atomdata[["_atom_site_adp_type",i]],-3]==="ani",
disp=Part[anisodata,atomdata[["_atom_site_label",i]]],
disp=atomdata[["_atom_site_U_iso_or_equiv",i]]];

AppendTo[item,"DisplacementParameters"->disp];
AppendTo[item,"Type"->atomdata[["_atom_site_adp_type",i]]];
AppendTo[atomoverview,item],{i,Length@First@atomdata}];


(*---* E. Misc data labels *---*)
(* E.1. Wavelength *)
\[Lambda]=StringCases[import,Shortest["_diffrn_radiation_wavelength"~~
Whitespace~~x:{DigitCharacter,"."}..~~Whitespace]:>x];

If[\[Lambda]=={},\[Lambda]=-1,
If[Length@\[Lambda]>1,
\[Lambda]=ToExpression@\[Lambda][[sub]],
\[Lambda]=ToExpression@First@\[Lambda]]];

(* E.2. Forumla units (Z) *)
Z=StringCases[import,Shortest["_cell_formula_units_Z"~~
Whitespace~~z:DigitCharacter]:>z];

If[Z==={},Z=0,Z=ToExpression@First@Z];


(*---* F. Chemical formula *---*)
(* F.1. Extracting formula *)
formula=StringCases[import,
Shortest[#~~{Whitespace,"\n"}..~~{"'","\""}~~f__~~
{"'","\""}~~{Whitespace,"\n"}..]:>f]&/@{
(* Prioritised order *)
"_chemical_formula_iupac",
"_chemical_formula_structural",
"_chemical_formula_sum"};

formula=Select[Flatten@formula,!StringContainsQ[#,{",","?"}]&];
formula=StringDelete[formula,{"\r","~"}];

(* F.2. Check for simplest formula *)
temp=Select[formula,!StringContainsQ[#,"("]&];
If[temp=!={},formula={First@temp}];

(* F.3. Misc treatmeant and possible subdata selection *)
If[formula==={}||formula==={""},
chemicalformula="";Goto["SpaceGroup"]];

formula={StringDelete[StringTrim@First@formula,{"'","\""}]};

If[formula==={""},
chemicalformula="";Goto["SpaceGroup"],
formula=StringSplit@formula];

If[Length@formula>1,
formula=formula[[sub]],
formula=Flatten@formula];

(* F.4. Loop for formatting the chemical formula *)
Label["FormatFormula"];
If[AnyTrue[formula,StringContainsQ[#,{"(",")"}]&],
{l,r}=Flatten@Position[StringPosition[
formula,{"(",")"}],{{_,_}}];
	checkParentheses=True];

chemicalformula={};
Do[
temp=Flatten@StringCases[formula[[i]],
x:LetterCharacter..~~
y:({DigitCharacter,"."})..:>{x,y}];
Which[
temp=={},AppendTo[chemicalformula,formula[[i]]],
temp[[2]]=="1",AppendTo[chemicalformula,temp[[1]]],
True,AppendTo[chemicalformula,left<>temp[[1]]<>mid<>temp[[2]]<>right]],
{i,Length@formula}];

chemicalformula=StringDelete[chemicalformula,{"(",")"}];

(* Adding back parentheses *)
If[checkParentheses,
chemicalformula[[l]]="("<>chemicalformula[[l]];
chemicalformula[[r]]=chemicalformula[[r]]<>")"
];

chemicalformula=StringJoin@chemicalformula;


(*---* G. Space group *---*)
Label["SpaceGroup"];

(* G.1. Prioritised list of data labels *)
sgTags={
"_space_group_name_Hall",
"_space_group_name_H-M_alt",
"_space_group_IT_number",
"_symmetry_space_group_name_Hall",
"_symmetry_space_group_name_H-M",
"_symmetry_Int_Tables_number"};

(* G.2. Extract space group sections from imported data *)
sgData=StringCases[import,Shortest[sgTags~~__~~"loop_"]];
If[Length[sgData]>0,sgData=sgData[[sub]]];
sgData=StringTrim@StringDelete[sgData,"loop_"];

(* G.3. Make association of tags and corresponding info *)
sgData=StringCases[sgData,t:sgTags~~Whitespace~~sg:Shortest[Except[WhitespaceCharacter]~~__]~~{"\n",EndOfString}:>{t->sg}];
sgData=Association@Flatten@sgData;
sgData=DeleteCases[sgData,"?"];

(* G.4. Go through priority order and validate *)
Do[
sg=sgData[sgTags[[i]]];
sg=Quiet@InputCheck["InterpretSpaceGroup",sg,False];
If[sg=!=Null,Break[]],
{i,Length@sgTags}];

(* G.5. For modulated structures *)
If[sg===Null&&modulationQ,
sg=StringCases[import,
"_space_group_ssg_name"~~Whitespace~~
{"'","\""}~~sg__~~{"'","\""}~~"\n":>sg];
sg=StringCases[sg,Shortest[StartOfString~~___
~~sg:(LetterCharacter~~__)~~"("]:>sg];
If[sg=!={},sg=Quiet@InputCheck["InterpretSpaceGroup",
First@Flatten@sg,False]]
];

(* G.6. If missing space group, display message and use 'P1' *)
If[sg===Null,Message[ImportCrystalData::SG];sg="P1"];


(*---* H. Adding item to dataset *---*)
options=Thread[#->OptionValue[#],String]&/@(
First/@Options@ImportCrystalData);

ImportCrystalData[
{name,chemicalformula,Z,sg,\[Lambda]},
cell,atomoverview,
options]
]


(* ::Input::Initialization:: *)
ImportCrystalData["RunDialogue"]:=DialogInput[DynamicModule[{
name,gridA,gridB,currentGrid,updGrid,
sgKeys=Keys@$SpaceGroups,sgNumber=Null,sgSymbol=Null,
crystalSystem,systemParameterFields,parameterFields,
a=Null,b=Null,c=Null,
\[Alpha]=Null,\[Beta]=Null,\[Gamma]=Null,
chemicalFormula=Null,wavelength=Null,massDensity=Null,formulaUnits=Null,
atomdata={},atomdataSummary,updAtomdataSummary,
createDeleteButtons,deleteButtons,createAtomdataPanel,atomdataPanel="(no entries)",updAtomdataPanel,
(* Adding entries *)
element=Null,elementListWithNumber,
coordinates,
coordX=Null,coordY=Null,coordZ=Null,
occupationFactor=Null,
adpType="Isotropic",createAdpField,adpField,
adpU11=Null,adpU22=Null,adpU33=Null,
adpU12=Null,adpU13=Null,adpU23=Null,
adpUiso=Null,ADPs,
updRet,toBeReturned,validQ=False
},

(*---* Setup for grid B *---*)
(* Logic *)
elementListWithNumber=#<>" ("<>
ToString@$PeriodicTable[#,"AtomicNumber"]<>
")"&/@Keys@$PeriodicTable;
elementListWithNumber=Thread[
Keys@$PeriodicTable->elementListWithNumber];

createAdpField[]:=Which[
adpType==="Isotropic",
adpField=Column[{
InputField[Dynamic[adpUiso,(adpUiso=#;updRet[])&],
Number,FieldSize->{5.,1.},FieldHint->"\!\(\*SubscriptBox[\(U\), \(iso\)]\)"],
Spacer[{165.,17.5}]
}],

adpType==="Anisotropic",
adpField=Column[{
Row[{
InputField[Dynamic[adpU11,(adpU11=#;updRet[])&],
Number,FieldSize->{5.,1.},FieldHint->"\!\(\*SubscriptBox[\(U\), \(11\)]\)"],
Spacer[5],
InputField[Dynamic[adpU22,(adpU22=#;updRet[])&],
Number,FieldSize->{5.,1.},FieldHint->"\!\(\*SubscriptBox[\(U\), \(22\)]\)"],
Spacer[5],
InputField[Dynamic[adpU33,(adpU33=#;updRet[])&],
Number,FieldSize->{5.,1.},FieldHint->"\!\(\*SubscriptBox[\(U\), \(33\)]\)"]
}],
Row[{
InputField[Dynamic[adpU12,(adpU12=#;updRet[])&],
Number,FieldSize->{5.,1.},FieldHint->"\!\(\*SubscriptBox[\(U\), \(12\)]\)"],
Spacer[5],
InputField[Dynamic[adpU13,(adpU13=#;updRet[])&],
Number,FieldSize->{5.,1.},FieldHint->"\!\(\*SubscriptBox[\(U\), \(13\)]\)"],
Spacer[5],
InputField[Dynamic[adpU23,(adpU23=#;updRet[])&],
Number,FieldSize->{5.,1.},FieldHint->"\!\(\*SubscriptBox[\(U\), \(23\)]\)"]
}]
}]
];
createAdpField[];

(* Dynamic variable storing input data *)
ADPs=Dynamic[{adpU11,adpU22,adpU33,adpU12,adpU13,adpU23}];
coordinates=Dynamic[{coordX,coordY,coordZ}];

updRet[]:=(
toBeReturned=Association[];

If[element=!=Null,
AssociateTo[toBeReturned,"Element"->element],
KeyDropFrom[toBeReturned,"Element"]];

If[occupationFactor=!=Null,
AssociateTo[toBeReturned,"OccupationFactor"->occupationFactor],
KeyDropFrom[toBeReturned,"OccupationFactor"]];

If[AllTrue[coordinates[[1]],NumericQ],
AssociateTo[toBeReturned,"FractionalCoordinates"->coordinates],
KeyDropFrom[toBeReturned,"FractionalCoordinates"]];

Which[
(adpType==="Anisotropic")&&AllTrue[ADPs[[1]],NumericQ],
	AssociateTo[toBeReturned,"DisplacementParameters"->ADPs];
	AssociateTo[toBeReturned,"Type"->"Uani"],
(adpType==="Isotropic")&&NumericQ@adpUiso,
	AssociateTo[toBeReturned,"DisplacementParameters"->adpUiso];
	AssociateTo[toBeReturned,"Type"->"Uiso"],
True,
	KeyDropFrom[toBeReturned,"DisplacementParameters"]
];

If[(element=!=Null)&&(AllTrue[coordinates[[1]],NumericQ]),
validQ=True,validQ=False]
);
updRet[];
(*---* // End of grid B setup // *---*)

(* Logic *)
systemParameterFields[system_String]:=Which[
system==="Triclinic",
Column[{
Row[{
InputField[Dynamic@a,Number,
FieldHint->"a",FieldSize->{5.,1.},
Enabled->True],
Spacer[5],
InputField[Dynamic@b,Number,
FieldHint->"b",FieldSize->{5.,1.},
Enabled->True],
Spacer[5],
InputField[Dynamic@c,Number,
FieldHint->"c",FieldSize->{5.,1.},
Enabled->True]
}],
Row[{
InputField[Dynamic@\[Alpha],Number,
FieldHint->"\[Alpha]",FieldSize->{5.,1.},
Enabled->True],
Spacer[5],
InputField[Dynamic@\[Beta],Number,
FieldHint->"\[Beta]",FieldSize->{5.,1.},
Enabled->True],
Spacer[5],
InputField[Dynamic@\[Gamma],Number,
FieldHint->"\[Gamma]",FieldSize->{5.,1.},
Enabled->True]
}]
}],

system==="Monoclinic",
Column[{
Row[{
InputField[Dynamic@a,Number,
FieldHint->"a",FieldSize->{5.,1.},
Enabled->True],
Spacer[5],
InputField[Dynamic@b,Number,
FieldHint->"b",FieldSize->{5.,1.},
Enabled->True],
Spacer[5],
InputField[Dynamic@c,Number,
FieldHint->"c",FieldSize->{5.,1.},
Enabled->True]
}],
Row[{
InputField[\[Alpha]=90,Number,
FieldHint->"\[Alpha]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[\[Beta]=90,Number,
FieldHint->"\[Beta]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[Dynamic@\[Gamma],Number,
FieldHint->"\[Gamma]",FieldSize->{5.,1.},
Enabled->True]
}]
}],

system==="Orthorhombic",
Column[{
Row[{
InputField[Dynamic@a,Number,
FieldHint->"a",FieldSize->{5.,1.},
Enabled->True],
Spacer[5],
InputField[Dynamic@b,Number,
FieldHint->"b",FieldSize->{5.,1.},
Enabled->True],
Spacer[5],
InputField[Dynamic@c,Number,
FieldHint->"c",FieldSize->{5.,1.},
Enabled->True]
}],
Row[{
InputField[\[Alpha]=90,Number,
FieldHint->"\[Alpha]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[\[Beta]=90,Number,
FieldHint->"\[Beta]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[\[Gamma]=90,Number,
FieldHint->"\[Gamma]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]]
}]
}],

system==="Tetragonal",
Dynamic@Column[{
Dynamic@Row[{
InputField[Dynamic[a,(a=#;b=#)&],Number,
FieldHint->"a",FieldSize->{5.,1.},
Enabled->True],
Spacer[5],
InputField[b=Dynamic@a,Number,
FieldHint->"b",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[Dynamic@c,Number,
FieldHint->"c",FieldSize->{5.,1.},
Enabled->True]
}],
Dynamic@Row[{
InputField[\[Alpha]=90,Number,
FieldHint->"\[Alpha]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[\[Beta]=90,Number,
FieldHint->"\[Beta]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[\[Gamma]=90,Number,
FieldHint->"\[Gamma]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]]
}]
}],

system==="Hexagonal"||system==="Trigonal",
Dynamic@Column[{
Dynamic@Row[{
InputField[Dynamic[a,(a=#;b=#)&],Number,
FieldHint->"a",FieldSize->{5.,1.},
Enabled->True],
Spacer[5],
InputField[b=Dynamic@a,Number,
FieldHint->"b",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[Dynamic@c,Number,
FieldHint->"c",FieldSize->{5.,1.},
Enabled->True]
}],
Dynamic@Row[{
InputField[\[Alpha]=90,Number,
FieldHint->"\[Alpha]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[\[Beta]=90,Number,
FieldHint->"\[Beta]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[\[Gamma]=120,Number,
FieldHint->"\[Gamma]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]]
}]
}],

system==="Cubic",
Dynamic@Column[{
Dynamic@Row[{
InputField[Dynamic[a,(a=#;b=#;c=#)&],Number,
FieldHint->"a",FieldSize->{5.,1.},
Enabled->True],
Spacer[5],
InputField[b=Dynamic@a,Number,
FieldHint->"b",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[c=Dynamic@a,Number,
FieldHint->"c",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]]
}],
Dynamic@Row[{
InputField[\[Alpha]=90,Number,
FieldHint->"\[Alpha]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[\[Beta]=90,Number,
FieldHint->"\[Beta]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]],
Spacer[5],
InputField[\[Gamma]=90,Number,
FieldHint->"\[Gamma]",FieldSize->{5.,1.},
Enabled->False,
BaseStyle->GrayLevel[0.65]]
}]
}]
];

(* Atom data *)
updAtomdataSummary[]:=atomdataSummary=atomdata[[
All,{"Element","FractionalCoordinates"}]];

createDeleteButtons[]:=deleteButtons=
Button["\[Times]",atomdataSummary=Delete[atomdataSummary,#];
createDeleteButtons[];createAtomdataPanel[],
Appearance->"Frameless"]&/@Range@Length@atomdataSummary;

createAtomdataPanel[]:=If[deleteButtons==={},
atomdataPanel="(no entries)",
atomdataPanel=Row[{Pane[
Grid[Transpose@Join[Transpose@Values@atomdataSummary,
{deleteButtons}],Alignment->Left],Scrollbars->False]}]];

updAtomdataPanel[]:=If[atomdata==={},
atomdataPanel="(no entries)",

updAtomdataSummary[];
createDeleteButtons[];
createAtomdataPanel[]
];

(* Initial settings *)
parameterFields=systemParameterFields["Triclinic"];
updAtomdataPanel[];

(*---* Grids *---*)
(* Grid switcher *)
updGrid[label_String]:=currentGrid=Which[
label==="A",gridA,
label==="B",gridB];
updGrid["A"];

(* Grid A *)
gridA=Dynamic@{
{"Crystal name",InputField[Dynamic@name,String,FieldHint->"Crystal name or label"]},
{"Space group",Dynamic@Row[{
PopupMenu[Dynamic[sgNumber,(sgNumber=#;
sgSymbol=sgKeys[[sgNumber]];
crystalSystem=$SpaceGroups[sgSymbol,"CrystalSystem"];
parameterFields=systemParameterFields[crystalSystem]
)&],
	Range@230,"Number"],
PopupMenu[Dynamic[sgSymbol,(sgSymbol=#;
sgNumber=$SpaceGroups[sgSymbol,"SpaceGroupNumber"];
crystalSystem=$SpaceGroups[sgSymbol,"CrystalSystem"];
parameterFields=systemParameterFields[crystalSystem]
)&],
	Keys@$SpaceGroups,"Symbol"]}]
},
{Tooltip["Lattice parameters",Column[{"a  b  c","\[Alpha]  \[Beta]  \[Gamma]","\[ARing]ngstr\[ODoubleDot]m and degree"}],
TooltipDelay->0.6],
Dynamic@parameterFields
},
{},
{Tooltip["Chemical formula","e.g. 'C13 H22 Fe N6 S3'",TooltipDelay->0.6],
InputField[Dynamic@chemicalFormula,String,
FieldHint->"e.g. 'C13 H22 Fe N6 S3'"]},
{Tooltip["Wavelength","\[ARing]ngstr\[ODoubleDot]m",TooltipDelay->0.6],
Row[{
InputField[Dynamic@wavelength,Number,
FieldSize->{5.,1.},FieldHint->"\[Lambda]"],
Spacer[5],
PopupMenu[Dynamic@wavelength,{
1.54059->"Cu \!\(\*SubscriptBox[\(K\[Alpha]\), \(1\)]\)",
1.54443->"Cu \!\(\*SubscriptBox[\(K\[Alpha]\), \(2\)]\)",
1.39223->"Cu \!\(\*SubscriptBox[\(K\[Beta]\), \(1\)]\)",
0.70932->"Mo \!\(\*SubscriptBox[\(K\[Alpha]\), \(1\)]\)",
0.71361->"Mo \!\(\*SubscriptBox[\(K\[Alpha]\), \(2\)]\)",
0.63230->"Mo \!\(\*SubscriptBox[\(K\[Beta]\), \(1\)]\)"
},"(Predefined)"]
}]},
{Tooltip["Mass density","g/\!\(\*SuperscriptBox[\(cm\), \(3\)]\)",TooltipDelay->0.6],
Row[{
InputField[Dynamic@massDensity,Number,
FieldSize->{5.,1.},FieldHint->"\[Rho]"],
Spacer[5],
"formula units",
Spacer[5],
InputField[Dynamic@formulaUnits,Number,
FieldSize->{5.,1.},FieldHint->"Z"]
}]},
{},
{"Atom data",Column[{
Button["Add new element",updGrid["B"]],
Dynamic@atomdataPanel
}]
},
{},
{Null,Row[{CancelButton[],DefaultButton[
DialogReturn[
(* Final checks *)
If[!StringQ@name,name="(no name)"];
If[chemicalFormula===Null,chemicalFormula=""];
If[formulaUnits===Null,formulaUnits=0];
If[sgSymbol===Null,sgSymbol=1];
If[wavelength===Null,wavelength=-1];

(* Return *)
MaXrd`Private`$temp={
{name,chemicalFormula,formulaUnits,sgSymbol,wavelength},
{a,b,c,\[Alpha],\[Beta],\[Gamma]},atomdata
};
MaXrd`Private`$temp=Replace[MaXrd`Private`$temp,
x_Dynamic:>x[[1]],-1]
]]}]}
};

(* Grid B *)
gridB=Dynamic@{
{"Element",PopupMenu[Dynamic[element,(element=#;updRet[])&],
elementListWithNumber,"Element"]},
{"Fractional coordinates",Row[{
InputField[Dynamic[coordX,(coordX=#;updRet[])&],
Number,FieldSize->{5.,1.},FieldHint->"x"],
Spacer[5],
InputField[Dynamic[coordY,(coordY=#;updRet[])&],
Number,FieldSize->{5.,1.},FieldHint->"y"],
Spacer[5],
InputField[Dynamic[coordZ,(coordZ=#;updRet[])&],
Number,FieldSize->{5.,1.},FieldHint->"z"]
}]},
{"Occupation factor",InputField[Dynamic[occupationFactor,(occupationFactor=#;updRet[])&],Number,FieldSize->{5.,1.},FieldHint->"1"]},
{Tooltip["ADP type","Anisotropic displacement parameters",TooltipDelay->0.6],
RadioButtonBar[Dynamic[adpType,(adpType=#;createAdpField[];updRet[])&],
{"Isotropic","Anisotropic"},Method->"Active"]},
{Null,Dynamic@adpField},
{},{},{},{},{},{},{},{},
{Null,Row[{
CancelButton[updGrid["A"]],
DefaultButton["Add",
AppendTo[atomdata,
Replace[toBeReturned,x_Dynamic:>x[[1]],-1]];
updAtomdataPanel[];
updGrid["A"],
Enabled->Dynamic@validQ]
}]}
};

(* Grid on display *)
Dynamic@Grid[currentGrid[[1]],
Spacings->{1,0.5},
Alignment->{Left,Center}]
],

(* Dialogue settings *)
WindowTitle->"Add crystal to $CrystalData",
Modal->True,
WindowSize->{310,All}
];


(* ::Input::Initialization:: *)
ImportCrystalData[]:=Block[{name},

MaXrd`Private`$temp=Null;
ImportCrystalData["RunDialogue"];
If[MaXrd`Private`$temp===Null,Return[]];
name=MaXrd`Private`$temp[[1,1]];

(* Execute ImportCrystalData on input data *)
If[ListQ@MaXrd`Private`$temp,
If[!AllTrue[MaXrd`Private`$temp[[2]]/.x_Dynamic:>x[[1]],NumericQ],
Message[ImportCrystalData::latticeParameters];Abort[],
ImportCrystalData@@MaXrd`Private`$temp
]];

(* Reset temporary variable *)
MaXrd`Private`$temp=Null;

InputCheck["ShallowDisplayCrystal",name]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
InputCheck::InvalidLabel="\[LeftGuillemet]`1`\[RightGuillemet] is not a recognised check label.";
InputCheck::InvalidTuple="Reflections (and coordinates) must be on a {\!\(\*
StyleBox[\"h\", \"TI\"]\), \!\(\*
StyleBox[\"k\", \"TI\"]\), \!\(\*
StyleBox[\"l\", \"TI\"]\)} (or {\!\(\*
StyleBox[\"x\", \"TI\"]\), \!\(\*
StyleBox[\"y\", \"TI\"]\), \!\(\*
StyleBox[\"z\", \"TI\"]\)}) form";
InputCheck::SingleTupleExpected="Only one `1` expected.";
InputCheck::IntegerExpected="One or more indices are not integers.";
InputCheck::InvalidInputType="Head of indices must be either Integer, String or Symbol.";
InputCheck::MultipleTuplesExpected="At least two reflections are required to make comparisons.";

InputCheck::EnergyUnitExpected="Input does not have a unit compatible with energy or wavelength.";
InputCheck::InvalidEnergyInput="Input must be an energy or wavelength compatible Quantity, or a number.";
InputCheck::EnergyMustBePositive="The wavelength/energy must be positive.";

InputCheck::InvalidCrystalEntity="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid crystal entity.";
InputCheck::NotIn$CrystalData="No data found on \[LeftGuillemet]`1`\[RightGuillemet].";
InputCheck::NoWavelengthIncluded="No wavelength was found for crystal \[LeftGuillemet]`1`\[RightGuillemet].";
InputCheck::InvalidUserInput="Invalid user input.";
InputCheck::InvalidPolarisationSetting="Invalid polarisation setting.";

InputCheck::InvalidPointOrSpaceGroup="Unable to interpret \[LeftGuillemet]`1`\[RightGuillemet] as a point- or space group.";
InputCheck::InvalidPointGroup="Unable to interpret \[LeftGuillemet]`1`\[RightGuillemet] as a point group.";
InputCheck::InvalidSpaceGroup="Unable to interpret \[LeftGuillemet]`1`\[RightGuillemet] as a space group.";
InputCheck::InvalidSpaceGroupNumber="Valid space group numbers are between 1 and 230.";
InputCheck::InvalidSymmetryObject="Unable to interpret \[LeftGuillemet]`1`\[RightGuillemet] as a point group, space group or a crystal.";

InputCheck::InvalidCentring="Invalid space group centring.";
InputCheck::ElementNumber="Element number `1` is out of range.";
InputCheck::ElementFailed="Unable to interpret \[LeftGuillemet]`1`\[RightGuillemet] as a chemical element.";
InputCheck::ElementError="The element \[LeftGuillemet]`1`\[RightGuillemet] cannot be interpreted.";

InputCheck::InvalidCrystalFamily="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid crystal family.";
InputCheck::InvalidDimension="Dimension must be either \"2D\" or \"3D\".";

InputCheck::DomainSizeError="Discrepancy between given domain size and length.";
InputCheck::InvalidRotationPoint="Invalid rotation point.";
InputCheck::InvalidRotationReference="Reference for rotation anchor must either be \"Host\", \"Domain\", \"DomainCentroid\" or \"Unit\".";
InputCheck::InvalidRotationMap="Values of `1`D rotation maps must be `2`.";


SyntaxInformation@InputCheck={
"ArgumentsPattern"->{__}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
InputCheck[input_List,labels___?(SubsetQ[
{"1hkl","1xyz","Integer","Multiple","StringSymbol","WrapSingle"},{#}]&)
]:=Block[{check,hkl,temp},
(* Check labels *)
	check={labels};
	Do[
	temp=check[[i]];
	If[!MemberQ[{
"1hkl","1xyz","Integer","Multiple",
"StringSymbol","WrapSingle"},temp],
	Message[InputCheck::InvalidLabel,temp];Abort[]],
	{i,Length@check}];

(* Dimensions check (always required) *)
	Which[
	(* Single reflection/coordinate *)
	MatchQ[input,{x1_,x2_,x3_}/;!AnyTrue[{x1,x2,x3},ListQ]],
		hkl={input},

	(* Multiple reflections/coordinates *)
	AllTrue[input,
	MatchQ[#,{x1_,x2_,x3_}/;!AnyTrue[{x1,x2,x3},ListQ]]&],
		hkl=input,

	(* None of the above *)
	True,
		Message[InputCheck::InvalidTuple];Abort[]
	];

(* Single reflection/coordinates check *)
	If[MemberQ[check,"1hkl"],
	If[Length@hkl!=1,
	Message[InputCheck::SingleTupleExpected,"reflection"];
	Abort[]]
	];
	If[MemberQ[check,"1xyz"],
	If[Length@hkl!=1,
	Message[InputCheck::SingleTupleExpected,"coordinate"];
	Abort[]]
	];

(* Multiple reflections check *)
	If[MemberQ[check,"Multiple"],
	If[Length@hkl<2,
	Message[InputCheck::MultipleTuplesExpected];
	Abort[]]
	];

(* Integer check *)
	If[MemberQ[check,"Integer"],
	If[!AllTrue[Flatten@hkl,IntegerQ],
	Message[InputCheck::IntegerExpected];
	Abort[]]
	];

(* Check if Integer, String or Symbol *)
	If[MemberQ[check,"StringSymbol"],
	If[!ContainsAll[{Integer,String,Symbol,Times},
	Head/@Flatten@hkl],
	Message[InputCheck::InvalidInputType];
	Abort[]]
	];

(* Wrap single reflections *)
	If[MemberQ[check,"WrapSingle"],
	If[MatchQ[input,
	{_?(!ListQ[#]&),_?(!ListQ[#]&),_?(!ListQ[#]&)}],
	Return[{input}],
	Return[input]
	]
	]
]


(* ::Input::Initialization:: *)
InputCheck["CrystalEntityQ",input_]:=(
If[input==="Void",Return[]];
If[MemberQ[Keys@$PeriodicTable,input],Return[]];
If[MemberQ[Keys@$CrystalData,input],Return[]];
Message[InputCheck::InvalidCrystalEntity,input];
)


(* ::Input::Initialization:: *)
InputCheck["CrystalQ",input_]:=Block[{dataRegular,dataTemp},
dataRegular=$CrystalData@input;
dataTemp=MaXrd`Private`$TempCrystalData@input;
Which[
AssociationQ@dataRegular,Return@dataRegular,
AssociationQ@dataTemp,Return@dataTemp,
True,Message[InputCheck::NotIn$CrystalData,input];Abort[]
]
]


(* ::Input::Initialization:: *)
InputCheck["FilterSpecialLabels",input_List]:=Intersection[
Join[{"Void"},Keys@$PeriodicTable],input]


(* ::Input::Initialization:: *)
InputCheck["GenerateTargetPositions",{X_,Y_,Z_}]:=Flatten[Table[
{i,j,k},{i,0.,N@X-1},{j,0.,N@Y-1},{k,0.,N@Z-1}],2]


(* ::Input::Initialization:: *)
InputCheck["GetAtomData",label_String]:=Block[{data},
InputCheck["CrystalQ",label];
data=Lookup[$CrystalData,label];
If[MissingQ@data,data=Lookup[MaXrd`Private`$TempCrystalData,label]];
data["AtomData"]
]


(* ::Input::Initialization:: *)
InputCheck["GetCentringVectors",centring_String]:=Block[{group,letter,vectors},
If[StringLength@centring=!=1,
group=InputCheck["GetPointSpaceGroupCrystal",centring];
letter=First@StringCases[ToString[group,OutputForm],LetterCharacter];
Return@InputCheck["GetCentringVectors",letter]
];
Which[
centring==="P",vectors={},
centring==="F",vectors={{1/2,1/2,0},{0,1/2,1/2},{1/2,0,1/2}},
centring==="I",vectors={{1/2,1/2,1/2}},
centring==="R",vectors={{2/3,1/3,1/3},{1/3,2/3,2/3}},
centring==="A",vectors={{0,1/2,1/2}},
centring==="B",vectors={{1/2,0,1/2}},
centring==="C",vectors={{1/2,1/2,0}},
centring==="H",vectors={{2/3,1/3,0},{1/3,2/3,0}},
True,Message[InputCheck::InvalidCentring];vectors={};
];
PrependTo[vectors,{0,0,0}]
]


(* ::Input::Initialization:: *)
InputCheck["GetCrystalFamilyMetric",family_,dimension_]:=Block[{M,a,b,c,\[Alpha],\[Beta],\[Gamma]},
(* Input checks *)
If[!MemberQ[{
"Cubic","Hexagonal","Tetragonal","Orthorhombic","Monoclinic","Triclinic"},
family],
Message[InputCheck::InvalidCrystalFamily,family];Abort[]];

If[!MemberQ[{"2D","3D"},dimension],
Message[InputCheck::InvalidDimension];Abort[]];

(* Metric *)
M={{1,b Cos[\[Gamma]],c Cos[\[Beta]]},{0,b Sin[\[Gamma]],c (Cos[\[Alpha]]-Cos[\[Beta]] Cos[\[Gamma]]) Csc[\[Gamma]]},{0,0,c *Sqrt[1-Cos[\[Beta]]^2-(Cos[\[Alpha]]-Cos[\[Beta]] Cos[\[Gamma]])^2 Csc[\[Gamma]]^2]}};

M=N[M/.Which[
family==="Cubic",{
a->1.,b->1.,c->1.,
\[Alpha]->90\[Degree],\[Beta]->90\[Degree],\[Gamma]->90\[Degree]
},
family==="Hexagonal",{
a->1.,b->1.,c->1.,
\[Alpha]->90\[Degree],\[Beta]->90\[Degree],\[Gamma]->120\[Degree]
},
family==="Tetragonal",{
a->1.,b->1.,c->1.61803,
\[Alpha]->90\[Degree],\[Beta]->90\[Degree],\[Gamma]->90\[Degree]
},
family==="Orthorhombic",{
a->1.7,b->1.2,c->0.85,
\[Alpha]->90\[Degree],\[Beta]->90\[Degree],\[Gamma]->90\[Degree]
},
family==="Monoclinic",{
a->1.,b->0.7,c->1.2,
\[Alpha]->90\[Degree],\[Beta]->72.\[Degree],\[Gamma]->90\[Degree]
},
family==="Triclinic",{
a->1.3,b->0.8,c->0.9,
\[Alpha]->66.\[Degree],\[Beta]->77.\[Degree],\[Gamma]->88.\[Degree]
}
]];
If[dimension==="2D",M[[{1,2},{1,2}]],M]
]


(* ::Input::Initialization:: *)
InputCheck["GetCrystalFormulaUnits",input_String]:=Block[{output},
(* Check if crystal entry exists *)
InputCheck["CrystalQ",input];
(* Return crystal wavelength if attached *)
If[KeyExistsQ[$CrystalData[input],"FormulaUnits"],
$CrystalData[input,"FormulaUnits"],
(* If not, query user manually *)
output=ToExpression@InputString[
"Cannot determine the number of formula units "<>
"for \[LeftGuillemet]"<>input<>"\[RightGuillemet]."<>"\n"<>
"Please enter that number or the density below."]
];
If[!NumericQ@output,Message[InputCheck::InvalidUserInput];Abort[],
output]
]


(* ::Input::Initialization:: *)
InputCheck["GetCrystalSpaceGroup",input_String]:=Block[{sg=input},
If[MemberQ[Keys@$CrystalData,input],sg=$CrystalData[input,"SpaceGroup"]];
InputCheck["InterpretSpaceGroup",sg]
]


(* ::Input::Initialization:: *)
InputCheck["GetCrystalWavelength",input_String,abortQ_:True]:=(
(* Check if crystal entry exists *)
InputCheck["CrystalQ",input];
(* Return crystal wavelength if attached *)
If[KeyExistsQ[
$CrystalData[input],"Wavelength"],
	Return@$CrystalData[
	input,"Wavelength"],
(* If not, abort OR return '-1' *)
If[abortQ,
Message[InputCheck::NoWavelengthIncluded,input];Abort[],
Return[-1]
]])


(* ::Input::Initialization:: *)
(* Converts to wavelength [\[ARing]ngstr\[ODoubleDot]ms] *)
InputCheck["GetEnergyWavelength",input_,unitsQ_:True]:=Block[{hcKeV=12.398420,\[Lambda]},
(* Only exception *)
If[input===-1,Return[-1]];

(* Check if positive *)
If[!Positive@input,Message[InputCheck::EnergyMustBePositive];Abort[]];

Which[
(* A. Number input *)
NumericQ@input,
	Which[
	(* 1. Assume \[ARing]ngstr\[ODoubleDot]ms *)
	input <= 5.0,\[Lambda]=N@input,
	(* 2. Assume kilo electronvolt *)
	input <= 250.0,\[Lambda]=hcKeV/input,
	(* 3. Assume electronvolts *)
	True,\[Lambda]=1000*hcKeV/input
	],

(* B. Quantity input *)
QuantityQ[input] ,
	(* Convert wavelength or energy to \[ARing]ngstr\[ODoubleDot]ms *)
	Which[
	UnitDimensions[input]==={{"LengthUnit",1}},
		\[Lambda]=UnitConvert[input,"Angstroms"];
		If[unitsQ,Return@\[Lambda],Return@QuantityMagnitude@\[Lambda]],

	CompatibleUnitQ[input,"Joules"],		
		\[Lambda]=hcKeV/QuantityMagnitude@
		UnitConvert[input,"Kiloelectronvols"],

	True,
		Message[InputCheck::EnergyUnitExpected];
		Abort[]
	],

(* C. None of the above *)
True,
	Message[InputCheck::InvalidEnergyInput];Abort[]
];

(* Set in Quantity if desired *)
If[unitsQ,
Quantity[\[Lambda],"Angstroms"],
\[Lambda]]
]


(* ::Input::Initialization:: *)
InputCheck["GetPointSpaceGroupCrystal",input_]:=Block[{
$CrystalDataCombined,sg},
(* Check if space group number is given *)
If[(1<=input<=230)&&IntegerQ@input,Return@$SpaceGroups[[input,"Name","Symbol"]]];
(* If actual input is a point- or space group, return it *)
If[KeyExistsQ[$GroupSymbolRedirect,input],Return@input];
(* Check if crystal entry exists *)
If[AssociationQ@MaXrd`Private`$TempCrystalData,
$CrystalDataCombined=Join[
$CrystalData,MaXrd`Private`$TempCrystalData],
$CrystalDataCombined=$CrystalData];
If[MissingQ@$CrystalDataCombined[input],
Message[InputCheck::InvalidSymmetryObject,input];Abort[]];
(* Check if space group of crystal exists *)
sg=$CrystalDataCombined[input,"SpaceGroup"];
If[!KeyExistsQ[$GroupSymbolRedirect,sg],
Message[InputCheck::InvalidSpaceGroupInCrystal,input,sg];Abort[],
Return@sg]
]


(* ::Input::Initialization:: *)
InputCheck["GetReciprocalImageOrientation",
latticeInput_,hklPlane_,indexLimit_,{width_,height_},directSpaceQ_
]:=Block[{
hkl=hklPlane,
abscissaIndex,ordinateIndex,planeConstant,planeIndex,
bottomLeft={-1,-1},bottomRight={1,-1},topRight={1,1},topLeft={-1,1},
M,\[Xi],imageOrientation
},

If[StringQ@hkl,hkl=MillerNotationToList@hkl];

{abscissaIndex,ordinateIndex,planeConstant}={#1,#2,hkl[[#3]]}&@@Flatten[
Position[hkl,#]&/@{"h","k","l",_Integer}];
planeIndex=First@Complement[Range@3,{abscissaIndex,ordinateIndex}];

If[TrueQ@directSpaceQ,
(* a. Direct space vectors (uvw) *)
M=GetCrystalMetric[latticeInput,"ToCartesian"->True];
\[Xi]=2*indexLimit/Max@M;
M=M[[{abscissaIndex,ordinateIndex},{abscissaIndex,ordinateIndex}]];
imageOrientation=\[Xi]*{bottomRight,topLeft,topRight};
imageOrientation=# . M&/@imageOrientation;
imageOrientation=Insert[#,N@planeConstant,planeIndex]&/@imageOrientation;
imageOrientation=Append[#1,#2]&@@@Transpose[
{imageOrientation,{width,height,1}}];
PrependTo[imageOrientation,imageOrientation[[3,{1,2,3}]]],

(* b. Corners in reciprocal space *)
imageOrientation=indexLimit*{bottomLeft,bottomRight,topLeft};
imageOrientation=N@Insert[#,planeConstant,planeIndex]&/@imageOrientation
];

imageOrientation=MapAt[#,imageOrientation,
{All,{abscissaIndex,ordinateIndex}}]&[DecimalForm[
#,{7,4},NumberPadding->{" ","0"}]&];
imageOrientation=Map[ToString,imageOrientation,{2}];
imageOrientation=StringRiffle[#,",  "]&/@imageOrientation
]


(* ::Input::Initialization:: *)
InputCheck["HandleSpecialLabels",input_List]:=Block[{specialLabels},
specialLabels=InputCheck["FilterSpecialLabels",input];
SynthesiseStructure/@specialLabels;
specialLabels
]


(* ::Input::Initialization:: *)
InputCheck["InterpretElement",input_]:=Block[{elementsIn=input,pertiodicTable,elementsRead,elementsReadNeutral,temp},
(*---* A. Input number *---*)
(* A.1. Check whether number is a string *)
If[StringQ@elementsIn,
If[StringMatchQ[elementsIn,NumberString],
elementsIn=ToExpression@elementsIn]];

(* A.2. Check if valid integer (in the periodic table) *)
If[NumericQ@elementsIn,
If[(1<=elementsIn<=Length@$PeriodicTable)&&IntegerQ@elementsIn,Return[(Keys@$PeriodicTable)[[elementsIn]]],
Message[InputCheck::ElementNumber,ToString@elementsIn];Abort[]]
];

(*---* B. Process single string *---*)
(* B.1. Wrap string *)
If[StringQ@elementsIn,elementsIn={elementsIn}];

(*---* C. Process list of strings *---*)
(* C.1. Check if input is a list of strings *)
If[!ListQ@elementsIn,Goto["Failed"]];
If[!AllTrue[elementsIn,StringQ],Goto["Failed"]];

(* C.2. Set of valid symbols from the periodic table *)
pertiodicTable=Keys@$PeriodicTable;

(* C.3. Find (possible) matches, and establish order *)
elementsRead=StringCases[elementsIn,
StartOfString~~a:LetterCharacter~~{"",b:LetterCharacter}~~
{"",n1:DigitCharacter...~~pm:{"+","-"}~~n2:DigitCharacter...}
:>ToUpperCase[a]<>ToLowerCase[b]<>
If[(n1==="")&&(n2===""),"1",""]<>n1<>n2<>pm];

	(* Check for non-elements *)
	If[MemberQ[elementsRead,{}],Message[InputCheck::ElementError,
	Part[elementsIn,Position[elementsRead,{}][[1,1]]]];Abort[]];

	(* Separate element symbol and charge (if any) *)
	elementsRead=Flatten[StringCases[Flatten@elementsRead,
	StartOfString~~a:LetterCharacter..~~b___
	:>{a,If[b==="","&",b]}],1](* '&' should be deleted later *);
	elementsReadNeutral=elementsRead[[All,1]];

(* C.4. Remove second character if not applicable *)
elementsReadNeutral=elementsReadNeutral/.s_String/;
!MemberQ[pertiodicTable,s]:>StringTake[s,1];

	(* Special case: deuterium *)
	elementsReadNeutral=elementsReadNeutral/."D"->"H";
	
(* C.5. Final validity check *)
temp=Complement[elementsReadNeutral,pertiodicTable];
If[temp=!={},Message[InputCheck::ElementError,
Part[elementsIn,Position[elementsReadNeutral,
First@temp][[1,1]]]];Abort[]];

(* C.6. Concatenate elements and charge *)
elementsRead[[All,1]]=elementsReadNeutral;
elementsRead=elementsRead/."1"->"";
elementsRead=StringDelete[StringJoin/@elementsRead,"&"];

Goto["Done"];

(*---* D. Post process *---*)
(* a. Unable to determine chemical element *)
Label["Failed"];
Message[InputCheck::"ElementFailed",ToString@input];
Abort[];

(* b. Return string (or list of strings) *)
Label["Done"];
If[StringQ@input,
elementsRead[[1]],elementsRead]
]


(* ::Input::Initialization:: *)
InputCheck["InterpretSpaceGroup",input_,abortQ_:True]:=Block[{sg=input,o,regex,temp},
(*---* A. Input number *---*)
(* A.1. Check whether number is a string *)
If[StringQ@sg,
If[StringMatchQ[StringTrim@sg,NumberString],
sg=ToExpression@sg]];

(* A.2. Check if valid integer (a canonical space group number) *)
If[NumericQ@sg,
If[(1<=sg<=230)&&IntegerQ@sg,Return@$SpaceGroups[[sg,"Name","Symbol"]],
Message[InputCheck::InvalidSpaceGroupNumber];
If[abortQ,Abort[],Return@Null]]
];

(*---* B. Process string *---*)
(* B.1. Check if string *)
If[!StringQ@sg,Goto["Failed"]];
sg=StringTrim@sg;

(* B.2 Process any annotations *)
If[StringContainsQ[sg,"origin",IgnoreCase->True],
regex=RegularExpression[" \\(origin.+(\\d)\\)"];
o=StringCases[sg,regex->"$1"];
If[o==={},
(* Manual input required *)
o=ChoiceDialog["Information on cell origin detected."<>
"\n"<>"Please confirm the cell origin.",{1,2},
WindowTitle->"Cell origin"];
sg=StringDelete[sg,Whitespace~~"("~~__~~")"],

(* Rebuild space group symbol *)
o=First@o;
sg=StringReplace[sg,regex->":$1"]
]
];

(* B.3 Tidy string *)
sg=Fold[StringReplace[#1,#2]&,sg,{
(* B.4.1. Remove any _enclosing_ quotation marks *)
(* Note: Some Hall symbols contain double quotation marks *)
StartOfString~~{"'","\""}~~main__~~{"'","\""}~~EndOfString:>main,

(* B.4.2 Uppercase centring 1 *)
StartOfString~~first:{"-"~~_,_}~~rest__~~EndOfString:>
ToUpperCase@first~~ToLowerCase@rest,

(* B.4.3. Fix boxes *)
{"overscriptbox"->"OverscriptBox",
"subscriptbox"->"SubscriptBox"},

(* B.4.4 Uppercase centring 2 *)
"Box[\("~~c_:>"Box[\("<>ToUpperCase[c],

(* B.4.5 Screw axes *)
a:DigitCharacter~~"("~~b:DigitCharacter~~")":>a<>b,

(* B.4.6. Miscellaneous replacements *)
";"->" "
}];
sg=StringTrim@sg;

(*---* C. Check symbol *---*)
(* C.1. Check centring symbol *)
If[!MemberQ[{"P","I","F","R","A","B","C","H","\!","-"},
StringTake[sg,1]],Goto["Failed"]];

(* C.2 Check if found by '$GroupSymbolRedirect' *)
temp=$GroupSymbolRedirect[sg];
If[!MissingQ@temp,
If[KeyExistsQ[temp,"PointGroupNumber"],Goto["Failed"]];
sg=temp[["Name","Symbol"]];Goto["SpaceGroupFound"]];

	(* Exception: Old symbols? *)
	If[sg==="Fm3m",sg="Fm-3m";Goto["SpaceGroupFound"]];
	If[sg==="Im3m",sg="Im-3m";Goto["SpaceGroupFound"]];

(* C.3 Delete whitespace and check again *)
temp=StringDelete[sg,Whitespace];
temp=$GroupSymbolRedirect[temp];
If[!MissingQ@temp,
sg=temp[["Name","Symbol"]];Goto["SpaceGroupFound"]];

(*---* D. Post process *---*)
(* a. Unable to determine space group *)
Label["Failed"];
Message[InputCheck::InvalidSpaceGroup,input];
If[abortQ,Abort[],Return@Null];

(* b. Return non-ambiguous output *)
Label["SpaceGroupFound"];
ToStandardSetting[sg]
]


(* ::Input::Initialization:: *)
InputCheck["PadDomain",{{X_,Y_,Z_},domain_List},padding_Integer:1]:=Block[{
newSize,
contentPositions,contentMap,
voidPositions,voidMap,
joined
},

If[padding<=0,Return[{{X,Y,Z},domain}]];
newSize=(padding+1){X,Y,Z}-padding;

contentPositions=Flatten[Table[{i,j,k},
{i,0.,(padding+1)*X-1,padding+1},
{j,0.,(padding+1)*Y-1,padding+1},
{k,0.,(padding+1)*Z-1,padding+1}
],2];
contentMap=AssociationThread[contentPositions->domain];

voidPositions=Complement[
InputCheck["GenerateTargetPositions",newSize],
contentPositions];
voidMap=AssociationThread[voidPositions->0];

joined=Join[contentMap,voidMap];
{newSize,Values@KeySortBy[joined,{#[[1]]&,#[[2]]&,#[[3]]&}]}
];


(* ::Input::Initialization:: *)
InputCheck["PointGroupQ",input_String]:=(
(* Check if valid point group string *)
If[!MemberQ[$PointGroups,input,Infinity],
Message[InputCheck::InvalidPointGroup,input];Abort[]
])


(* ::Input::Initialization:: *)
InputCheck["PointSpaceGroupQ",input_String]:=
(* Check if valid point- or space group string *)
	If[!KeyExistsQ[$GroupSymbolRedirect,input],
	Message[InputCheck::InvalidPointOrSpaceGroup,input];Abort[]
	]


(* ::Input::Initialization:: *)
InputCheck["Polarisation",type_String,scatteringAngle_:0]:=
Which[
type==="sigma"||type==="\[Sigma]",1,
type==="pi"||type==="\[Pi]",Abs@Cos[scatteringAngle],
True,Message[InputCheck::InvalidPolarisationSetting];Abort[]
]


(* ::Input::Initialization:: *)
InputCheck["ProcessWavelength",crystal_String,wavelength_,abortQ_:True]:=Block[{\[Lambda]},
\[Lambda]=If[N@wavelength===-1.,
InputCheck["GetCrystalWavelength",crystal,abortQ],wavelength];
InputCheck["GetEnergyWavelength",\[Lambda],False]]


(* ::Input::Initialization:: *)
InputCheck["RotationTransformation",
{{A_Integer,B_Integer,C_Integer},domains_List},
{
AnchorShift_List,
anchorReference_String,
rotations_,
rotationAxes_:IdentityMatrix@3
},
force3Dinterpretation_:False
]:=Module[{
twoDimensionalQ,coordinates,
\[Zeta],R,
uniqueDomains,anchorShift=AnchorShift,anchors,coordinatesGrouped,
domainAnchors,zeroRotation,zeroAnchor
},

(* Preparations and checks *)
If[Length@domains!=A*B*C,
Message[InputCheck::DomainSizeError];Abort[]];

uniqueDomains=DeleteDuplicates@domains;
twoDimensionalQ=(C===1);
If[force3Dinterpretation,twoDimensionalQ=False];
If[twoDimensionalQ,anchorShift=anchorShift[[{1,2}]]];

If[twoDimensionalQ,
If[!MatchQ[anchorShift,{_?NumericQ,_?NumericQ}],
Message[InputCheck::InvalidRotationPoint];Abort[]],
If[!MatchQ[anchorShift,{_?NumericQ,_?NumericQ,_?NumericQ}],
Message[InputCheck::InvalidRotationPoint];Abort[]]
];

If[AssociationQ@rotations,
If[twoDimensionalQ,
If[AnyTrue[Values@rotations,
!NumericQ[#]&],
Message[InputCheck::InvalidRotationMap,"2","scalars"];
Abort[]],
If[AnyTrue[Values@rotations,
!MatchQ[#,ConstantArray[_?NumericQ,3]]&],
Message[InputCheck::InvalidRotationMap,"3","lists of three numbers"];Abort[]]
]
];

If[!MemberQ[
{"Host","Domain","DomainCentroid","Unit"},anchorReference],
Message[InputCheck::InvalidRotationReference];Abort[]];

(* Rotation anchor and reference for domains *)
If[anchorReference==="Domain"||anchorReference==="DomainCentroid",
coordinates=Flatten[Table[{i,j,k},
{i,0.,A-1},{j,0.,B-1},{k,0.,C-1}],2];
If[twoDimensionalQ,coordinates=coordinates[[All,{1,2}]]];
coordinatesGrouped=Pick[coordinates,domains,#]&/@uniqueDomains;
domainAnchors=<|
"Domain"->Flatten[TakeSmallestBy[#,Norm,1]&/@coordinatesGrouped,1],
"DomainCentroid"->(#+If[twoDimensionalQ,{0.5,0.5},{0.5,0.5,0.5}]
&/@Map[Mean,Transpose/@coordinatesGrouped,{2}])
|>@anchorReference;
#+anchorShift&/@domainAnchors;
anchors=N@Association@Thread[uniqueDomains->domainAnchors]
];

(* Rotation transformation function 'R' *)
{zeroRotation,zeroAnchor}=If[twoDimensionalQ,
{0.,{0.,0.}},{{0.,0.,0.},{0.,0.,0.}}];
\[Zeta][d_]:=N@Lookup[rotations,d,zeroRotation];
Which[
anchorReference==="Host"&&twoDimensionalQ,
R[d_]:=Chop@RotationTransform[\[Zeta]@d,anchorShift],

anchorReference==="Host",
R[d_]:=Chop[Composition@@MapThread[RotationTransform[#1,#2,anchorShift]&,
{\[Zeta]@d,rotationAxes}]];
R[d_,p_]:=Chop[Composition@@MapThread[RotationTransform[#1,#2,anchorShift]&,
{If[!AssociationQ@rotations,d,\[Zeta]@d],rotationAxes}]],

anchorReference==="Unit"&&twoDimensionalQ,
R[d_,p_]:=Chop@RotationTransform[\[Zeta]@d,p+anchorShift],

anchorReference==="Unit",
R[d_,p_]:=Chop[Composition@@MapThread[RotationTransform[#1,#2,p+anchorShift]&,
{If[!AssociationQ@rotations,d,\[Zeta]@d],rotationAxes}]],

twoDimensionalQ,
R[d_]:=Chop@RotationTransform[\[Zeta]@d,Lookup[anchors,d,zeroAnchor]+anchorShift],

True,
R[d_,p_]:=Chop[Composition@@MapThread[RotationTransform[#1,#2,
Lookup[anchors,d,zeroAnchor]+anchorShift]&,
{\[Zeta]@d,rotationAxes}]]
];

R
]


(* ::Input::Initialization:: *)
InputCheck["ShallowDisplayCrystal",crystal_String]:=KeyValueMap[If[#1==="AtomData",
"AtomData"->Shallow[#2,1],
#1->#2]&,
$CrystalData@crystal]


(* ::Input::Initialization:: *)
InputCheck["Update$CrystalDataAutoCompletion"]:=(
FE`Evaluate[FEPrivate`AddSpecialArgCompletion[#]]&[
"$CrystalData"->{Keys@$CrystalData,
{"AtomData","ChemicalFormula","FormulaUnits",
"LatticeParameters","Notes","SpaceGroup","Wavelength"}
}];
$CrystalData=KeySort@$CrystalData;
Keys@$CrystalData
)


(* ::Input::Initialization:: *)
InputCheck["Update$CrystalDataFile",
dataFile_String,newStructureLabel_String,hostCopy_]:=(
If[!FileExistsQ@dataFile,$CrystalData=<||>];
AssociateTo[$CrystalData,newStructureLabel->hostCopy];
InputCheck["Update$CrystalDataAutoCompletion"];
Export[dataFile,$CrystalData];
);


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@InterplanarSpacing={
"Units"->True
};

SyntaxInformation@InterplanarSpacing={
"ArgumentsPattern"->{_,_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
InterplanarSpacing[input_,reflections_List,OptionsPattern[]]:=Block[{hkl,H,d,h},

(* Check reflection *)
hkl=InputCheck[reflections,"Integer","WrapSingle"];

(* Reciprocal metric *)
H=GetCrystalMetric[input,"Space"->"Reciprocal"];

(* Interplanar distance *)
d=Reap[Do[
h=hkl[[i]];
Sow[
1/Sqrt[h . H . h]
],
{i,Length@hkl}]
][[2,1]];

(* Option: Units *)
If[OptionValue["Units"],
d=Quantity[d,"Angstroms"]];

(* If only one reflection, return content *)
If[Length@d==1,
First@d,d]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@MergeSymmetryEquivalentReflections={
"ToStandardSetting"->True
};

SyntaxInformation@MergeSymmetryEquivalentReflections={
"ArgumentsPattern"->{_,_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
MergeSymmetryEquivalentReflections[group_String,hkl_List,OptionsPattern[]]:=
Block[{input,sg,merged},

(* Check input *)
	input=InputCheck[hkl,"Integer","WrapSingle"];
	sg=InputCheck["GetPointSpaceGroupCrystal",group];

(* Consider duplicate if they generate same symmetry equivalents *)
	merged=DeleteDuplicatesBy[input,
	Sort@SymmetryEquivalentReflections[sg,#]&];

(* Optional: Use standard setting on indices *)
	If[OptionValue["ToStandardSetting"],
	ToStandardSetting[sg,#]&/@merged,
	merged]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
SyntaxInformation@MillerNotationToList={
"ArgumentsPattern"->{_}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
MillerNotationToList[input_String]:=Block[{L,R,temp,split},
(* Removing overbars *)
L="\!\(\*OverscriptBox[\(";
R="\), \(_\)]\)";
	temp=StringReplace[input,L~~Shortest@x__~~R:>"|"<>"-"<>x<>"|"];

(* Separating indices *)
temp=StringReplace[temp,
(* Sign *)
s:{"","-","|"}~~
{
(* Letters are not joined with digits *)
x:LetterCharacter,
(* Digits could be joined *)
d:DigitCharacter~~
y:Shortest[{
"|",
DigitCharacter..~~{",","|",")"}
}]
}:>"|"<>s<>x<>d<>y<>"|"
];
temp=StringReplace[temp,"|"->","];
temp=StringSplit[temp,","];

	(* Special case: Positive single digits/letters only *)
	If[Length@temp<3,
	temp=StringCases[temp,x:WordCharacter:>x];
	temp=Flatten@DeleteCases[temp,{}]];

(* Trimming *)
temp=StringDelete[temp,{"(",")"}];
temp=DeleteCases[temp,x_/;MemberQ[{"",Null,"{}"},x]];

(* If not three entires, split digits *)
split[x_]:=Flatten@StringCases[x,{
p:{"","-"}~~n:DigitCharacter:>p~~n,
n1:DigitCharacter~~n2:DigitCharacter:>{n1,n2}
}];
temp=temp/.x_List/;Length[x]<3:>split[x];

(* Setting numbers as experssions *)
temp/.x_String/;StringContainsQ[x,DigitCharacter]:>ToExpression[x]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
MillerNotationToString::inv="Invalid index input \[LeftGuillemet]`1`\[RightGuillemet].";

SyntaxInformation@MillerNotationToString={
"ArgumentsPattern"->{{_,_,_}}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
MillerNotationToString[inputRaw_List]:=Block[{L,R,quit,i,H,index,input=inputRaw,presentation,output},
(* Input check *)
Check[InputCheck@inputRaw,Goto["End"]];

(* Shortcuts *)
L="\!\(\*OverscriptBox[\(";
R="\), \(_\)]\)";
quit[index_]:=(
Message[MillerNotationToString::inv,index];
Goto["End"]);

(* Pre-processing input *)
input=input/.x_String/;StringContainsQ[x,"-"]:>
-StringDelete[x,"-"];

(* Converting to string with overbar if negative *)
H={};
Do[
index=input[[i]];
Which[
IntegerQ@index,
	If[index<0,
	AppendTo[H,L<>ToString[-index]<>R],
	AppendTo[H,ToString@index]],
StringQ@index,
	If[StringLength@index!=1,quit[index],
	AppendTo[H,index]],
Head[index]===Real,
	AppendTo[H,ToString@index],
Head[index]===Times,
	If[(index[[1]]===-1)&&(StringQ@index[[2]]),
	If[StringLength@index[[2]]!=1,quit[index],
	AppendTo[H,L<>index[[2]]<>R]],
	quit[index]],
True,
	quit[index]
],{i,3}];

(* Presentation *)
presentation=StringJoin[
"("<>H[[1]]<>"|"<>H[[2]]<>"|"<>H[[3]]<>")"];

(* Only remove commas for single digit integers *)
If[AllTrue[Select[input,NumericQ],(Abs[#]<=9)&&IntegerQ[#]&],
output=StringDelete[presentation,"|"],
output=StringReplace[presentation,"|"->","]];

Return@output;

Label["End"];
input
]


(* ::Input::Initialization:: *)
MillerNotationToString[input_String]:=
MillerNotationToString@MillerNotationToList@input


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ReciprocalImageCheck::file="Input file was not found.";
ReciprocalImageCheck::method="The method \[LeftGuillemet]`1`\[RightGuillemet] was not recognised.";
ReciprocalImageCheck::system="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid lattice system.";
ReciprocalImageCheck::angles="Invalid angle input for the given system.";
ReciprocalImageCheck::threshold="`1` reflection`2` outside the threshold for integer determination.";
ReciprocalImageCheck::all="All reflections were inside the threshold for integer determination.";
ReciprocalImageCheck::ambiguous="Ambiguous image orientation. Use different correspondence points.";
ReciprocalImageCheck::data="At least two data points are required.";
ReciprocalImageCheck::grid="The option \[LeftGuillemet]ShowLattice\[RightGuillemet] must either be set to \[LeftGuillemet]True\[RightGuillemet] or a non-negative integer.";
ReciprocalImageCheck::InvalidLatticeOrigin="Lattice origin must be a list of two integers or \"Center\".";
ReciprocalImageCheck::InvalidLatticeParameters="The lattice must be a 2\[Times]2 matrix and the origin coordinates numeric.";
ReciprocalImageCheck::InvalidPlaneDescriptor="The plane descriptor must be a vector with two miller indices (\"h\", \"k\", \"l\") and one constant; \[LeftGuillemet]`1`\[RightGuillemet] was provided.";

Options@ReciprocalImageCheck={
(* FindPixelClusters options *)
"ClearStatus"->False,

(* Plot options *)
Frame->True,
ImageSize->Large,
PlotRange->All,
PointSize->Large,

(* ReciprocalImageCheck options *)
"BackgroundImage"->False,
"Colours"->{ColorData[97,2],ColorData[97,1],LightGray},
"CountNonInteger"->False,
"LatticeOrigin"->"Center",
"ReturnLatticeData"->False,
"RoundPixels"->True,
"ShowLattice"->False,
"StoreDataTemporarily"->False,
"Threshold"->0.15,
"TooltipStyle"->{FontFamily->"Courier New",FontSize->14}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ReciprocalImageCheck[
image_Image,
{a_,b_,c_,\[Alpha]_,\[Beta]_,\[Gamma]_},
data_List,
Optional[pattern_Condition,{x1_,x2_,x3_}/;False],
options:OptionsPattern[{
ReciprocalImageCheck,FindPixelClusters,ListPlot}]]:=Block[{
latticeParameters={a,b,c,\[Alpha],\[Beta],\[Gamma]},
latticeOrigin,
hkl,normalDirection,normalConstant,planeSelection,planeDescriptor,
data2D,L,model,\[Lambda]1,\[Lambda]2,h1,h2,\[CapitalLambda],latticeData,
optionKeys
},

(*--- Input check ---*)
(* Check for sufficient data *)
If[Length@data<2,
Message[ReciprocalImageCheck::data];
Abort[]];

(* Lattice origin shift *)
latticeOrigin=OptionValue["LatticeOrigin"];
If[latticeOrigin==="Center",latticeOrigin=ImageDimensions[image]/2];
If[!MatchQ[latticeOrigin,{_?NumericQ,_?NumericQ}],
Message[ReciprocalImageCheck::InvalidLatticeOrigin];Abort[]];

(*--- Preparations for extracting two dimensions (image plane) ---*)
(* Variables describing the plane *)
hkl=data[[All,{3,4,5}]];
normalDirection=Check[
First@Flatten@Position[Length/@DeleteDuplicates/@Transpose@hkl,1],
Message[ReciprocalImageCheck::ambiguous];Abort[]];
normalConstant=data[[1,normalDirection+2]];
planeSelection=DeleteCases[{1,2,3},normalDirection];

planeDescriptor=planeSelection/.<|1->"h",2->"k",3->"l"|>;
planeDescriptor=Insert[planeDescriptor,normalConstant,{normalDirection}];

(*--- Setting up lattice ---*)
data2D=Transpose@Drop[Transpose@data,{2+normalDirection}];
data2D={#3,#4,N@Norm[{#1,#2}]}&@@@data2D;
L=GetCrystalMetric[latticeParameters,"Space"->"Reciprocal","ToCartesian"->True];
L=L[[planeSelection,planeSelection]];

model=Quiet@NonlinearModelFit[
data2D,
Norm[Plus@@(Transpose@L*{\[Lambda]1,\[Lambda]2}*{h1,h2})+latticeOrigin],
{\[Lambda]1,\[Lambda]2},{h1,h2}];
{\[Lambda]1,\[Lambda]2}=model["ParameterTableEntries"][[All,1]];

\[CapitalLambda]=Transpose[Transpose[L]*{\[Lambda]1,\[Lambda]2}];

latticeData={\[CapitalLambda],latticeOrigin,planeDescriptor};
If[TrueQ@OptionValue["ReturnLatticeData"],Return@latticeData];

ReciprocalImageCheck[image,latticeData,pattern,options]
]


(* ::Input::Initialization:: *)
ReciprocalImageCheck[
image_Image,
{lattice_List,origin_List,planeDescriptor_List},
Optional[pattern_Condition,{x1_,x2_,x3_}/;False],
options:OptionsPattern[{
ReciprocalImageCheck,FindPixelClusters,ListPlot}]
]:=Block[{
normalConstant,planeSelection,normalDirection,
\[CapitalLambda],tx,ty,\[ScriptP],latticeData,
storeDataTemporarily,gz,showGrid=False,
imageHash,pixelList,
\[CapitalGamma],\[Xi],\[Chi],convert,residue,threshold,result,
imageDimensions=ImageDimensions@image,
axisColors,L1,L2,V,t,T,tt,grids,u,grid,
off,nodes,hkl,count,selection,selection2D,pos,matching,rest,
groupfix,tooltip,
colorMatch,colorRest,colorOff,optionKeys,plotOptions,nodePlot,plot,
temp,temp2
},

(*--- Input check ---*)
(* Variables describing the plane *)
normalConstant=Check[First@Select[planeDescriptor,NumericQ],
Message[ReciprocalImageCheck::InvalidPlaneDescriptor,planeDescriptor];
Abort[]];
planeSelection=DeleteCases[planeDescriptor,_?NumericQ]/.<|
"h"->1,"k"->2,"l"->3|>;
normalDirection=First@Complement[{1,2,3},planeSelection];

storeDataTemporarily=TrueQ@OptionValue["StoreDataTemporarily"];
gz=OptionValue["ShowLattice"];
If[storeDataTemporarily,gz=0];
If[gz||(IntegerQ[gz]&&NonNegative[gz]),showGrid=True];
If[gz,gz=0];

(* Lattice check *)
latticeData={\[CapitalLambda],{tx,ty},\[ScriptP]}={lattice,origin,planeDescriptor};
If[!MatchQ[\[CapitalLambda],{{#,#},{#,#}}&[_?NumericQ]]||!NumericQ@tx||!NumericQ@ty,
Message[ReciprocalImageCheck::InvalidLatticeParameters];Abort[]];
If[TrueQ@OptionValue["ReturnLatticeData"],Return@latticeData];

(* Image check/treatment *)
pixelList=FindPixelClusters[
image,FilterRules[{options},Options@FindPixelClusters]];
If[TrueQ@OptionValue["ReturnBinaryImage"],Return@pixelList];


(*--- Lattice conversion functions ---*)
\[CapitalLambda]=lattice;
\[CapitalGamma]=Inverse[\[CapitalLambda]];

\[Xi][x_,y_]:=\[CapitalGamma] . {x-tx,y-ty};
\[Chi][h_,k_]:=\[CapitalLambda] . {h,k}+{tx,ty};
	
(* Pixel to node *)
\[Xi][{x_,y_}]:=(
(* Calculation and discrepancy check *)
convert=\[CapitalGamma] . {x-tx,y-ty};
residue=Abs/@FractionalPart/@N[convert];

(* Decide whether to round to integer *)
threshold=OptionValue["Threshold"];
result={};
	
Do[
Which[
residue[[i]]<=threshold,
	AppendTo[result,Round@convert[[i]]],
1-residue[[i]]<=threshold,
	AppendTo[result,Round@convert[[i]]],
True,
	AppendTo[result,N@convert[[i]]]
],
{i,2}];

result);

(* Node to pixel *)
\[Chi][H_,round_:OptionValue["RoundPixels"]]:=(
convert=\[CapitalLambda] . H+{tx,ty};
If[round,Round@convert,convert]
);


(*--- Optional: Overlaying grid/lattice ---*)
If[!showGrid,Goto["LatticeDone"]];

(* Preparations *)
axisColors=Lookup[<|1->Red,2->Green,3->Blue|>,planeSelection];
{L1,L2}=Transpose[\[CapitalLambda]];

(* Lattice setup *)
V[x0_,y0_]:=(
T={tx,ty};
t=\[CapitalLambda] . {x0,y0}+{tx,ty};
tt={t,t};
If[x0==y0==0,
(* Origin arrows *)
{
{axisColors[[1]],Arrow[{T,T+L1}]},
{axisColors[[2]],Arrow[{T,T+L2}]}
},
(* Translated lines *)
{
{axisColors[[1]],Dashed,Line[{{0,0},L1}+tt]},
{axisColors[[2]],Dashed,Line[{{0,0},L2}+tt]}
}]
);

(* Lattice generation *)
grids={};
	
Label["StartGrid"];
temp=Table[V[i,j],{i,-gz,Max[1,gz]},{j,-gz,Max[1,gz]}];
temp=Flatten[temp,2];
If[gz==0,
temp=Delete[temp,{{3},{4},{5},{6},{7},{8}}];
Goto["One"]
];
temp2=4gz+2;
u=2*(2gz+1)^2;
x1=Table[i,{i,temp2,u,temp2}];
	x1=Replace[x1,x_:>{x},{1}];
x2=Table[j,{j,u-(4gz+1),u-1,2}];
	x2=Replace[x2,x_:>{x},{1}];
temp=Delete[temp,DeleteDuplicates@Join[x1,x2]];
Label["One"];
PrependTo[temp,Arrowheads[Medium]];

grid=Graphics[temp,
ImageSize->Small,
AspectRatio->1,
Axes->False
];

(* Optional: Generate several grids *)
If[storeDataTemporarily&&gz<8,
AppendTo[grids,grid];gz++;Goto["StartGrid"]];

Label["LatticeDone"];
	
(* Consider relfections outside threshold to be wrong/off *)
off=Select[pixelList,!AllTrue[\[Xi][#],IntegerQ]&];


(*--- Selecting nodes that match the pattern ---*)
(* Setup *)
nodes=\[Xi]/@pixelList;
hkl=Partition[Riffle[
Flatten@nodes,normalConstant,
{normalDirection,-1,3}],3];
	
(* Check for non-integer cases *)
If[TrueQ@OptionValue["CountNonInteger"],
If[!FreeQ[hkl,_Real],
Message[ReciprocalImageCheck::threshold,
count=Count[FreeQ[#,_Real]&/@hkl,False],
If[count>1,"s were"," was"]],
Message[ReciprocalImageCheck::all]
]
];

selection=Quiet@Cases[hkl,pattern];

(* Backtracking *)
selection2D=selection[[All,planeSelection]];
pos=Flatten[Position[nodes,#]&/@selection2D];
matching=Part[pixelList,pos];

(* Selection managment *)
matching=Complement[matching,off];
rest=Complement[pixelList,matching,off];

(* Tooltip styling and managment *)
groupfix[x_]:=Quiet[{x,MillerNotationToString@
Insert[\[Xi][x],normalConstant,{normalDirection}]}];
tooltip=Tooltip[#1,#2,TooltipStyle->
OptionValue["TooltipStyle"]]&;

(* Special case: Empty selections *)
off=If[off==={},{Null,Null},MapThread[tooltip,Transpose[groupfix/@off]]];
rest=If[rest==={},{Null,Null},MapThread[tooltip,Transpose[groupfix/@rest]]];
If[matching==={},matching={Null,Null};
Goto["SkipMatching"]];

(* Adding tooltip *)
matching=MapThread[tooltip,
Transpose[{
pixelList[[#]],
MillerNotationToString@hkl[[#]]
}&/@pos]
];
Label["SkipMatching"];


(*--- Plot ---*)
{colorMatch,colorRest,colorOff}=OptionValue["Colours"];

(* Options *)
optionKeys=Flatten[Keys/@Options/@{ReciprocalImageCheck,ListPlot}];
plotOptions=Association[#->OptionValue[#]&/@optionKeys];

If[plotOptions[AspectRatio]===1/GoldenRatio,
plotOptions[AspectRatio]=1/Divide@@imageDimensions];

If[plotOptions[PlotStyle]===Automatic,
plotOptions[PlotStyle]={
{PointSize->OptionValue[PointSize],Automatic,colorOff},
{PointSize->OptionValue[PointSize],Automatic,colorRest},
{PointSize->OptionValue[PointSize],Automatic,colorMatch}}];

plotOptions=FilterRules[
Normal@plotOptions,Options@ListPlot];

If[TrueQ@OptionValue["BackgroundImage"],
(* a. Put invisible nodes on top of image *)
plotOptions=Normal@Join[Association@plotOptions,<|
PlotStyle->{Transparent,PointSize->Large},
Frame->False,Axes->False,
PlotRange->{{0,#1},{0,#2}}&@@imageDimensions
|>];
nodePlot=ListPlot[rest,Sequence@@plotOptions];
Return@Show[
nodePlot,
If[showGrid,grid,{}],
Prolog->Inset[image,{0,0},{0,0},imageDimensions]
],

(* b. Regular ListPlot *)
plot=ListPlot[{off,rest,matching},Sequence@@plotOptions]
];


(*--- End ---*)
(* Optional: Store data temporarily *)
If[TrueQ@OptionValue["StoreDataTemporarily"],
Return[<|
"Image"->image,
	"ImageGrayscale"->ColorConvert[image,"Grayscale"],
	"ImageNegative"->ColorNegate[image],
	"ImageGrayscaleNegative"->ColorConvert[ColorNegate[image],"Grayscale"],
	"ImageBinarised"->Binarize[image],
"Lattice"->latticeData,
"Plotdata"->rest,
	"PlotdataMatch"->matching,
	"PlotdataWrong"->off,
"Grids"->grids
|>
]];

(* Plot *)
If[showGrid,Show[grid,plot,plotOptions],plot]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ReciprocalSpaceSimulation::invalid="Invalid input form.";
ReciprocalSpaceSimulation::dep="The layer vectors are not linearly independent.";

Options@ReciprocalSpaceSimulation={
"ReturnData"->False
};

SyntaxInformation@ReciprocalSpaceSimulation={
"ArgumentsPattern"->{_,_.,_,{_,_,_},_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ReciprocalSpaceSimulation[
crystal_,
lambda:_?(NumericQ[#]||QuantityQ[#]&):-1,
{L1_List,L2_List},origin_List,
res_?(NumericQ[#]&&Positive[#]&),
OptionsPattern[]]:=Block[{
\[Lambda],check,
G,Ginv,B,CrystalDot,CrystalCross,
Hx,Hy,Hz,HCx,HCy,HCz,
U,UB,o,ref,refz,flip,condition,pindex,
\[Epsilon],disk,
hkl,xy,pair,points},

(** Input check **)
	\[Lambda]=InputCheck["ProcessWavelength",crystal,lambda];

	check=Flatten[{L1,L2,origin}];
	If[Length@check!=9||!AllTrue[check,NumericQ],
	Message[ReciprocalSpaceSimulation::invalid];Abort[]];

	(* Check if vectors are linearly independent *)
	If[Det[{{L1 . L1,L1 . L2},{L2 . L1,L2 . L2}}]==0,
	Message[ReciprocalSpaceSimulation::dep];Abort[]];

(** Metric information **)
	G=GetCrystalMetric[crystal];
	Ginv=Inverse@G;
	B=CholeskyDecomposition@Inverse@G;

(** Dot- and cross products in reciprocal space **)
	CrystalDot[u_,v_]:=Return[
	Sum[
	Sum[
	Ginv[[i,j]]*u[[i]]*v[[j]],
	{j,3}],
	{i,3}]
	];

	CrystalCross[u_,v_]:=Return[
	Sqrt@Det@Ginv*Table[
	Sum[
	Sum[
	Sum[
	Signature[{i,j,k}]*
	G[[i,t]]*u[[j]]*v[[k]],
	{k,3}],
	{j,3}],
	{i,3}],
	{t,3}]
	];

(** Plane of projection **)
	(* Projection plane in reciprocal space *)
	Hx=L1;
	Hy=L2-Hx*CrystalDot[Hx,L2]/CrystalDot[Hx,Hx];
	Hz=CrystalCross[Hx,Hy];

	(* Components in Cartesian frame *)
	{HCx,HCy,HCz}=Normalize[B . #]&/@{Hx,Hy,Hz};

	(* U and UB matrices for generation of coordinates *)
	U=IdentityMatrix[3] . Inverse@Transpose[{HCx,HCy,HCz}];
	UB=Chop[U . B];

	(* Reference position in projection *)
	o=origin;
	ref=UB . o;
	refz=ref[[3]];

	If[Chop[origin]=={0,0,0},
	o=L1+L2;flip=True,
	flip=False];

	condition={
{h_,k_,l_}/;h==#1,
{h_,k_,l_}/;k==#2,
{h_,k_,l_}/;l==#3
}&@@o;
	condition=DeleteCases[condition,c_/;
	If[flip,
	!Equal[c[[2,2]],0],
	   Equal[c[[2,2]],0]
	]
	];

		(* Constant plane index *)
		pindex=condition[[1,2]];
		pindex=ToString@pindex[[1]]->pindex[[2]];

	If[Length@condition>1,
	condition=condition[[All,2]];
	condition={h_,k_,l_}/;#&[And@@condition],
	condition=First@condition];

(** Building **)
	Label["Building"];

	(* Resolution, limits and background *)
	\[Epsilon]=2.0*^-6;
	disk=Show[Graphics[{
	GrayLevel[0.95],
	EdgeForm[Thickness[Small]],
	Disk[{0,0},1/res]
	}],AspectRatio->1];

	(* Generating reflection *)
	hkl=ReflectionList[
	crystal,\[Lambda],condition,
	"HoldIndex"->pindex,
	"SplitEquivalent"->True,
	"ShowProgress"->False];

	(* Generating coordinates *)
	xy=(UB . #-{0,0,refz}&/@hkl)[[All,{1,2}]];
	pair=Transpose[{xy,hkl}];
	pair=Select[pair,
	Sqrt[CrystalDot[#[[2]],#[[2]]]]<1/(1.01*res)&];

	(* Optional: Return data *)
	If[OptionValue["ReturnData"],Return@pair];	

	pair=Tooltip[#1,MillerNotationToString[#2]]
&@@#&/@pair;(* TODO: Check if @@@ OK *)
	points=ListPlot[pair,
	PlotStyle->PointSize[Large],PlotRange->All];

Show[disk,points,PlotRange->{{-#,#},{-#,#}}&[1.01/res],ImageSize->Large]	
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ReflectionList::form="Some reflections are not on a {\!\(\*
StyleBox[\"h\", \"TI\"]\), \!\(\*
StyleBox[\"k\", \"TI\"]\), \!\(\*
StyleBox[\"l\", \"TI\"]\)} form.";
ReflectionList::integer="Some reflection indices are not integers.";
ReflectionList::empty="No reflections match the conditions.";
ReflectionList::keep="Invalid setting for the \[LeftGuillemet]Keep\[RightGuillemet] option.";
ReflectionList::index="Invalid index setting.";
ReflectionList::limit="Limit must be a natural number.";

Options@ReflectionList={
"AngleThreshold"->90.*Degree,
"CustomReflections"->False,
"Keep"->All,
"Limit"->30,
"ShowProgress"->True,
"SplitEquivalent"->False,
"HoldIndex"->False,
(* 'ToStandardSetting' options *)
"ToStandardSetting"->True
};

SyntaxInformation@ReflectionList={
"ArgumentsPattern"->{_,_.,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ReflectionList[
n_?(IntegerQ[#]&&Positive[#]&),
condition___Condition,
OptionsPattern[]]:=Block[
{opt,i,v,h,k,l,hkl},

(* Optional: Hold an index at same value *)
opt=OptionValue["HoldIndex"];
If[TrueQ[Head@opt==Rule],
{i,v}=Part[opt,#]&/@{1,2};
i=StringTake[i,-1],
i="None"];

	(* Check *)
	If[i!="None",
	If[!MemberQ[{"h","k","l"},i]||!IntegerQ[v],
	Message[ReflectionList::index];
	Abort[]]];

hkl=Which[
i=="h",
Flatten[Table[{v,k,l},{k,-n,n},{l,-n,n}],1],

i=="k",
Flatten[Table[{h,v,l},{h,-n,n},{l,-n,n}],1],

i=="l",
Flatten[Table[{h,k,v},{h,-n,n},{k,-n,n}],1],

True,
Tuples[Range[-n,n],3]
];

(* Remove the '000' reflection *)
	hkl=DeleteCases[hkl,{0,0,0}];

(* Sorting *)
	hkl=SortBy[hkl,{Total@Abs[#]&,Negative}];

(* Checking if extra conditions are present *)
	If[{condition}!={},
	(* Filtering reflections *)
	hkl=Cases[hkl,condition]];

Return@hkl
]


(* ::Input::Initialization:: *)
ReflectionList[
crystal_String,
lambda:_?(NumericQ[#]||QuantityQ[#]&):-1,
condition___Condition,
OptionsPattern[]]:=Block[{
\[Lambda],limit,H,\[Theta],checkIfEmpty,custom,n,list,
G,Ginv,CrystalDot,res,
keep,options,angleThreshold,
(* Progress *)
progress,total
},

(* Dynamical progress *)
	progress={0,"Initialisation"};
	total=11;
	If[OptionValue["ShowProgress"],
	PrintTemporary[Row[{
	ProgressIndicator@Dynamic[progress[[1]]/total],
	Spacer[10],
	Dynamic@progress[[2]]
	}]]
	];

(* Checking input *)
	progress={0,"Checking input"};
	\[Lambda]=InputCheck["ProcessWavelength",crystal,lambda];

	limit=OptionValue["Limit"];
	If[!(Positive[limit]&&IntegerQ[limit]),
	Message[ReflectionList::limit];Abort[]];

	(* Useful variables *)
	progress={2,"Defining variables"};
	G=GetCrystalMetric[crystal];
	Ginv=Inverse@G;
	H=N@Chop@Ginv;
	\[Theta][hkl_]:=N[ArcSin[\[Lambda]*Sqrt[hkl . H . hkl]/2]];

		(* Empty list check *)
		checkIfEmpty:=If[list=={},
		Message[ReflectionList::empty];
		Goto["ReturnEmpty"]];

	(* Option: Use custom reflections *)
	progress={3,"Custom input"};
	If[ListQ@OptionValue["CustomReflections"],
	custom=OptionValue["CustomReflections"];

	(* Check custom input *)
	If[Flatten@custom=={},
	Message[InputCheck::hkl];
	Return[{}]
	];

	Check[InputCheck[custom,"Integer","WrapSingle"],
	Abort[]];	

	list=custom;
	Goto["ListDone"]
	];

(** Generating a reflection list **)
	progress={4,"Generating a reflection list"};
	(* Dot product in reciprocal space *)
	CrystalDot[u_,v_]:=Return[
	Sum[
	Sum[
	Ginv[[i,j]]*u[[i]]*v[[j]],
	{j,3}],
	{i,3}]
	];

	(* Coarse decision on which 'hkl' values to generate *)
	progress={5,"Deciding which 'hkl' values to generate"};
	options=#->OptionValue[#]&/@Keys@Options@ReflectionList;
	n=1;
	While[Im@\[Theta][{n,n,n}]==0,n++];
	n=Min[n,limit];
	list=ReflectionList[n,condition,options];
	checkIfEmpty;

	(* Filter away reflections with complex Bragg angle *)
	progress={6,"Checking Bragg angles"} ;
	list=Select[list,
	Norm[#]<=1&&Head[#]=!=Complex&[\[Theta][#]]&];

	(* Optional: Truncate at chosen angle threshold *)
	angleThreshold=OptionValue["AngleThreshold"];
	If[0<=angleThreshold<\[Pi]/2,
	list=Select[list,(\[Theta][#]<=angleThreshold)&]
	];

	(* Resolution filtering *)
	progress={7,"Resolution filtering"};
	res=\[Lambda]/2;
	list=Select[list,Sqrt[CrystalDot[#,#]]<1/(1.01*res)&];
	checkIfEmpty;

	(* Filter away absent reflections *)
	Label["ListDone"];
	progress={8,"Filtering away absent reflections"};
	list=Pick[
	list,
	SystematicAbsentQ[crystal,list],
	False];
	checkIfEmpty;


(** Optional: Merge symmetry-equivalent reflections **)
	progress={9,"Merging symmetry equivalent reflections"};
	If[OptionValue["SplitEquivalent"],
	(* Split *)
	Null,
	(* Merge *)
	list=MergeSymmetryEquivalentReflections[
	crystal,list,
	"ToStandardSetting"->OptionValue["ToStandardSetting"]]
	];

(** Optional: Limit number of reflections **)
	progress={10,"Limiting the number of reflections"};
	keep=OptionValue["Keep"];
		(* Check *)
		If[keep==All,keep=Length@list];
		If[!(IntegerQ[keep]&&Positive[keep]),
		Message[ReflectionList::keep]];


	progress={11,"Reflection list done"};
	list=Take[list,Min[keep,Length@list]];

(*---* End *---*)
Return@list;

Label["ReturnEmpty"];
Return[{}]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Options@RelatedFunctionsGraph={
"Limit"->10,
"DirectOnly"->False,
"ShowDependent"->False
};

SetAttributes[RelatedFunctionsGraph,HoldFirst];

SyntaxInformation@RelatedFunctionsGraph={
"ArgumentsPattern"->{_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
RelatedFunctionsGraph[function_,OptionsPattern[]]:=Block[{
f,allf,deffile,import,
finddepf,data,d,main,g,done,new,x,X,c,part},

(* Loading data *)
f=ToString@HoldForm@function;
allf=First/@Cases[$MaXrdFunctions,_Hyperlink,Infinity];
deffile=FileNameJoin[{$MaXrdPath,"Core","Definitions.m"}];
import=StringJoin@Check[Import[deffile,"Text"],Abort[]];

	(* Optional: Show all functions depedent on 'f' *)
	If[OptionValue["ShowDependent"],
	data=StringCases[import,Shortest[
	c:(allf)~~{"[",":="}~~d__~~"End[];"]:>{c,d}];
	x=Reap@Do[
	c=data[[i,1]];
	d=Sort@DeleteDuplicates@StringCases[data[[i,2]],allf];
	d=DeleteCases[d,c];
	Sow[c->d],
	{i,Length@data}];
	x=x[[2,1]];
	part=First/@Position[x,f];
	g=First/@x[[part]];
	g=DeleteCases[g,f];
		(* If none, return empty list *)
		If[g=={},Return[{}]];
	g=f->#&/@g;
		Goto["GraphDataGenerated"]
	];

(* Function for finding related functions *)
finddepf[F_]:=(
data=StringCases[
import,Shortest[
"Begin[\"`Private`\"];"~~Whitespace~~
"(* ::Input::Initialization:: *)\n"~~
F~~{"[",":="}~~d__~~"End[];"]
:>d];

	(* Check if anything is found *)
	If[data=={},Return[{}]];

d=DeleteDuplicates@Flatten@Sort@StringCases[First@data,{
"\""~~allf~~"\"",
allf~~"::",
allf}];
d=DeleteCases[d,F];
d=DeleteCases[d,x_/;StringContainsQ[x,{"\"","::"}]]
);

(* Seed *)
main=finddepf@f;
	If[main=={},Return[{}]];

(* Loop *)
g={};
done={};
new={f};
While[new!={},
x=First@new;
X=finddepf@x;
g=DeleteDuplicates@Join[g,#->x&/@X];

AppendTo[done,x];
new=Join[new,X];
new=Complement[new,done]
];

Label["GraphDataGenerated"];
g=DeleteDuplicatesBy[g,Sort];

	(* Optional: Only directly connected *)
	If[OptionValue["DirectOnly"],
	g=DeleteCases[g,(a_->b_)/;(a!=f&&b!=f)]];
	
	(* Optional: Limiting graph *)
	g=Take[g,UpTo@OptionValue["Limit"]];

(* Plot *)
(* A. Older than version 12 *)
If[$VersionNumber<12.,
GraphPlot[g,
DirectedEdges->True,
ImageSize->Large,
MultiedgeStyle->False,
DirectedEdges->True,
SelfLoopStyle->None,
VertexLabeling->True,
VertexRenderingFunction->({
White,EdgeForm[],Rectangle[
#-{0.02*StringLength@#2,0.05},#+{0.02*StringLength@#2,0.05}],Black,
Text[
Style[Hyperlink[#2, "paclet:MaXrd/ref/"<>#2],
11,"Program"],
#1]
}&),
Method->"RadialDrawing"],

(* B. Version 12 and above *)
GraphPlot[g,
DirectedEdges->True,
VertexLabels->None,
ImageSize->Large,
MultiedgeStyle->False,
DirectedEdges->True,
EdgeShapeFunction->({Arrowheads[{{Automatic,0.5}}],Arrow[#1]}&),
SelfLoopStyle->None,
VertexShapeFunction->({
White,EdgeForm[],Rectangle[
#-{0.02*StringLength@#2,0.05},#+{0.02*StringLength@#2,0.05}],Black,
Text[
Style[Hyperlink[#2, "paclet:MaXrd/ref/"<>#2],
11,"Program"],
#1]
}&),
Method->"RadialDrawing"]
]
];


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ResetCrystalData::DemoDataNotFound="Demo data not found.";

SyntaxInformation@ResetCrystalData={
"ArgumentsPattern"->{}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ResetCrystalData[]:=Block[{demoFile,newDataFile},
demoFile=FileNameJoin[
{$MaXrdPath,"Core","Data","CrystalDataDemo.m"}];
If[!FileExistsQ@demoFile,
Message[ResetCrystalData::DemoDataNotFound];Return[]];
newDataFile=FileNameJoin[{$MaXrdPath,"UserData","CrystalData.m"}];
CopyFile[demoFile,newDataFile,OverwriteTarget->True];
$CrystalData=Import@newDataFile;
Keys@$CrystalData
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
SimulateDiffractionPattern::InvalidStructureInput="Structural input must be a crystal label or the path to one or more structure files.";
SimulateDiffractionPattern::InvalidInputForDIFFUSE="If not using a crystal label with DIFFUSE, input should be two structure files.";
SimulateDiffractionPattern::InvalidReciprocalPlane="Invalid reciprocal plane input.";
SimulateDiffractionPattern::InvalidReciprocalSpaceLimit="Invalid setting for \"IndicesLimit\".";
SimulateDiffractionPattern::ZeroIntensity="No intensity found in data.";
SimulateDiffractionPattern::MissingOutputData="Unable to import the expected output data.";
SimulateDiffractionPattern::MissingProgram="`1` does not appear to be installed.";
SimulateDiffractionPattern::InvalidPrint="Invalid print setting.";
SimulateDiffractionPattern::InvalidFormat="Structure file seems to be invalid.";
SimulateDiffractionPattern::UnsupportedProgram="The program \[LeftGuillemet]`1`\[RightGuillemet] is not supported.";
SimulateDiffractionPattern::InvalidSubtractionMode="Invalid scattering subtraction mode.";
SimulateDiffractionPattern::InvalidScalingFactor="The scaling factor must be a number.";
SimulateDiffractionPattern::InvalidImageDimensions="Image dimension must be a pair of natural numbers.";

Options@SimulateDiffractionPattern=SortBy[Normal@Union[
Association@Options@ArrayPlot,
Association@Options@ListDensityPlot,<|
"BraggScatteringSubtractionMode"->None,
"ImageDimensions"->{500,500},
"IndicesLimit"->5.5,
"LowerCutoff"->0,
"PrintOutput"->"ErrorsOnly",
"ProgramPaths"-><|
"MacOSX"-><|
"DISCUS"->"/usr/local/bin/discus_suite",
"DIFFUSE"->"/usr/local/bin"|>,
"Unix"-><|
"DISCUS"->"/usr/local/bin/discus_suite",
"DIFFUSE"->"/usr/local/bin"|>,
"Windows"-><|
"DISCUS"->"C:\\Program Files (x86)\\Discus\\bin\\discus_suite.exe",
"DIFFUSE"->"C:\\Program Files (x86)\\DIFFUSE"|>
|>,
"ReturnData"->False,
"ScalingFactor"->1,
"UseRawInput"->False,
(* ArrayPlot *)
ColorFunction->"Warm",
Frame->False,
FrameTicks->All,
ImageSize->Large,
PlotLegends->None,
ScalingFunctions->"Log"
|>],ToString[#[[1]]]&];

SyntaxInformation@SimulateDiffractionPattern={
"ArgumentsPattern"->{_,_,OptionsPattern[
{SimulateDiffractionPattern,ArrayPlot,ListDensityPlot}]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
SimulateDiffractionPattern[usingProgram_String,structureInput_,ImagePlane_,OptionsPattern[]]:=Block[{
imgPlane=ImagePlane,programPaths,searchExpression,options,inputs
},

(*---* Common driver routine *---*)
(* Common checks *)
If[!MemberQ[{"DISCUS","DIFFUSE"},usingProgram],
Message[SimulateDiffractionPattern::UnsupportedProgram,usingProgram];Abort[]];

If[!MemberQ[{"ErrorsOnly",All},OptionValue["PrintOutput"]],
Message[SimulateDiffractionPattern::InvalidPrint];Abort[]];

If[!MemberQ[
{None,"Biso","ExactAverage","SmallAverage"},
OptionValue["BraggScatteringSubtractionMode"]],
Message[SimulateDiffractionPattern::InvalidSubtractionMode];Abort[]];

If[!NumericQ@OptionValue["ScalingFactor"],
Message[SimulateDiffractionPattern::InvalidScalingFactor];Abort[]];

If[!MatchQ[OptionValue["ImageDimensions"],
{#,#}&[_?(IntegerQ[#]&&Positive[#]&)]],
Message[SimulateDiffractionPattern::InvalidImageDimensions];
Abort[]];

Which[
usingProgram==="DISCUS",
If[!StringQ@structureInput,
Message[SimulateDiffractionPattern::InvalidStructureInput];
Abort[]],

usingProgram==="DIFFUSE",
If[StringQ@structureInput,InputCheck["CrystalQ",structureInput],
If[Length@structureInput!=2||AnyTrue[structureInput,!FileExistsQ[#]&],
Message[SimulateDiffractionPattern::InvalidInputForDIFFUSE];
Abort[]]
]
];

If[StringQ@imgPlane,imgPlane=MillerNotationToList@imgPlane];
If[MatchQ[Sort@imgPlane,{_Integer,#,#}]
&["h"|"k"|"l"]\[Nand]DuplicateFreeQ@imgPlane,
Message[SimulateDiffractionPattern::InvalidReciprocalPlane];Abort[]];

If[!DirectoryQ@#,CreateDirectory@#]&[
FileNameJoin[{$TemporaryDirectory,"MaXrd"}]];

programPaths=OptionValue["ProgramPaths"][$OperatingSystem][usingProgram];
If[programPaths===""||DirectoryQ@programPaths,
searchExpression=Which[
usingProgram==="DISCUS",{"discus"},
usingProgram==="DIFFUSE",{"dzmc","bin2gray"}];
If[$OperatingSystem==="Windows",searchExpression=#<>".exe"&/@searchExpression];
searchExpression="(?i)"<>StringRiffle[searchExpression,"|"];
programPaths=Sort@FileNames[
RegularExpression@searchExpression,
programPaths,IgnoreCase->True]
];
programPaths=Flatten@List@programPaths;
If[!AllTrue[Flatten@List@programPaths,FileExistsQ]||programPaths==={},
Message[SimulateDiffractionPattern::MissingProgram,usingProgram];
Abort[]];
If[usingProgram==="DISCUS"&&ListQ@programPaths,
programPaths=First@programPaths];

(* Switch flow *)
options=Thread[#->OptionValue[#],String]&/@Keys@Options@SimulateDiffractionPattern;
inputs={programPaths,structureInput,imgPlane,Association@options};
Which[
usingProgram==="DISCUS",SDP$DISCUS@@inputs,
usingProgram==="DIFFUSE",SDP$DIFFUSE@@inputs
]
]


(* ::Input::Initialization:: *)
SDP$DISCUS[programPath_String,structureInput_,ImagePlane_,givenOptions_]:=Block[{
structureFile=structureInput,options=givenOptions,workDir,
i,stream,line,streamData,
ncell="",allCoords,structureSize,
latticeParameters,crystalM,
hklMax,abscissaIndex,ordinateIndex,
x,imageOrientation,commands,feedback="",
cutOffValue,data,dataLength,
xDataSize,yDataSize,xMin,xMax,yMin,yMax,xStep,yStep,numbers,plotData,
scaleMax,intensities,maxIntensity,useRawInputQ,imageBasis
},

(* Handle both crystal label and structure file input *)
If[KeyExistsQ[$CrystalData,structureInput],
structureFile=ExportCrystalData["DISCUS",structureFile,FileNameJoin[
{$TemporaryDirectory,"MaXrd","TemporaryStructureFile.stru"}]
]];
If[!FileExistsQ@structureFile,
Message[SimulateDiffractionPattern::InvalidStructureInput];Abort[]];
structureFile=AbsoluteFileName@structureFile;

(* Determining structure size *)
{i,stream}={1,OpenRead@structureFile};
While[True,
line=Read[stream,String];
If[StringTake[line,;;4]==="cell",
latticeParameters=line];
If[StringTake[line,;;5]==="ncell",
ncell=line;ReadLine@stream;Break[]];
If[StringTake[line,;;5]==="atoms",
Break[]];
If[i>10,Message[SimulateDiffractionPattern::InvalidFormat];Abort[]];
i++;
];
streamData=ReadList[stream,String];
Close@stream;

structureSize=If[ncell=!="",
(* a. Read size directly *)
Max@ToExpression[StringCases[ncell,DigitCharacter..][[;;3]]],

(* b. Determine size from coordinate data *)
allCoords=ToExpression@Part[StringSplit@streamData,All,2;;4];
Subtract@@Reverse[Ceiling/@MinMax@allCoords]
];

latticeParameters=ToExpression@StringCases[
latticeParameters,{DigitCharacter,"."}..];
crystalM=GetCrystalMetric[latticeParameters,
"Space"->"Reciprocal","ToCartesian"->True];

(* Preparing input for Fourier transform *)
workDir=DirectoryName@structureFile;
hklMax=options["IndicesLimit"];
If[NumericQ@hklMax\[Nand]Positive@hklMax,
Message[SimulateDiffractionPattern::InvalidReciprocalSpaceLimit];Abort[]];

imageOrientation=InputCheck["GetReciprocalImageOrientation",
latticeParameters,ImagePlane,hklMax,{100,100}(* Dummy width and height *),False];

{abscissaIndex,ordinateIndex}={#1,#2}&@@Flatten[
Position[ImagePlane,#]&/@{"h","k","l",_Integer}];

commands="
################################################
# COMBINED BUILD MACRO FOR `SimulateDiffractionPattern`
################################################
cd "<>workDir<>"
discus
####### Load/build crystal #####################
variable int, sizeX
sizeX = "<>ToString@structureSize<>"
#
read
  stru "<>FileNameTake@structureFile<>"
#
chem
  elem
exit
####### Fourier transform ######################
variable real, hklMax
variable int,  fourierWidth
variable int,  fourierPoints
#
hklMax = "<>ToString@N@hklMax<>"
fourierWidth = 2 * hklMax
fourierPoints = fourierWidth * sizeX + 1
#
fourier
  xray
  wvle moa1
#
  ll   "<>imageOrientation[[1]]<>"
  lr   "<>imageOrientation[[2]]<>"
  ul   "<>imageOrientation[[3]]<>"
  na   fourierPoints
  no   fourierPoints
  abs  "<>(abscissaIndex/.{1->"h",2->"k",3->"l"})<>"
  ord  "<>(ordinateIndex/.{1->"h",2->"k",3->"l"})<>"
#
  show
  run
exit
#
#
#---# Fourier data output #---#
output
  value intensity
  format standard
  outfile fourier_data.dat
  run
exit
################################################
exit
";

(* Run DISCUS *)
feedback=RunProcess[programPath,All,commands];
SDP$EvaluateFeedbackPrint[commands,feedback,options["PrintOutput"]];

(*-----* Plot preparations *-----*)
(* Importing (x,y,intensity) data from file *)
data=Check[
Import[FileNameJoin[{workDir,"fourier_data.dat"}],"Table"],
Message[SimulateDiffractionPattern::MissingOutputData];Abort[]];
dataLength=Length@data;

i=1;
While[data[[i,1]]===("#")&&i<=dataLength,i++];
Check[{xDataSize,yDataSize}=data[[i]],Abort[]];
{xMin,xMax,yMin,yMax}=data[[i+1]];
xStep=(xMax-xMin)/(xDataSize-1);
yStep=(yMax-yMin)/(yDataSize-1);

numbers=Flatten[data[[i+2;;]]];
numbers=Partition[numbers,xDataSize];

plotData=Table[
{
xMin+(x-1)*xStep,
yMin+(y-1)*yStep,
numbers[[y,x]](* Instead of transposing *)
},{y,yDataSize},{x,xDataSize}];
plotData=Flatten[plotData,1];

(* Scaling intensities *)
scaleMax=100.;
intensities=plotData[[All,3]];
maxIntensity=Max@intensities;
If[maxIntensity==0,Message[SimulateDiffractionPattern::ZeroIntensity];Abort[]];
intensities*=scaleMax/maxIntensity;
intensities=#*options["ScalingFactor"]&/@intensities;
intensities=intensities/.x_/;x>scaleMax->scaleMax;(* 16 bit max *)
plotData[[All,3]]=intensities;

(* Data treatment and preparation *)
useRawInputQ=TrueQ@options["UseRawInput"];
If[useRawInputQ,
(* a. Use data "as is" *)
plotData=Partition[plotData[[All,3]],Length@numbers],

(* b. Rescale intensity and use appropriate basis for image *)
cutOffValue=Power[10.,-3];
plotData=plotData/.{x_,y_,i_}/;i<cutOffValue:>{x,y,cutOffValue};
imageBasis=Normalize/@crystalM[[
{abscissaIndex,ordinateIndex},
{abscissaIndex,ordinateIndex}]];
plotData[[All,{1,2}]]=Map[imageBasis . #&,plotData[[All,{1,2}]]]
];

(* Prepare and deliver plot *)
If[useRawInputQ,
AssociateTo[options,DataRange->{{xMin,xMax},{yMin,yMax}}],
AssociateTo[options,AspectRatio->Divide@@Total@imageBasis]
];

If[TrueQ@options@"ReturnData",Return@plotData];
ListDensityPlot[plotData,Sequence@@FilterRules[Normal@options,Options@ListDensityPlot]]
]


(* ::Input::Initialization:: *)
SDP$DIFFUSE[programPaths_List,structureInput_,ImagePlane_List,givenOptions_]:=Block[{
structureFiles,workDir=FileNameJoin[{$TemporaryDirectory,"MaXrd"}],
inputFileDZMC,
subtractionMode,lowerCutoff,
width,height,
inputFile1="diffuse_input1_crystal.txt",
inputFile2="diffuse_input2_setup.txt",
commands,feedback,outputFile,imageData
},

(* Handle both crystal label and structure file input *)
If[KeyExistsQ[$CrystalData,structureInput],
subtractionMode=givenOptions["BraggScatteringSubtractionMode"];
subtractionMode=subtractionMode/.{
None->"N","Biso"->"Y","ExactAverage"->"E","SmallAverage"->"e"};
{width,height}=givenOptions["ImageDimensions"];
structureFiles=ExportCrystalData["DIFFUSE",structureInput,
workDir,ImagePlane,givenOptions["IndicesLimit"],subtractionMode,{width,height}],

CopyFile[#1,#2,OverwriteTarget->True]&@@@Transpose[{structureInput,
FileNameJoin[{workDir,#}]&/@{inputFile1,inputFile2}
}]
];

If[AnyTrue[structureFiles,!FileExistsQ[#]&],
Message[SimulateDiffractionPattern::InvalidStructureInput];Abort[]];
structureFiles=AbsoluteFileName/@structureFiles;

Quiet@DeleteFile@FileNames["output*",workDir];
inputFileDZMC=FileNameJoin[{workDir,"DZMC_inputs.txt"}];
Put[OutputForm@inputFile2,OutputForm["output.bin"],inputFileDZMC];

commands=StringTemplate["
cd `workDir`
\"`prog1`\" `inp1` < DZMC_inputs.txt
\"`prog2`\" --quiet=true output.bin
"]@<|"workDir"->workDir,"inp1"->inputFile1,"prog1"->programPaths[[2]],"prog2"->programPaths[[1]]|>;

(* Run DIFFUSE and then bin2gray *)
feedback=RunProcess[$SystemShell,All,commands];
SDP$EvaluateFeedbackPrint[commands,feedback,givenOptions["PrintOutput"]];

outputFile=FileNameJoin[{workDir,"output.pgm"}];
If[!FileExistsQ@outputFile,
Message[SimulateDiffractionPattern::MissingOutputData];Abort[]];

lowerCutoff=givenOptions["LowerCutoff"];
If[TrueQ@givenOptions["UseRawInput"],
Import@outputFile,

imageData=N@Import[outputFile,"Data"];
imageData=#*givenOptions["ScalingFactor"]&/@imageData;
imageData=imageData/.x_/;x>65535->65535;(* 16 bit max *)
imageData=imageData/.x_/;x<lowerCutoff->0.;
If[TrueQ@givenOptions["ReturnData"],Return@imageData];
ArrayPlot[imageData,Sequence@@FilterRules[Normal@givenOptions,Options@ArrayPlot]]
]
]


(* ::Input::Initialization:: *)
SDP$EvaluateFeedbackPrint[commands_String,Feedback_Association,optionSetting_]:=Block[{feedback=Feedback,stderr},
If[optionSetting===All,
Print@Prepend[feedback,"Input"->commands],

(* Removing irrelevant errors *)
stderr=StringTrim@StringDelete[feedback["StandardError"],{
"Remaining memory"~~__~~WhitespaceCharacter,
WhitespaceCharacter~~"More segments"~~__,
"'\\\\"~~__~~"UNC paths"~~__~~"Defaulting to Windows directory."
}];
If[stderr=!=""||feedback["ErrorCode"]==2,
Print@stderr]
]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
StructureFactor::InvalidThreshold="Invalid threshold setting: \[LeftGuillemet]`1`\[RightGuillemet].";
StructureFactor::ElementMismatch="Element mismatch detected.";

Options@StructureFactor=SortBy[Normal@Union[
Association@Options@GetAtomicScatteringFactors,
Association@Options@GetElements,<|
"AbsoluteValue"->True,
"IgnoreSystematicAbsence"->False,
"Threshold"->Power[10.,-6],
"Units"->True
|>],ToString[#[[1]]]&];

SyntaxInformation@StructureFactor={
"ArgumentsPattern"->{_,_,_.,
OptionsPattern[{StructureFactor,GetAtomicScatteringFactors,GetElements}]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
StructureFactor[
crystal_String,
hklInput_List,
lambda:_?(NumericQ[#]||QuantityQ[#]&):-1,
options:OptionsPattern[
{StructureFactor,GetAtomicScatteringFactors,GetElements}]]:=Block[{
data,\[Lambda],
abs=TrueQ@OptionValue["AbsoluteValue"],ignoreExtinct=TrueQ@OptionValue["IgnoreSystematicAbsence"],
unitsQ=TrueQ@OptionValue["Units"],
\[Delta]=OptionValue["Threshold"],
hkl,L0,L,
zerotype,absence,l,hklPos,j,
H,d,sl,fOptions,f,
atomdata,r,type,
disp,U,R,T,cvecs,occ,elements,
siteSymMxyz,siteSymO,
sf,SF,F,\[Phi]},

(*---* Checking input *---*)
InputCheck["CrystalQ",crystal];
\[Lambda]=InputCheck["ProcessWavelength",crystal,lambda];
data=$CrystalData[crystal];
If[!NumericQ@\[Delta],Message[StructureFactor::InvalidThreshold,\[Delta]];Abort[]];
hkl=InputCheck[hklInput,"Integer","WrapSingle"];
L0=Length@hkl;

(*---* Systematically absent reflections *---*)
If[!ignoreExtinct,
zerotype=If[abs,If[unitsQ,{0,Quantity[0,"Degrees"]},{0,0}],0];

absence=SystematicAbsentQ[crystal,hkl];
l=Length@absence;
hkl=Pick[hkl,absence,False];
hklPos=Position[absence,False];

(* Return if only extinct reflections *)
If[AllTrue[Flatten@absence,TrueQ],
If[l===1,Return@zerotype,Return@ConstantArray[zerotype,l]]]
];

(*---* Auxiliary and preparations *---*)
L=Length@hkl;
H=Chop@N@GetCrystalMetric[crystal,"Space"->"Reciprocal"];
sl=N[Sqrt[# . H . #]/2]&/@hkl;

atomdata=data["AtomData"];
r=atomdata[[All,"FractionalCoordinates"]];

{R,T}=Transpose@GetSymmetryOperations[crystal,"AugmentedMatrix"->False];
occ=Lookup[atomdata,"OccupationFactor",1.];
type=Lookup[atomdata,"Type","Uiso"];
cvecs=Length@Quiet@InputCheck["GetCentringVectors",crystal];
siteSymMxyz=cvecs*Length@R;
	(* Site symmetry order: siteSymO = siteSymMxyz / siteSymM *)

elements=atomdata[[All,"Element"]];
If[TrueQ@OptionValue["IgnoreIonCharge"],
elements=StringDelete[elements,{DigitCharacter,"+","-"}]];

f=GetAtomicScatteringFactors[crystal,hkl,\[Lambda],
"SeparateCorrections"->False,
FilterRules[{options},Options@GetAtomicScatteringFactors]];
If[AssociationQ@f,f={f}];
If[Sort@Keys@First@f=!=Sort@DeleteDuplicates@elements,
Message[StructureFactor::ElementMismatch];Abort[]];

(* Atomic displacement parameters preparation *)
d=Chop@N@Sqrt@DiagonalMatrix@Diagonal@H;
disp=Lookup[atomdata,"DisplacementParameters",0.];
U={};
Do[
If[Length@disp[[i]]==6,
AppendTo[U,
Partition[Part[disp[[i]],{1,4,5,4,2,6,5,6,3}],3]],
AppendTo[U,disp[[i]]]
],{i,Length@disp}
];

Which[
(* a. Extract 'SiteSymmetryOrder' from $CrystalData *)
KeyExistsQ[First@atomdata,"SiteSymmetryOrder"],
siteSymO=atomdata[[All,"SiteSymmetryOrder"]],

(* b. Calculate order from 'SiteSymmetryMultiplicity' *)
KeyExistsQ[First@atomdata,"SiteSymmetryMultiplicity"],
siteSymO=siteSymMxyz/
atomdata[[All,"SiteSymmetryMultiplicity"]],

(* c. Calculate site symmetry order *)
True,
siteSymO=siteSymMxyz/Table[
Length@SymmetryEquivalentPositions[crystal,r[[a]]],{a,Length@r}]
];

(*---* Structure factor calculation *---*)
(* Magnitude *)
sf=Table[(* Table for each reflection *)
Sum[1
*occ[[j]](* Occupation factor *)
*cvecs(* Centring vectors *)
*1.0/siteSymO[[j]] (* Symmetry reduction *)
*Part[f[[h]],elements[[j]]](* Atomic form factor *)
*Sum[
Which[(* Atomic displacement *)
type[[j]]=="Uani",
	Exp[-2 Pi^2*hkl[[h]] . d . R[[s]]
	. U[[j]]
	. Transpose[R[[s]]]
	. d . hkl[[h]]],
type[[j]]=="Uiso",
	Exp[-8 Pi^2*disp[[j]]*(sl[[h]])^2],
type[[j]]=="Bani",
	Exp[-1/4*hkl[[h]] . d . R[[s]]
	. U[[j]]
	. Transpose[R[[s]]]
	. d . hkl[[h]]],
type[[j]]=="Biso",(* Temperature factor *)
	Exp[-disp[[j]]*(sl[[h]])^2],
True,Message[$CrystalData::type,type];Abort[]
]*Exp[2Pi*I(hkl[[h]] . R[[s]] . r[[j]]+hkl[[h]] . T[[s]])],
{s,Length@R}],
	{j,Length@atomdata}],
		{h,L}];

(* Phase *)
If[!abs,SF=sf;Goto["ComplexNumber"]];

SF=Reap[Do[
F=sf[[i]];
If[
(* a. Check threshold *)
Abs@Re@F<\[Delta],Sow[{0,0}],
(* b. Calculate *)
Which[
Re[F]==0.&&Im[F]>=0,
	F=0;\[Phi]=90,
Re[F]==0.&&Im[F]<0,
	sf[[i]]=0;\[Phi]=-90,
Re[F]>=0.&&Im[F]==0,
	\[Phi]=90,
Re[F]<0.&&Im[F]==0,
	\[Phi]=180,
Re[F]>0.&&Im[F]>0,	
	\[Phi]=N[ArcTan[Abs[Im[F]/Re[F]]]/Degree],
Re[F]>0.&&Im[F]<0,
	\[Phi]=-N[ArcTan[Abs[Im[F]/Re[F]]]/Degree],
Re[F]<0.&&Im[F]>0,
	\[Phi]=N[(Pi-ArcTan[Abs[Im[F]/Re[F]]])/Degree],
Re[F]<0.&&Im[F]<0,
	\[Phi]=N[(ArcTan[Abs[Im[F]/Re[F]]]-Pi)/Degree]
];
Sow[{F,\[Phi]}]],
{i,L}]][[2,1]];

(*---* Preparing output *---*)
(* Processing units *)
If[unitsQ,SF=MapAt[Quantity[#,"Degrees"]&,SF,{All,2}]];

(* a. Return absolute value and phase *)
SF=MapAt[Abs,SF,{All,1}];

(* b. Return complex number *)
Label["ComplexNumber"];

(* Putting back extinct reflections *)
If[L0>1&&!ignoreExtinct,SF=ReplacePart[
ConstantArray[zerotype,l],
Thread[hklPos->SF]]];

If[L0===1,First@SF,SF]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
StructureFactorTable::invcustom="Invalid setting for the \[LeftGuillemet]CustomReflections\[RightGuillemet] option.";
StructureFactorTable::sort="Invalid \[LeftGuillemet]Sort\[RightGuillemet] option.";

Options[StructureFactorTable]={
(* DarwinWidth and ExtinctionLength options *)
"Polarisation"->"\[Pi]",
(* StructureFactor options *)
"Threshold"->Power[10.,-6],
(* ReflectionList options *)
"SplitEquivalent"->False,
"CustomReflections"->False,
"ReflectionListKeep"->50,
(* StructureFactorTable options *)
"Keep"->All,
"Sort"->-2,
"TitleStyle"->{FontFamily->"Baskerville",FontSize->15},
"SubtitleStyle"->{FontFamily->"Times New Roman",FontSize->13,Gray},
"NumberStyle"->FontFamily->"Courier",
Background->{{None},{None,{None,LightGray}}},
Dividers->{{None,{True},None},{None,None,True}}
};

SyntaxInformation@StructureFactorTable={
"ArgumentsPattern"->{_,_.,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
StructureFactorTable[
crystal_String,
lambda:_?(NumericQ[#]||QuantityQ[#]&):-1,
condition___Condition,
OptionsPattern[]]:=
Block[{
\[Lambda],hkl,H,sl,bragg,
column1,column2,column3,column4,column5,column6,
V,
zeros,
R,\[Theta],Fh,FhBar,\[CapitalLambda]o,\[Delta]os,
temp,temp1,temp2,temp3,temp4,temp5,temp6,
sort,keep,polarisation,threshold},

(*---* Preparations *---*)
	(* Checking wavelength *)
	\[Lambda]=InputCheck["ProcessWavelength",crystal,lambda];

	(* Preparing list of reflections *)
	hkl=Check[ReflectionList[
	crystal,\[Lambda],condition,
	"SplitEquivalent"->OptionValue["SplitEquivalent"],
	"CustomReflections"->OptionValue["CustomReflections"],
	"Keep"->OptionValue["ReflectionListKeep"]
	],Abort[]];

	(* Useful variables *)
	H=Chop@N@Inverse@GetCrystalMetric[crystal];
	(* Using inner product and Bragg's law *)
	sl[h_]:=N[Sqrt[h . H . h]/2];
	bragg[h_]:=N[ArcSin[sl[h]*QuantityMagnitude@\[Lambda]]];

	(* Miscellaneous options *)
	polarisation=OptionValue["Polarisation"];
	threshold=OptionValue["Threshold"];

(*---* Calculations *---*)
	(* Miller indices *)
	column1=MillerNotationToString/@hkl;

	(* Structure factors *)
	temp=Check[StructureFactor[crystal,hkl,\[Lambda],"Threshold"->threshold],Abort[]];
	column2=Chop[temp[[All,1]],OptionValue["Threshold"]];
		(* Structure factor zero positions *)
		zeros=Position[column2,0];

	(* Phase *)
	column3=QuantityMagnitude@temp[[All,2]];
	column3=ReplacePart[column3,zeros->"\[Dash]"];

	(* Bragg angles *)
	column4=(bragg/@hkl)/Degree;
	
	(* Unit cell volume *)
	V=Sqrt@Det@GetCrystalMetric[crystal];

(* Extinction length (Pendell\[ODoubleDot]sung distance) *)
	R=QuantityMagnitude@UnitConvert[
	Quantity["ClassicalElectronRadius"],"Angstroms"];

	\[Theta]=column4*Degree;
	Fh=column2;
	FhBar=(StructureFactor[crystal,-hkl,\[Lambda]])[[All,1]];
	
	\[CapitalLambda]o=Quiet@ExtinctionLength[crystal,\[Lambda],hkl,
"Units"->False,"Polarisation"->polarisation];
	\[CapitalLambda]o=ReplacePart[\[CapitalLambda]o,zeros->"\[Dash]"];
	
(* Darwin width *)
	\[Delta]os=Quiet@DarwinWidth[crystal,\[Lambda],hkl,
"Units"->False,"Polarisation"->polarisation];
	\[Delta]os=ReplacePart[\[Delta]os,zeros->"\[Dash]"];
	
	{column5,column6}={\[CapitalLambda]o,\[Delta]os};

(*---* Preparing output *---*)
	temp1={column1,column2,column3,column4,column5,column6};

	(* Optional: Sorting option *)
		sort=OptionValue["Sort"];
		
		(* Check sort setting *)
		If[!MemberQ[Range[6],Abs@sort],
		Message[StructureFactorTable::sort];
		Abort[]];
		
		(* Sorting by a specific column *)			
		temp2=Sort[Transpose@temp1,
		#1[[Abs@sort]]<#2[[Abs@sort]]&];
			(* Reversing if negative *)
			If[sort<0,temp2=Reverse@temp2];

	(* Optional: Truncate the list of reflections *)
		keep=OptionValue["Keep"];
		If[keep==All,keep=Length@hkl];
		If[!IntegerQ[keep]||!Positive[keep],
		Message[StructureFactorTable::invkeep];Abort[]];
		
		temp2=Take[temp2,Min[keep,Length@hkl]];

(* Rounding off numbers *)
	temp3=NumberForm[#,{5,3},
	DigitBlock->3,NumberSeparator->","]&/@(Flatten@temp2);
	temp4=Partition[temp3,Last@Dimensions@temp2];


(*---* Table construction *---*)
	temp5=PrependTo[temp4,
	{"(hkl)","|\!\(\*SubscriptBox[\(F\), \(hkl\)]\)|","\!\(\*SubscriptBox[\(\[Phi]\), \(hkl\)]\) [\[Degree]]",
	"\!\(\*SubscriptBox[\(\[Theta]\), \(B\)]\) [\[Degree]]","\!\(\*SubscriptBox[\(\[CapitalLambda]\), \(0\)]\) [\[Micro]m]","2\!\(\*SubscriptBox[\(\[Delta]\), \(os\)]\) [\[Micro]rad]"}];
	temp6=PrependTo[temp5,
	{Null,"Structure factor","Phase",
	"Bragg angle","Extinction length",
	"Darwin width"}];

	Grid[temp6,
	Dividers->OptionValue[Dividers],
	Background->OptionValue[Background],
	Alignment->{Center,Center},
	Spacings->{Automatic,2->0.5},
	ItemStyle->
	{Automatic,
	Automatic,
	{
	{{1,1},{1,First@Dimensions@temp1}}->OptionValue["TitleStyle"],
	{{2,2},{1,First@Dimensions@temp1}}->OptionValue["SubtitleStyle"],
	{{3,First@Dimensions@temp2+2},{1,First@Dimensions@temp1}}->OptionValue["NumberStyle"]
	}
	}]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
SymmetryEquivalentPositions::threshold="Tolerance specification must be a non-negative number.";

Options@SymmetryEquivalentPositions={
"RationaliseThreshold"->0.001,
"UseCentring"->True
};

SyntaxInformation@SymmetryEquivalentPositions={
"ArgumentsPattern"->{_,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
SymmetryEquivalentPositions[input_String,xyzInput_List:{"x","y","z"},
OptionsPattern[]]:=Block[{
group,\[Delta]=OptionValue["RationaliseThreshold"],
useCenteringQ=TrueQ@OptionValue["UseCentring"],
recognizedFractions,r,xyz,
centeringVectors,
s,R,T,equiv,RationalizeRecognizedFractions,mod,generate,gather,centring,final,t,sym,c,add,pos,temp
},

(* Checks *)
If[!NumericQ@\[Delta]||Negative@\[Delta],Message@SymmetryEquivalentPositions::threshold];
group=InputCheck["GetPointSpaceGroupCrystal",input];
xyz=InputCheck[xyzInput,"WrapSingle"];

(* Auxiliary *)
recognizedFractions={1/12,1/8,1/6,1/4,1/3,3/8,5/12,1/2,7/12,5/8,2/3,3/4,5/6,7/8,11/12};
RationalizeRecognizedFractions[coordinates_]:=Reap[Do[Sow@If[
MemberQ[recognizedFractions,r=Rationalize[i/.{0.->0},\[Delta]]],r,i],
{i,coordinates}]][[2,1]];
mod[X_]:=Switch[X,
_?NumericQ,Mod[X,1],
_Plus,t=Select[X,NumericQ];sym=X-t;Mod[t,1]+sym,
_,X];

(* Generate equivalent positions *)
s=GetSymmetryOperations[group,
"AugmentedMatrix"->True,"UseCentring"->useCenteringQ];
xyz=RationalizeRecognizedFractions/@xyz;
xyz=Transpose[#@xyz&/@s];
If[!useCenteringQ,xyz=DeleteDuplicatesBy[#,
centeringVectors=InputCheck["GetCentringVectors",group];
Sort@Map[mod,(centeringVectors\[Transpose]+#)\[Transpose],{2}]&]&/@xyz
];
xyz=Map[mod,xyz,{3}];
xyz=xyz/.x_Real:>Round[x,10.^(-6)];
xyz=DeleteDuplicates/@xyz;

If[MatchQ[xyzInput,{x_,y_,z_}/;!AnyTrue[{x,y,z},ListQ]],
First@xyz,xyz]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
SyntaxInformation@SymmetryEquivalentReflections={
"ArgumentsPattern"->{_,_.}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
SymmetryEquivalentReflections[input_String,hkl_List:{"h","k","l"}]:=Block[
{group,operations},
group=InputCheck["GetPointSpaceGroupCrystal",input];
InputCheck[hkl,"1hkl","StringSymbol"];
operations=GetSymmetryOperations[group,"IgnoreTranslations"->True];
operations=Map[Transpose,operations,{2}];
DeleteDuplicates[#@hkl&/@operations]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
SyntaxInformation@SymmetryEquivalentReflectionsQ={
"ArgumentsPattern"->{_,_}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
SymmetryEquivalentReflectionsQ[group_String,hkl_List]:=
Block[{equiv},
(* Check input *)
Check[InputCheck[hkl,"Multiple"],Abort[]];

(* Listing all symmetry-equivalents of the first reflection *)
equiv=SymmetryEquivalentReflections[group,First@hkl];

(* Checking if all given reflections are symmetry equivalent *)
AllTrue[hkl,MemberQ[equiv,#]&]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
SynthesiseStructure::SizeError="Size discrepancy in domain input.";
SynthesiseStructure::DifferentBlockSizes="The blocks must have the same size.";
SynthesiseStructure::InvalidOutputSize="Output size must be a list of three positive integers.";
SynthesiseStructure::IncompatibleOutputSize="Output size must be compatible with block sizes.";
SynthesiseStructure::InvalidSelectionMethod="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid selection method.";
SynthesiseStructure::ExpectedSpecialLabel="Chemical element or \"Void\" expected; got \[LeftGuillemet]`1`\[RightGuillemet] instead.";
SynthesiseStructure::InvalidLatticeParameters="Lattice parameters should be a list of six numbers.";
SynthesiseStructure::NothingToBuild="No units in construction list.";

Options@SynthesiseStructure={
"Padding"->False,
"RotationAnchorReference"->"DomainCentroid",
"RotationAnchorShift"->{0,0,0},
"RotationAxes"->IdentityMatrix[3],
"RotationMap"-><||>,
"SelectionMethod"->"Sequential"
};

SyntaxInformation@SynthesiseStructure={
"ArgumentsPattern"->{_,_.,_.,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
SynthesiseStructure[blocks_List,{A_Integer,B_Integer,C_Integer},outputName_String,OptionsPattern[]]:=Block[{
selectionMethod=OptionValue["SelectionMethod"],
domains,mapping,options
},
(* Checking input *)
Check[Scan[InputCheck["CrystalEntityQ",#]&,DeleteDuplicates@blocks],Abort[]];

(* Preparing domain representation *)
domains=Which[
selectionMethod==="Random",RandomChoice[blocks,A*B*C],
selectionMethod==="Sequential",#,
selectionMethod==="Shuffled",RandomSample@#,
True,
Message[SynthesiseStructure::InvalidSelectionMethod,selectionMethod];
Abort[]
]&@PadRight[{},A*B*C,blocks];

mapping=AssociationThread[Range@Length@blocks->blocks];

(* Relaying data to separate procedure *)
options=Thread[#->OptionValue[#],String]&/@(
First/@Options@SynthesiseStructure);
SynthesiseStructure[{{A,B,C},domains},outputName,mapping,Sequence@@options]
]


(* ::Input::Initialization:: *)
SynthesiseStructure[
{{inputA_Integer,inputB_Integer,inputC_Integer},inputDomains_List},
outputName_String,
integerToLabelMap_Association:<||>,
OptionsPattern[]]:=Block[{
domains=inputDomains,
A=inputA,B=inputB,C=inputC,
blocks,nonVoidRange,normalBlocks,
blockSizes,
outputSize,targetPositions,blockPositionsMap,blockCopy,blockCopies,
coordinatesCrystal,coordinatesCartesian,coordinatesCrystalEmbedded,newCoordinates,
hostM,hostMinverse,targetPositionsCartesian,M,T,
anchorShift=OptionValue["RotationAnchorShift"],
anchorReference=OptionValue["RotationAnchorReference"],
rotationAxes=OptionValue["RotationAxes"],
rotationMap=OptionValue["RotationMap"],
R,twist
},

(* Checking input *)
If[TrueQ@OptionValue["Padding"],
{{A,B,C},domains}=InputCheck["PadDomain",{{A,B,C},inputDomains}]];
blocks=domains/.Join[{0->"Void"},Normal@integerToLabelMap];
blocks=blocks/._Integer->"Void";
Check[Scan[InputCheck["CrystalEntityQ",#]&,DeleteDuplicates@blocks],Abort[]];


(* Handling special labels (chemcial elements or void) *)
InputCheck["HandleSpecialLabels",blocks];
nonVoidRange=Complement[Range[A*B*C],Flatten@Position[blocks,"Void"]];
normalBlocks=Part[blocks,nonVoidRange];
If[normalBlocks==={},
Message[SynthesiseStructure::NothingToBuild];Abort[]
];

(* Checking if all blocks have same size *)
blockSizes=($CrystalData[#,"Notes","StructureSize"]
/._Missing->{1,1,1})&/@blocks;
If[!SameQ@@blockSizes,
Message[SynthesiseStructure::DifferentBlockSizes];Abort[]];
blockSizes=First@blockSizes;

(* Checking if output size is valid *)
outputSize={A,B,C};
If[A*B*C!=Length@domains,
Message[SynthesiseStructure::SizeError];Abort[]];
If[(Length@outputSize!=3)||(AnyTrue[outputSize,Positive[#]\[Nand]IntegerQ[#]&]),
Message[SynthesiseStructure::InvalidOutputSize];Abort[]];
If[Total@MapThread[Mod,{outputSize,blockSizes}]=!=0,
Message[SynthesiseStructure::IncompatibleOutputSize];Abort[]];

(* Final preparations before synthesis *)
targetPositions=InputCheck["GenerateTargetPositions",outputSize];
blockPositionsMap=AssociationThread[targetPositions->blocks];
AppendTo[$CrystalData,outputName->$CrystalData@First@normalBlocks];
hostM=GetCrystalMetric[outputName,"ToCartesian"->True];
hostMinverse=Inverse@hostM;
targetPositionsCartesian=hostM . #&/@targetPositions;

If[rotationMap=!=<||>,
R=InputCheck["RotationTransformation",{outputSize,domains},
{anchorShift,anchorReference,rotationMap,rotationAxes},True]];

blockCopies=Reap[Do[
M=GetCrystalMetric[blocks[[i]],"ToCartesian"->True];
T=TranslationTransform[targetPositions[[i]]];

blockCopy=$CrystalData[blocks[[i]]];
coordinatesCrystal=blockCopy[["AtomData",All,"FractionalCoordinates"]];
coordinatesCartesian=M . #&/@coordinatesCrystal;
coordinatesCrystalEmbedded=hostMinverse . #&/@coordinatesCartesian;
newCoordinates=T/@coordinatesCrystalEmbedded;

If[rotationMap=!=<||>,
twist=R[domains[[i]],targetPositionsCartesian[[i]]];
coordinatesCartesian=hostM . #&/@newCoordinates;
coordinatesCartesian=twist@coordinatesCartesian;
newCoordinates=hostMinverse . #&/@coordinatesCartesian
];

blockCopy[["AtomData",All,"FractionalCoordinates"]]=newCoordinates;
Sow@blockCopy,
{i,nonVoidRange}
]][[2,1]];

$CrystalData[outputName,"AtomData"]=Flatten@blockCopies[[All,"AtomData"]];

If[!KeyExistsQ[$CrystalData[outputName],"Notes"],
AppendTo[$CrystalData[outputName],"Notes"-><||>]];
$CrystalData[outputName,"Notes","StructureSize"]=outputSize;

outputName
]


(* ::Input::Initialization:: *)
SynthesiseStructure[element_String,
latticeParameters_List:{5.,5.,5.,90.,90.,90.},
spaceGroup_:"P1",
inputLabel_String:""]:=Block[{
label=inputLabel,sg,chemicalFormula,atomData
},

(* Checks *)
If[InputCheck["FilterSpecialLabels",{element}]==={},
Message[SynthesiseStructure::ExpectedSpecialLabel,element];Abort[]];
If[!MatchQ[latticeParameters,{#,#,#,#,#,#}&[_?NumericQ]],
Message[SynthesiseStructure::InvalidLatticeParameters];Abort[]];
sg=InputCheck["InterpretSpaceGroup",spaceGroup];

(* Prepare crystal data *)
If[element==="Void",
chemicalFormula="";atomData={},

chemicalFormula=element;
atomData={<|"Element"->element,"FractionalCoordinates"->{0,0,0}|>}
];

(* Add to crystal database *)
If[label==="",label=element];
ImportCrystalData[
{label,chemicalFormula,0,spaceGroup,-1},
latticeParameters,
atomData,
"OverwriteWarning"->False]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
SystematicAbsentQ::InvalidSpaceGroup="Invalid space group: \[LeftGuillemet]`1`\[RightGuillemet].";

Options@SystematicAbsentQ={
(* Options from 'StructureFactor' *)
"Threshold"->0
};

SyntaxInformation@SystematicAbsentQ={
"ArgumentsPattern"->{_,_,OptionsPattern[]}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
SystematicAbsentQ[crystalOrSpaceGroup_,reflections_List,OptionsPattern[]]:=Block[{
crystalQ=True,spaceGroup,centeringVectors,rotations,translations,CheckAbsence,
r,t,\[Delta]=OptionValue["Threshold"],\[Lambda]
},

InputCheck[reflections,"Integer"];
spaceGroup=InputCheck["GetCrystalSpaceGroup",crystalOrSpaceGroup];

{rotations,translations}=Transpose@GetSymmetryOperations[
spaceGroup,"AugmentedMatrix"->False];
centeringVectors=Quiet@InputCheck["GetCentringVectors",spaceGroup];

(* Ony check structure factor if \[Delta] is numeric *)
If[NumericQ@\[Delta]&&\[Delta]>0,
\[Lambda]=Lookup[$CrystalData[crystalOrSpaceGroup],"Wavelength",1.0],
crystalQ=False
];

CheckAbsence[hkl_]:=(
(* General absence (centring) *)
If[!AllTrue[Dot[hkl,#]&/@centeringVectors,IntegerQ],Return@True];

(* Special absence (translation) *)
r=Equal[hkl,#]&/@Transpose[Transpose@rotations . hkl];
t=IntegerQ[hkl . #]&/@translations;
If[MemberQ[Transpose[{r,t}],{True,False}],Return@True];

(* Structure factor below threshold *)
If[crystalQ,If[Abs[First@StructureFactor[crystalOrSpaceGroup,hkl,\[Lambda],
"Units"->False,"IgnoreSystematicAbsence"->True]]<\[Delta],
Return@True]];

(* Not systematically absent reflection *)
False
);

If[MatrixQ@reflections,(* Multiple or single reflection(s) *)
Reap[Do[Sow[CheckAbsence@reflections[[i]]],{i,Length@reflections}]][[2,1]],
CheckAbsence@reflections
]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
ToStandardSetting::InvalidExtension="Invalid extension \[LeftGuillemet]`1`\[RightGuillemet] for this space group.";

SyntaxInformation@ToStandardSetting={
"ArgumentsPattern"->{_,_.}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ToStandardSetting[group_String,hkl_List]:=Block[{equivalents,nonNegatives},
InputCheck[hkl,"1hkl","Integer"];InputCheck["PointSpaceGroupQ",group];

equivalents=SymmetryEquivalentReflections[group,hkl];
nonNegatives=Select[equivalents,AllTrue[#,NonNegative]&];
If[nonNegatives=!={},equivalents=nonNegatives];

Last@SortBy[equivalents,{#[[3]]&,#[[2]]&,#[[1]]&}]
]


(* ::Input::Initialization:: *)
ToStandardSetting[input_String,extension_:1]:=Block[{
sg,fullHM,SG,
mainTargetQ,uniqueInSgQ,mainSetting,
output=input,temp
},

InputCheck["PointSpaceGroupQ",input];
sg=$GroupSymbolRedirect[input];
fullHM=sg["Name","HermannMauguinFull"];

temp=Position[$SpaceGroups,fullHM];
SG=$SpaceGroups[temp[[1,1,1]]];

(* Is target space group main setting? *)
mainTargetQ=Length@First@temp<=3;

(* Is target symbol unique among all space groups? *)
temp=Position[$SpaceGroups,sg["Name","Symbol"]];
If[!Length@DeleteDuplicates@temp[[All,1,1]]===1,
Return@fullHM];

(* Is target symbol unique in its space group? *)
uniqueInSgQ=Length@temp===1;	

	Which[
	(* With cell origin tag? *)
	extension=!=1,
	output=sg["Name","Symbol"]<>":"<>ToString@extension;
	If[!KeyExistsQ[$GroupSymbolRedirect,output],
	Message[ToStandardSetting::InvalidExtension,extension];Abort[]],

	(* Is target "best candidate" for non-main symbol? *)
	!uniqueInSgQ&&!mainTargetQ,
	mainSetting=First@SG["Setting"];
	If[First@sg["Setting"]===mainSetting,
	output=sg["Name","Symbol"],
	output=fullHM],

	(* Uniquely formatted symbol OR "main symbol"? *)
	uniqueInSgQ||mainTargetQ,
	output=$GroupSymbolRedirect[output]["Name","Symbol"],

	(* If ambiguous, use full Hermman--Mauguin *)
	True,
	output=fullHM
	];

Return@output
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
TransformAtomicDisplacementParameters::InvalidTransformation="The transformation input \[LeftGuillemet]`1`\[RightGuillemet] is invalid.";

SyntaxInformation@TransformAtomicDisplacementParameters={
"ArgumentsPattern"->{_,_.}
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
TransformAtomicDisplacementParameters[
crystal_,transformation_:"EquivalentIsotropic"]:=Block[{
ADPs,cartesianConverter,cartesianADPs
},

InputCheck["CrystalQ",crystal];
If[!MemberQ[{"CartesianConverter","EquivalentIsotropic"},transformation],
Message[TransformAtomicDisplacementParameters::InvalidTransformation,transformation];Abort[]];

cartesianConverter=$CartesianConverterMaker@crystal;
If[transformation==="CartesianConverter",
(* a. Transform ADPs to Cartesian basis -- returns function *)
Return@cartesianConverter];

If[transformation==="EquivalentIsotropic",
(* b. Calculate equivalent isotropic ADPs *)
ADPs=Lookup[$CrystalData[crystal,"AtomData"],"DisplacementParameters",0.];
cartesianADPs=cartesianConverter/@ADPs;
Mean/@Diagonal/@cartesianADPs
]
]


(* ::Input::Initialization:: *)
$CartesianConverterMaker[crystal_]:=Module[{
latticeReciprocal,toCartesian,n,U,dimensionlessU,CartesianConverter},
(* Reference: https://doi.org/10.1107/S0021889802008580 *)
latticeReciprocal=GetCrystalMetric[crystal,
"Category"->"LatticeParameters","Space"->"Reciprocal","Units"->False];
toCartesian=GetCrystalMetric[crystal,"ToCartesian"->True];
n=DiagonalMatrix@latticeReciprocal[[1;;3]];

CartesianConverter[ADPs_]:=(
If[NumericQ@ADPs,Return@DiagonalMatrix[{#,#,#}]&@ADPs
(* Alternatively: see '_cell.convert_Uiso_to_Uij' *)
(*ADPs*{{1,#3,#2},{#3,1,#1},{#2,#1,1}}&@@Cos@latticeReciprocal\[LeftDoubleBracket]4;;6\[RightDoubleBracket]*)];
U={{#1,#4,#5},{#4,#2,#6},{#5,#6,#3}}&@@ADPs;
dimensionlessU=n . U . n;
toCartesian . dimensionlessU . Transpose@toCartesian
);
CartesianConverter
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
UnitCellTransformation::command="Transformation command \[LeftGuillemet]`1`\[RightGuillemet] not recognised.";
UnitCellTransformation::invalid="The setting \[LeftGuillemet]`1`\[RightGuillemet] is invalid.";
UnitCellTransformation::invalidSG="The setting \[LeftGuillemet]`1`\[RightGuillemet] is invalid for this particular space group.";
UnitCellTransformation::na="Input not applicable for the `1` system.";
UnitCellTransformation::diffset="Setting mismatch between source, `1`, and target, `2`.";
UnitCellTransformation::sg="Could not interpret \[LeftGuillemet]`1`\[RightGuillemet] as a space group symbol.";
UnitCellTransformation::differentsg="The source space group, \[LeftGuillemet]`1`\[RightGuillemet] (no.`2`), and the target space group, \[LeftGuillemet]`3`\[RightGuillemet] (no. `4`), are not the same.";
UnitCellTransformation::support="Transformation of the input is not supported.";
UnitCellTransformation::target="Could not determine target space group.";
UnitCellTransformation::one="This space group, \[LeftGuillemet]`1`\[RightGuillemet] (no. `2`), has no alternative representations.";

Options@UnitCellTransformation={
"CustomP"->False,
"ReturnP"->False,
"MoveIfCellEmpty"->True
};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
UnitCellTransformation[crystal_String,userinput___]:=
Block[{
(*---* 1. Input check and preparation *---*)
(* 1.A. Load crystal metric, space group and crystal system *)
G,G0,sg,sg0,sourceSG,fullHM,posSG,SG,fullHMs,sourceSGnumber,system,mainSourceQ,
P,P1,P2,p,
centList,axpList,tetList,hex3List,hexList,monoList,
sourceSetting,targetSetting,
(* 1.B. Process input syntax and options *)
inputRules,inputString,returnP,customP,moveNegativeQ,
(* 1.C Process source setting *)
sourceCentring,sourceCell,notes,relevantNotes,sourceO,
(* 1.D. Interpret space group from input *)
targetSG,needtargetSG,
(* 1.E Process target setting *)
allowed,cmds,na,
(* 1.F. Validating input values *)
targetCentring,targetAxis,targetCC,targetAP,targetCell,targetRS,
targetO,
(* 1.G. Check setting constraints on certain space groups *)
(* 1.H. Determining new space group symbol *)
targetSGnumber,
(* 1.I. Common transformation procedures *)
procedureCellCentring,procedureCellOrigin,shift,
(*---* 2. Determining correct transformation matrices *---*)
(* 2.A. Triclinic *)
(* 2.B. Monoclinic *)
cmd,Q,
(* 2.C. Orthorhombic *)
(* 2.D. Tetragonal *)
(* 2.E. Hexagonal crystal family *)
sourceRS,M,
(* 2.F. Cubic *)
(*---* 3. Carrying out transformations *---*)
(* 3.A. Preparations *)
q,newlattice,
(* 3.B. Transforming coordinates and ADPs *)
xyz,newxyz,AnyInsideUnitCellQ,adps,U,n0,n,newU,u,
(*---* 4. Overwriting entry in $CrystalData *---*)
targetFullHM,
(*---* 5. Display *---*)

(* Dummy variables *)
temp,x,y,i},

(*---* 1. Input check and preparation *---*)
(* 1.A. Load crystal metric, space group and crystal system *)
	InputCheck["GetCrystalSpaceGroup",crystal];
	G=G0=GetCrystalMetric@crystal;
	sg=sg0=$CrystalData[crystal,"SpaceGroup"];
	sg=$GroupSymbolRedirect[sg];
	sourceSG=fullHM=sg["Name","HermannMauguinFull"];
	posSG=Position[$SpaceGroups,fullHM];
	SG=$SpaceGroups[posSG[[1,1,1]]];
	fullHMs=SG["Name","HermannMauguinFull"];
	sourceSGnumber=SG["SpaceGroupNumber"];
	system=SG["CrystalSystem"];
	mainSourceQ=Length@First@posSG<=3;

	(* Default transformation matrices and origin shift *)
	P=P1=P2=IdentityMatrix[3];
	p={0,0,0};

	(* Frequently used lists *)
	centList={
	"P","A","B","C","F","I"};
	axpList={
	"abc","ba-c","cab","-cba","bca","a-cb"};
	tetList={
	"P","I","C1","F1","C2","F2"};
	hex3List={
	"R1","R2","R3"};
	hexList={
	"C1","C2","C3","H1","H2","H3","D1","D2"};
	monoList={
	"Cb1","Cb2","Cb3","Ac1","Ac2","Ac3"};

	(* Miscellaneous *)
	sourceSetting=targetSetting=<||>;

(* 1.B. Process input syntax and options *)
	inputRules=Association@Cases[{userinput},_Rule];
	inputString=Cases[{userinput},_String];
		(* Check *)
		Which[
		#===0,Null,
		#===1,inputString=First@inputString,
		True,
			Message[UnitCellTransformation::invalid,inputString];
			Abort[]
		]&@Length@inputString;

	(* Save option settings *)
	returnP=inputRules["ReturnP"];
	customP=Lookup[inputRules,"CustomP",{}];
	moveNegativeQ=Lookup[inputRules,"MoveIfCellEmpty",True];

	(* Remove options from other settings *)
	KeyDropFrom[inputRules,
	{"ReturnP","CustomP","CustomSymbol"}];

(* 1.C Process source setting *)
	(* i. Load source setting from source space group *)
	sourceSetting=$GroupSymbolRedirect[sourceSG]["Setting"];

	(* ii. Check if space group has alternative settings *)
	If[sourceSetting===<||>&&
	(* Exception: Special multiple cells *)
	!MemberQ[{"Tetragonal","Hexagonal"},system],
		Message[UnitCellTransformation::one,
		GetSymmetryData[sourceSG,"Symbol"],
		sourceSGnumber];
		Abort[]];

	(* iii. Check cell origin from symbol *)
	temp=StringTake[sg0,-2];
	Which[
	temp===":2",AppendTo[sourceSetting,"CellOrigin"->2]
	];

	(* iv. Checking 'Notes' for info on input setting *)
	notes=Lookup[$CrystalData@crystal,"Notes",<||>];
	relevantNotes=notes[[{
	"RhombohedralSetting","MultipleCell","CellCentring","CellOrigin"}]];
	{sourceRS,sourceCell,sourceCentring,sourceO}=Values@relevantNotes;
	AppendTo[sourceSetting,DeleteMissing@relevantNotes];

(* 1.D. Interpret space group from input *)
	(* i. No input commands -- prompt dialogue/UI (TODO) *)
	
	(* ii. Custom transformation matrix *)
	If[customP=!={},P1=customP;
	If[!MatrixQ@P1,(* Check *)
	Message[UnitCellTransformation::invalid,P1];Abort[]];
	targetSG=sourceSG(* Use same space group *);
	Goto["MetricTransformation"]];

	(* iii. Interpret string as target space group *)
	If[inputString=!={},

		(* Check if valid space group symbol *)
		If[MissingQ@$GroupSymbolRedirect[inputString],
		Message[UnitCellTransformation::sg,inputString];
		Abort[]];

		targetSG=inputString];

	(* iv. Parse input as setting commands *)
	If[inputRules=!=<||>,
	needtargetSG=True,
		(* Check whether Hall symbol has been used *)
		temp=Position[$SpaceGroups,targetSG];
		If[temp!={},
		If[temp[[1,-1,1]]==="HallString",
		targetSG=First[$SpaceGroups@@@
		Most@First@temp]["Name","Symbol"]]]
	];

(* 1.E Process target setting *)
	If[inputRules=!=<||>,
	(* a. Setting commands given in association *)
		targetSetting=inputRules;

			(* Checking commands *)
			allowed={
			"UniqueAxis","CellChoice","AxisPermutation",
			"CellCentring","MultipleCell",
			"RhombohedralSetting","CellOrigin"};
			cmds=Keys@targetSetting;
			na=Complement[cmds,allowed];
				If[na!={},
				Message[UnitCellTransformation::command,First@na];
				Abort[]];

			(* Checking usefullness of commands *)
			temp=Which[
			system==="Triclinic",
				{"CellCentring"},
			system==="Monoclinic",
				{"UniqueAxis","CellChoice"},
			system==="Orthorhombic",
				{"AxisPermutation","CellCentring","CellOrigin"},
			system==="Tetragonal",
				{"CellCentring","MultipleCell","CellOrigin"},
			system==="Trigonal",
				{"MultipleCell","RhombohedralSetting"},
			system==="Hexagonal",
				{"MultipleCell"},
			system==="Cubic",
				{"CellCentring","CellOrigin"}
			];

			targetSetting=DeleteMissing@targetSetting[[temp]];
			If[targetSetting===<||>,
			Message[UnitCellTransformation::na,
			ToLowerCase@system];
			Abort[]],

		(* b. Setting extracted from target space group *)
		If[!ValueQ@targetSG,targetSG=sourceSG];
		targetSetting=$GroupSymbolRedirect[targetSG]["Setting"]
	];

	(* Supply with current settings if unspecified in input *)
	targetSetting=Append[sourceSetting,targetSetting];
		(* Exception: No 'RhombohedralSetting' for 'R' cell *)
		If[targetSetting["MultipleCell"]==="R",
		KeyDropFrom[targetSetting,"RhombohedralSetting"]]; 

(* 1.F. Validating input values *)
	(* i. 'CellCentring' *)
	targetCentring=targetSetting["CellCentring"];
	If[!MissingQ@targetCentring,
	If[!MemberQ[centList,
	targetCentring],
	Message[UnitCellTransformation::invalid,
	targetCentring];Abort[]
	]];

	(* ii. 'UniqueAxis' *)
	targetAxis=targetSetting["UniqueAxis"];
	If[!MissingQ@targetAxis,
	If[!MemberQ[{"a","b","c"},targetAxis],
	Message[UnitCellTransformation::invalid,
	targetAxis];Abort[]];
	targetAxis=ToLowerCase@targetAxis
	];

	(* iii. 'CellChoice' *)
	targetCC=targetSetting["CellChoice"];
	If[!MissingQ@targetCC,
	If[!MemberQ[{1,2,3},targetCC],
	Message[UnitCellTransformation::invalid,
	targetCC];Abort[]]
	];

	(* iv. 'AxisPermutation' *)
	targetAP=targetSetting["AxisPermutation"];
	If[!MissingQ@targetAP,
	(* Check if string *)
	If[!StringQ@targetAP,
	Message[UnitCellTransformation::invalid,
	targetAP];Abort[]];
	(* Support for various input forms *)
	targetAP=ToLowerCase@StringReplace[
	targetAP,{"\!\(\*OverscriptBox[\(c\), \(_\)]\)"->"-c","\!\(\*OverscriptBox[\(C\), \(_\)]\)"->"-C"}];
	(* Check setting value *)
	If[!MemberQ[axpList,targetAP],
	Message[UnitCellTransformation::invalid,
	targetSetting["AxisPermutation"]];Abort[]];
	(* Update 'targetSetting' *)
	targetSetting["AxisPermutation"]=targetAP];

	(* v. 'MultipleCell' *)
	targetCell=targetSetting["MultipleCell"];
	If[!MissingQ@targetCell,
	(* Depending on crystal system... *)
	temp=Which[
	system==="Tetragonal",tetList,
	system==="Trigonal"||system==="Hexagonal",
		Flatten@Join[
		{"P","R"},hex3List,hexList,monoList],
	True,
		Message[UnitCellTransformation::na,
		ToLowerCase@system];Abort[]];
	(* Check setting value *)
	If[!MemberQ[temp,targetCell],
	Message[UnitCellTransformation::invalidSG,
	targetCell];Abort[]]
	];

	(* vi. 'RhombohedralSetting' *)
	targetRS=inputRules["RhombohedralSetting"];
	If[!MissingQ@targetRS,
	targetRS=ToLowerCase@targetRS;
	(* Check setting value *)
	If[!MemberQ[{"obverse","reverse"},targetRS],
	Message[UnitCellTransformation::invalid,
	targetSetting["RhombohedralSetting"]];Abort[]];
	(* Update 'targetSetting' *)
	targetSetting["RhombohedralSetting"]=targetRS
	];

	(* vii. 'CellOrigin' *)
	targetO=targetSetting["CellOrigin"];
	If[!MissingQ@targetO,
	If[!MemberQ[{1,2},targetO],
	Message[UnitCellTransformation::invalid,
	targetO];Abort[]]
	];

(* 1.G. Check setting constraints on certain space groups *)
	(* i. Target setting must be a subset of space group settings *)
	If[!(SubsetQ@@Keys/@{SG["Setting"],
Which[(* Exceptions: Cell centring and special multiple cells *)
MemberQ[{"Tetragonal","Hexagonal"},system],
	KeyDrop[targetSetting,"MultipleCell"],
MemberQ[{"Monoclinic","Orthorhombic","Tetragonal","Cubic"},system],
	KeyDrop[targetSetting,"CellCentring"],
True,
	targetSetting]}
	),Message[UnitCellTransformation::diffset,
		Keys@sourceSetting,Keys@targetSetting];Abort[]
	];

(* 1.H. Determining new space group symbol *)
	(* i. Determine the target space group from setting if needed *)
		If[needtargetSG,
		(* Main entry? *)
		If[Sort@SG["Setting"]===Sort@targetSetting,
		targetSG=SG["Name","HermannMauguinFull"],
			(* Special multiple cell? *)
			If[MemberQ[Flatten@Join[
			{tetList,{"R"},hex3List,hexList,monoList}],
			targetCell],
			targetSG=sourceSG;
			targetSGnumber=sourceSGnumber;
			Goto["CheckSGformat"]
			];

		(* Check alternatives *)
		temp=SG[["AlternativeSettings"]];
		i=1;
		While[True,
		If[i>Length@temp,
		Message[UnitCellTransformation::target];Abort[]];
		If[Sort@temp[[i,"Setting"]]===Sort@targetSetting,
		targetSG=temp[[i,"Name","HermannMauguinFull"]];
		Break[]];
		i++]
		]];

	(* ii. Check if source and target are same space group *)
	targetSGnumber=GetSymmetryData[targetSG,"SpaceGroupNumber"];

	If[sourceSGnumber!=targetSGnumber,
	Message[UnitCellTransformation::differentsg,
	GetSymmetryData[sourceSG,"Symbol"],sourceSGnumber,
	GetSymmetryData[targetSG,"Symbol"],targetSGnumber];
	Abort[]];

	(* iii. Check whether to use formatted symbol *)
	Label["CheckSGformat"];
	targetSG=ToStandardSetting@targetSG;

(* 1.I. Common transformation procedures *)
	(* 'CellCentring' *)
	procedureCellCentring:=(
	If[!MissingQ@targetCentring,
	If[MissingQ@sourceCentring||!ValueQ@sourceCentring,
	sourceCentring=StringTake[fullHM,1]];

	Which[
	(* No change *)
	sourceCentring===targetCentring,
	Null,

	(* Transformation from 'P' *)
	sourceCentring==="P",
	P1=Inverse@$TransformationMatrices[
	targetCentring<>"_to_P"],

	(* Transformation to 'P' *)
	targetCentring==="P",
	P1=$TransformationMatrices[sourceCentring<>"_to_P"],

	(* Transformation via 'P' *)
	True,
	P1=$TransformationMatrices[sourceCentring<>"_to_P"];
	P2=Inverse@$TransformationMatrices[targetCentring<>"_to_P"]
	]
	]);

	(* 'CellOrigin' *)
	procedureCellOrigin:=(
	If[KeyExistsQ[targetSetting,"CellOrigin"],
	temp={sourceSetting["CellOrigin"],targetO};
	shift=SG[["AlternativeSettings",1,"OriginShift"]];
	If[!MissingQ@targetO,
	(* Get space group origin shift (shift vector) *)
	Which[
	temp==={1,1},Null,
	temp==={2,2},Null,
	temp==={1,2},p=shift,
	temp==={2,1},p=-shift]
	]
	]);


(*---* 2. Determining correct transformation matrices *---*)
Goto[system];

(*-- 2.A. Triclinic --*)
Label["Triclinic"];

	(* i. 'CellCentring' *)
	procedureCellCentring;

	(* Preparations done *)
	Goto["MetricTransformation"];


(*-- 2.B. Monoclinic --*)
Label["Monoclinic"];

	(* Prepartations *)
		(* If target axis not given, use same axis as source *)
		If[MissingQ@targetAxis||!ValueQ@targetAxis,
		targetAxis=sourceSetting["UniqueAxis"]];

	(* i. 'UniqueAxis' *)
		(* Target unique axis transformation *)
		allowed={
		"UniqueAxisB_to_C",
		"UniqueAxisB_to_A",
		"UniqueAxisC_to_A"};

		temp=ToUpperCase/@{sourceSetting["UniqueAxis"],targetAxis};
	
		(* Check whether P or Q (inverse) is needed *)
		cmd="UniqueAxis"<>temp[[1]]<>"_to_"<>temp[[2]];
		If[MemberQ[allowed,cmd],
		Q=False,
		Q=True;
			cmd="UniqueAxis"<>temp[[2]]<>"_to_"<>temp[[1]]
		];

		(* Target unique axis transformation *)
		If[!SameQ@@temp,
		P1=$TransformationMatrices[cmd];
		If[Q,P1=Inverse@P1]
		];

	(* ii. 'CellChoice' *)
		(* Check if cell choice is an available setting *)		
		If[!KeyExistsQ[SG["Setting"],"CellChoice"]
		&&KeyExistsQ[targetSetting,"CellChoice"],
		Message[UnitCellTransformation::command,"CellChoice"];
		Abort[],

		If[!MissingQ@targetCC,
		(* Matrix for checking transformation signature *)
		temp={{0,1,-1},{-1,0,1},{1,-1,0}};
		temp=temp[[sg["Setting","CellChoice"],targetCC]];
		(* Use regular, none, or inverse transformation *)
		Which[
		temp===-1,Q=True,
		temp===0,Goto["MetricTransformation"],
		temp===1,Q=False
		];
		cmd="UniqueAxis"<>ToUpperCase@targetAxis
		<>"_CellChoice+1";
		P2=$TransformationMatrices[cmd];
		If[Q,P2=Inverse@P2];
		]];

	(* Preparations done *)
	Goto["MetricTransformation"];


(*-- 2.C. Orthorhombic --*)
Label["Orthorhombic"];

	(* i. 'AxisPermutation' *)
		If[!MissingQ@targetAP,
		(* Check which matrices are needed *)
		temp=ToUpperCase/@
		{sourceSetting["AxisPermutation"],targetAP};
		If[SameQ@@temp,
		(* Same axis permutation -- no transform required *)
		Null,
		If[!MemberQ[temp,"DEF"],
		(* Chain through 'abc' *)
		x=temp[[1]]<>"_to_DEF";
		y=temp[[2]]<>"_to_DEF";
		P1=$TransformationMatrices[x];
		P2=Inverse@$TransformationMatrices[y],
		(* OR use one of the six transformations *)
		cmd=temp[[1]]<>"_to_"<>temp[[2]];
		If[KeyExistsQ[$TransformationMatrices,cmd],
		P1=$TransformationMatrices[cmd],
		P1=Inverse@$TransformationMatrices[
	temp[[2]]<>"_to_"<>temp[[1]]]
		]
		]
		]
		];

	(* ii. 'CellOrigin' *)
	procedureCellOrigin;

	(* Preparations done *)
	Goto["MetricTransformation"];


(*-- 2.D. Tetragonal --*)
Label["Tetragonal"];

	(* Checks and updates *)
	If[MissingQ@sourceCentring||!ValueQ@sourceCentring,
	sourceCentring=StringTake[
	sg["Name","HermannMauguinShort"],1]];

	If[MissingQ@targetCentring||!ValueQ@targetCentring,
	targetCentring=StringTake[
	SG["Name","HermannMauguinShort"],1]];

	(* i. 'CellCentring' *)
	procedureCellCentring;

	(* ii. 'MultipleCell' *)
	If[KeyExistsQ[targetSetting,"MultipleCell"],
	(* If already transformed, transform to 'P' or 'I' *)
	If[MemberQ[tetList,sourceCell],
	P1=Inverse@$TransformationMatrices[
	"TetragonalProjection"<>StringTake[sourceCell,-1]]
	];

	(* Transforming to target cell *)
	If[!MemberQ[{"P","I"},targetCell],
	P2=$TransformationMatrices[
	"TetragonalProjection"<>StringTake[targetCell,-1]]
	]
	];
	
	(* iii. 'CellOrigin' *)
	procedureCellOrigin;

	(* Preparations done *)
	Goto["MetricTransformation"];


(*-- 2.E. Hexagonal crystal family --*)
Label["Trigonal"];
Label["Hexagonal"];

	(* Checks and updates *)
		(* Reinstate 'MultipleCell' label *)
		If[MissingQ@sourceCell||!ValueQ@sourceCell,
		sourceCell=sourceSetting["MultipleCell"]];

		(* Check rhombohedral source setting *)
		If[MissingQ@sourceRS||!ValueQ@sourceRS,
		(* Assume main space group setting *)
		sourceRS="obverse"];

		(* Check rhombohedral target setting *)
		If[MissingQ@targetRS&&MemberQ[hex3List,targetCell],targetRS="obverse"];
		If[!MissingQ@targetRS&&targetCell==="R",targetCell="R1"];

	Which[
	(* A. Rhombohedral space group *)
	SubsetQ[{146,148,155,160,161,166,167},
	{sourceSGnumber,targetSGnumber}],

		(* Check target command *)
		If[!MemberQ[Flatten@Join[
	{{"R"},hex3List,monoList}],targetCell],
		Message[UnitCellTransformation::invalidSG,
			targetCell];Abort[]];

		Which[
		(* a. Rhombohedral source *)
		sourceCell==="R",
		Which[
		(* a.1. Rhombohedral target *)
		targetCell==="R"&&MissingQ@targetRS,
			Goto["MatricesDone"],

		(* a.2. Triple hexagonal target *)
		MemberQ[hex3List,targetCell],
		P1=$TransformationMatrices[
		"Rhombohedral_to_"<>targetCell<>"_"<>targetRS],

		(* a.3. Monoclinic target *)
		True,
		P1=$TransformationMatrices[
		"Rhombohedral_to_Monoclinic_"<>targetCell]
		],

		(* b. Regular hexagonal (R1, R2, R3) source *)
		MemberQ[hex3List,sourceCell],
		Which[
		(* b.1. Rhombohedral target *)
		targetCell==="R",
		P1=Inverse@$TransformationMatrices[
		"Rhombohedral_to_"<>sourceCell<>"_"<>sourceRS],

		(* b.2. Triple hexagonal target *)
		MemberQ[hex3List,targetCell],
		If[sourceCell===targetCell&&sourceRS===targetRS,
		Goto["MatricesDone"]];
		P1=Inverse@$TransformationMatrices[
		"Rhombohedral_to_"<>sourceCell<>"_"<>sourceRS];
		P2=$TransformationMatrices[
		"Rhombohedral_to_"<>targetCell<>"_"<>targetRS],

		(* b.3. Monoclinic target *)
		True,
		If[sourceCell==="R1"&&sourceRS==="obverse",
		P1=$TransformationMatrices[
		"TripleHexagonal_to_Monoclinic_"<>targetCell],
		P1=Inverse@$TransformationMatrices[
		"Rhombohedral_to_"sourceCell<>"_"<>sourceRS];
		P2=$TransformationMatrices[
		"Rhombohedral_to_Monoclinic_"<>targetCell]]
		],


		(* c. Monoclinic source *)
		MemberQ[monoList,sourceCell],
		Which[
		(* c.1. Rhombohedral target *)
		targetCell==="R",
		P1=Inverse@$TransformationMatrices[
		"Rhombohedral_to_Monoclinic_"<>sourceCell],

		(* c.2. Regular hexagonal (R1, R2, R3)l target *)
		MemberQ[hex3List,targetCell],
		P1=Inverse@$TransformationMatrices[
		"Rhombohedral_to_Monoclinic_"<>sourceCell];
		P2=$TransformationMatrices[
		"Rhombohedral_to_"<>targetCell<>"_"<>targetRS],

		(* c.3. Monoclinic target *)
		True,
		If[sourceCell===targetCell,Goto["MatricesDone"]];
		P1=Inverse@$TransformationMatrices[
		"Rhombohedral_to_Monoclinic_"<>sourceCell];
		P2=$TransformationMatrices[
		"Rhombohedral_to_Monoclinic_"<>targetCell]
		]
		],
	

	(* B. Transformation of the hexagonal lattice *)
	True,
	
	(* Check if target is valid *)
	If[!MemberQ[Flatten@Join[
	{{"P"},hexList,monoList}],targetCell],
		Message[UnitCellTransformation::invalidSG,
			targetCell];Abort[]];

	M=Flatten@DeleteCases[
	StringCases[Keys@$TransformationMatrices,
	StartOfString~~"Hexagonal"~~__],{}];

	If[MissingQ@sourceCell,sourceCell="P"];

		Which[
		(* a. Primitive hexagonal source *)
		sourceCell==="P",
		Which[
		(* a.1. No change *)
		targetCell==="P",Goto["MatricesDone"],
		(* a.2. Special hexagonal target *)
		MemberQ[hexList,targetCell],
		temp=Select[M,StringContainsQ[#,targetCell]&];
		P1=$TransformationMatrices@@temp
		],

		(* b. Special hexagonal source *)
		MemberQ[hexList,sourceCell],
		Which[
		(* b.1. To primitive hexagonal cell *)
		targetCell==="P",
		temp=Select[M,StringContainsQ[#,targetCell]&];
		P1=Inverse@$TransformationMatrices@@temp,

		(* b.2. To special hexagonal target *)
		MemberQ[hexList,targetCell],
		If[sourceCell===targetCell,Goto["MatricesDone"]];
		temp=Select[M,StringContainsQ[#,sourceCell]&];
		P1=Inverse[$TransformationMatrices@@temp];
		temp=Select[M,StringContainsQ[#,targetCell]&];
		P2=$TransformationMatrices@@temp
		]
		]
	];
	Label["MatricesDone"];

	(* Preparations done *)
	Goto["MetricTransformation"];


(*-- 2.F. Cubic --*)
Label["Cubic"];

	(* i. 'CellCentring' *) 
	procedureCellCentring;

	(* ii. 'CellOrigin' *)
	procedureCellOrigin;

	(* Preparations done *)
	Goto["MetricTransformation"];


(*---* 3. Carrying out transformations *---*)
(* 3.A. Preparations *)
Label["MetricTransformation"];
	P=P1 . P2;
		If[returnP===All,Return@{P1,P2}];
		If[returnP,Return@P];
	Q=Inverse@P;
	q=-Q . p;
	G=Transpose[P] . G . P;

	newlattice=Association@Thread[
{"a","b","c","\[Alpha]","\[Beta]","\[Gamma]"}
->GetLatticeParameters[G,"Units"->True]];

(* 3.B. Transforming coordinates and ADPs *)
(* Fractional coordinates *)
xyz=$CrystalData[[crystal,
"AtomData",All,"FractionalCoordinates"]];
newxyz=Chop[FractionalPart[Dot[Q,#]+q]&/@xyz];

(* Optional: Move content to unit cell if empty *)
If[TrueQ@moveNegativeQ,
AnyInsideUnitCellQ[allCoordinates_]:=Or@@Map[
AllTrue[#,0<=#<=1&]&,allCoordinates];
If[Length@newxyz<=100&&!AnyInsideUnitCellQ@newxyz,
newxyz=Transpose[Transpose@newxyz-First@Sort@Floor@newxyz]
]];

(* Atomic displacement parameters *)	adps=Lookup[$CrystalData[crystal,"AtomData"],"DisplacementParameters",0.];
U={{#1,#4,#5},{#4,#2,#6},{#5,#6,#3}}&@@#&/@adps;

(* Preparing diagonal 'N' matrices *)
(* References:
https://doi.org/10.1107/S0108767311018216
https://doi.org/10.1107/S0021889802008580 *)
n0=DiagonalMatrix@Sqrt@Diagonal@Inverse@G0;
n=Inverse@DiagonalMatrix@Sqrt@Diagonal@Inverse@G;

(* Transforming ADPs *)
newU={};
Do[
u=U[[i]];
If[MatrixQ[u],
temp=n0 . u . Transpose[n0];
temp=Q . temp . Transpose[Q];
temp=Chop[n . temp . Transpose[n]];
temp=Part[temp,#/.List->Sequence]&/@
{{1,1},{2,2},{3,3},{1,2},{1,3},{2,3}},
temp=u];
AppendTo[newU,temp],
{i,Length@adps}
];


(*---* 4. Overwriting entry in $CrystalData *---*)
	(* Determine new space group symbol automatically *)
		(* Remove old cell tag *)
		If[StringTake[targetSG,{-2}]===":",
		targetSG=StringTake[targetSG,{1,-3}]];

		(* Update space group symbol *)
		If[(targetO===2||targetSetting["CellOrigin"]===2)&&
		!StringContainsQ[targetSG,":2"],
		targetSG=targetSG<>":2"];

		(* Get full Hermann\[Dash]Mauguin symbol *)
		targetFullHM=GetSymmetryData[targetSG,"HermannMauguinFull"];

		(* Set new symbol *)
		$CrystalData[crystal,"SpaceGroup"]=targetSG;

	(* New lattice parameters *)
	AppendTo[$CrystalData[crystal,
	"LatticeParameters"],newlattice];

	(* New fractional coordinates *)
	$CrystalData[[crystal,"AtomData",All,
	"FractionalCoordinates"]]=newxyz;

	(* New ADPs *)
	If[!AllTrue[N@newU,#==0.&],
	$CrystalData[[crystal,"AtomData",All,
	"DisplacementParameters"]]=newU];

	(* Updating 'Notes' and adding space group notes if needed *)
	If[
	(* a. Exception: default space group setting *)
	Sort@Values@SG["Setting"]===
	Sort@DeleteMissing@{targetCell,targetRS,targetCentring},
	KeyDropFrom[notes,{"MultipleCell","RhombohedralSetting","CellCentring"}],


	(* b. Write both multiple cell and rhombohedral setting *)
	If[KeyExistsQ[targetSetting,"MultipleCell"]&&
	!MemberQ[{"P","I"},targetCell],
	AppendTo[notes,"MultipleCell"->targetCell]];
	
	If[MemberQ[hex3List,targetCell],
	AppendTo[notes,"RhombohedralSetting"->targetRS],
	KeyDropFrom[notes,"RhombohedralSetting"]];

	If[!MissingQ@targetCentring&&ValueQ@targetCentring&&
	(* No need if centring is in space group symbol *)
	StringTake[targetFullHM,1]!=targetCentring,
	AppendTo[notes,"CellCentring"->targetCentring]]
	];

	(* Writing over 'Notes' or removing if empty *)
	If[notes=!=<||>,
	$CrystalData[crystal,"Notes"]=Sort@notes,
	KeyDropFrom[$CrystalData[crystal],"Notes"]
	];


(*---* 5. Display *---*)
Label["End"];
InputCheck["ShallowDisplayCrystal",crystal]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
$CrystalData::type="The atomic displacement type \[LeftGuillemet]`1`\[RightGuillemet] is not recognised.";
$CrystalData::missing="Could not find \[LeftGuillemet]`1`\[RightGuillemet].";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$CrystalData:=$CrystalData=Import[
FileNameJoin[{$MaXrdPath,"UserData","CrystalData.m"}],"Package"];


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
$GroupSymbolRedirect::missing="Could not find \[LeftGuillemet]`1`\[RightGuillemet].";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$GroupSymbolRedirect:=$GroupSymbolRedirect=Import[FileNameJoin[{$MaXrdPath,"Core","Data","GroupSymbolRedirect.m"}],"Package"];


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
$LaueClasses::notLaue="\[LeftGuillemet]`1`\[RightGuillemet] is not a valid Laue class.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$LaueClasses:=$LaueClasses=$PointGroups[[{"-1","2/m","mmm","4/m","4/mmm","-3","-3m","6/m","6/mmm","m-3","m-3m"}]];


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
$MaXrdChangelog::fileMissing="Cannot find the `1` file (`2`).";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$MaXrdChangelog:=Block[{
dir=$MaXrdPath,
pacletFile,packletVersion,
packageSymbols,
changelogFile,log,current,content,new,t,title,post,
temp},
(* Load current version -- could be undeployed *)
	pacletFile=FileNames["PacletInfo.m",{#}]
	&/@{dir,ParentDirectory@dir};
	pacletFile=Cases[pacletFile,_String,2,1];

	If[pacletFile==={},
	Message[$MaXrdChangelog::fileMissing,"paclet",pacletFile];
	Abort[],
	pacletFile=pacletFile[[1]]
	];

	packletVersion=(Association@@Import@pacletFile)[Version];

(* Latest entry in the changelog *)
	changelogFile=FileNames["Changelog.md",{dir},2][[1]];
	If[!FileExistsQ@changelogFile,
	Message[$MaXrdChangelog::fileMissing,"changelog",changelogFile];
	Abort[]];
	log=Import[changelogFile,"Text"];
	
	current=Check[StringCases[log,Shortest[
"## Version "~~packletVersion~~"\n"~~news__~~
{"\n\n\n##",EndOfString}]:>news],
	Abort[]];

	(* Content *)
	content=StringSplit[First@current,"\n"..];
	content=StringDrop[#,2]&/@content;
	content=TextCell[Row[{#}],"Item"]&/@content;

	(* Format function names *)
	packageSymbols=First/@Cases[
	Flatten@First@$MaXrdFunctions,_Hyperlink];
	new={};
	Do[
	temp=content[[i,1,1,1]];
	t={StartOfString,"",".",",","!"};
	AppendTo[new,
	Row@StringSplit[temp,{
	Shortest[a:t~~"**"~~x__~~"**"~~b:t]:>
	Style[a<>x<>b,Bold],
	Shortest[a:t~~"_"~~x__~~"_"~~b:t]:>
	Style[a<>x<>b,Italic],
	Shortest[a:t~~"*"~~x__~~"*"~~b:t]:>
	Style[a<>x<>b,Italic],
	Shortest[a:t~~"`"~~x__~~"`"~~b:t]:>
	If[MemberQ[packageSymbols,x],
	Hyperlink[x,"paclet:/MaXrd/Ref/"<>x],
	Style[a<>x<>b,"Program"]]
	}]],
	{i,Length@content}];

	new=(
first=#[[1,1]];
If[StringQ@first&&StringTake[first,2]==="# ",
TextCell[
ReplacePart[#,{1,1}->StringDrop[first,2]],
"Subsubsection"],
TextCell[#,"Item"]
])&/@new;

(* Title *)
	title=TextCell@Row[Style[#,"Text",
FontSize->24,
FontFamily->"Source Sans Pro",
Italic]&/@{
"Changelog for the MaXrd",
" package \[LongDash] version "<>packletVersion}
];

(* Log file link *)
	MaXrd`Private`$changelogFile=changelogFile;
	post=TextCell[
	Row[{
	Mouseover[#1,#2]&@@(Button["Click here",
SystemOpen@MaXrd`Private`$changelogFile,
Appearance->"Frameless",
BaseStyle->{"GenericButton",#}]&/@{
RGBColor[0.269993,0.308507,0.6],
RGBColor[0.823529411764706,0.490196078431373,0.133333333333333]}),
" to see the complete changelog of all versions."
	}],
	"Item"
	];

(* Print all cells *)
CreateDocument[CellGroup@Join[{title},new,{Row[{}]},{post}],CellGrouping->Manual]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$MaXrdFunctions:=$MaXrdFunctions=
Block[{subContexts,packagefunctions,packagef,hyperlinks},
subContexts=Select[Contexts["MaXrd`*"],!StringContainsQ[#,"Private"]&];
packagefunctions=#->Names[#<>"*"]&/@subContexts;
packagef=Sort@Flatten@packagefunctions[[All,2]];
hyperlinks=Hyperlink[#,"paclet:/MaXrd/Ref/"<>#]&/@packagef;
Multicolumn[hyperlinks,2]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
$MaXrdPath::MissingDefinitionsFile="Unable to locate the package definition file.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$MaXrdPath:=$MaXrdPath=Block[{files,prioritisedFile,definitionFile},
files=FileNames["MaXrd/Core/Definitions.m",$Path];
If[files==={},
Message[$MaXrdPath::MissingDefinitionsFile];Abort[]];
prioritisedFile=Select[files,StringContainsQ[#,FileNameJoin[
{"Mathematica","Applications","MaXrd","Core","Definitions.m"}]]&];
definitionFile=If[prioritisedFile=!={},
prioritisedFile,files][[1]];
DirectoryName[definitionFile,2]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$MaXrdVersion:=Block[{dir,p},
(* Load current version *)
	dir=$MaXrdPath;
	p=FileNameJoin[{dir,"PacletInfo.m"}];
	First@StringCases[Import[p,"String"],
	Shortest[Whitespace~~"Version -> \""~~v__~~"\""]:>v]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$PeriodicTable:=$PeriodicTable=Import[
FileNameJoin[{$MaXrdPath,"Core","Data","PeriodicTable.m"}],"Package"];


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
$PointGroups::symbol="No data found on \[LeftGuillemet]`1`\[RightGuillemet].";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$PointGroups:=$PointGroups=Import[FileNameJoin[{$MaXrdPath,"Core","Data","PointGroups.m"}],"Package"];


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
$SpaceGroups::symbol="No data found on \[LeftGuillemet]`1`\[RightGuillemet].";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$SpaceGroups:=$SpaceGroups=Import[FileNameJoin[{$MaXrdPath,"Core","Data","SpaceGroups.m"}],"Package"];


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(* Messages, options, attributes and syntax information *)


(* ::Input::Initialization:: *)
$TransformationMatrices::incompatible="Incompatible transformation request.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$TransformationMatrices:=$TransformationMatrices=Import[FileNameJoin[{$MaXrdPath,"Core","Data","TransformationMatrices.m"}],"Package"];


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
EndPackage[];
